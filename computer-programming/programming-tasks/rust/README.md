- [Fibonacci sequence](#sec-1)
- [Conditional structures](#sec-2)
- [Factorial](#sec-3)
- [100 doors](#sec-4)
- [Sieve of Eratosthenes](#sec-5)
- [Arrays](#sec-6)
- [Hello world/Text](#sec-7)
- [FizzBuzz](#sec-8)
- [String length](#sec-9)
- [Comments](#sec-10)
- [Function definition](#sec-11)
- [Ackermann function](#sec-12)
- [Hello world/Newbie](#sec-13)
- [Collections](#sec-14)
- [Reverse a string](#sec-15)
- [Greatest common divisor](#sec-16)
- [Hailstone sequence](#sec-17)
- [A+B](#sec-18)
- [Hamming numbers](#sec-19)
- [Empty program](#sec-20)
- [Greatest element of a list](#sec-21)
- [Palindrome detection](#sec-22)
- [Call a function](#sec-23)
- [Quine](#sec-24)
- [Generic swap](#sec-25)
- [Loop over multiple arrays simultaneously](#sec-26)
- [Repeat a string](#sec-27)
- [99 Bottles of Beer](#sec-28)
- [Associative array/Creation](#sec-29)
- [Averages/Arithmetic mean](#sec-30)
- [Apply a callback to an array](#sec-31)
- [Loops/Foreach](#sec-32)
- [Remove duplicate elements](#sec-33)
- [Hello world/Graphical](#sec-34)
- [Binary search](#sec-35)
- [ABC Problem](#sec-36)
- [Loops/For](#sec-37)
- [N-queens problem](#sec-38)
- [Happy numbers](#sec-39)
- [Pascal's triangle](#sec-40)
- [Arithmetic/Integer](#sec-41)
- [Day of the week](#sec-42)
- [Filter](#sec-43)
- [Array concatenation](#sec-44)
- [Even or odd](#sec-45)
- [Binary digits](#sec-46)
- [Roman numerals/Encode](#sec-47)
- [Loops/While](#sec-48)
- [Loops/For with a specified step](#sec-49)
- [Tokenize a string](#sec-50)
- [Factors of an integer](#sec-51)
- [Sorting algorithms/Quicksort](#sec-52)
- [Loops/Infinite](#sec-53)
- [Boolean values](#sec-54)
- [Caesar cipher](#sec-55)
- [Increment a numerical string](#sec-56)
- [Sum and product of an array](#sec-57)
- [Anagrams](#sec-58)
- [File input/output](#sec-59)
- [Permutations](#sec-60)
- [Character codes](#sec-61)
- [Stack](#sec-62)
- [Sorting algorithms/Bubble sort](#sec-63)
- [Combinations](#sec-64)
- [Command-line arguments](#sec-65)
- [Rot-13](#sec-66)
- [Balanced brackets](#sec-67)
- [Roman numerals/Decode](#sec-68)
- [Ethiopian multiplication](#sec-69)
- [Search a list](#sec-70)
- [Flatten a list](#sec-71)
- [Compound data type](#sec-72)
- [String case](#sec-73)
- [Towers of Hanoi](#sec-74)
- [Higher-order functions](#sec-75)
- [Loops/Do-while](#sec-76)
- [Integer comparison](#sec-77)
- [Sum of a series](#sec-78)
- [Bitwise operations](#sec-79)
- [Knuth shuffle](#sec-80)
- [Dot product](#sec-81)
- [Return multiple values](#sec-82)
- [Find limit of recursion](#sec-83)
- [Accumulator factory](#sec-84)
- [Sum multiples of 3 and 5](#sec-85)
- [Mandelbrot set](#sec-86)
- [Luhn test of credit card numbers](#sec-87)
- [Copy a string](#sec-88)
- [Function composition](#sec-89)
- [Primality by trial division](#sec-90)
- [Include a file](#sec-91)
- [Loops/N plus one half](#sec-92)
- [Determine if a string is numeric](#sec-93)
- [Range extraction](#sec-94)
- [Leap year](#sec-95)
- [Classes](#sec-96)
- [Associative array/Iteration](#sec-97)
- [Identity matrix](#sec-98)
- [Loops/Downward for](#sec-99)
- [Perfect numbers](#sec-100)
- [Y combinator](#sec-101)
- [Matrix multiplication](#sec-102)
- [Null object](#sec-103)
- [Sort an integer array](#sec-104)
- [Execute a system command](#sec-105)
- [Read entire file](#sec-106)
- [Program termination](#sec-107)
- [Matrix transposition](#sec-108)
- [Sum of squares](#sec-109)
- [Literals/Integer](#sec-110)
- [Logical operations](#sec-111)
- [Catalan numbers](#sec-112)
- [Integer sequence](#sec-113)
- [Levenshtein distance](#sec-114)
- [Cumulative standard deviation](#sec-115)
- [Evaluate binomial coefficients](#sec-116)
- [Multiplication tables](#sec-117)
- [Mutual recursion](#sec-118)
- [Babbage problem](#sec-119)
- [Loops/Break](#sec-120)
- [Count occurrences of a substring](#sec-121)
- [Averages/Root mean square](#sec-122)
- [Short-circuit evaluation](#sec-123)
- [Look-and-say sequence](#sec-124)
- [JSON](#sec-125)
- [String concatenation](#sec-126)
- [Arithmetic-geometric mean](#sec-127)
- [Array length](#sec-128)
- [Averages/Median](#sec-129)
- [Loops/Nested](#sec-130)
- [Generate lower case ASCII alphabet](#sec-131)
- [Abstract type](#sec-132)
- [Arbitrary-precision integers (included)](#sec-133)
- [Closures/Value capture](#sec-134)
- [Comma quibbling](#sec-135)
- [Strip a set of characters from a string](#sec-136)
- [Least common multiple](#sec-137)
- [Longest common subsequence](#sec-138)
- [Detect division by zero](#sec-139)
- [Exponentiation operator](#sec-140)
- [Arithmetic/Complex](#sec-141)
- [Count the coins](#sec-142)
- [Haversine formula](#sec-143)
- [First-class functions](#sec-144)
- [Queue/Definition](#sec-145)
- [Create an HTML table](#sec-146)
- [Program name](#sec-147)
- [Sorting algorithms/Insertion sort](#sec-148)
- [Middle three digits](#sec-149)
- [Real constants and functions](#sec-150)
- [Loops/Continue](#sec-151)
- [Read a file line by line](#sec-152)
- [Assertions](#sec-153)
- [Averages/Simple moving average](#sec-154)
- [Knapsack problem/0-1](#sec-155)
- [Date format](#sec-156)
- [Hello world/Newline omission](#sec-157)
- [Monty Hall problem](#sec-158)
- [Case-sensitivity of identifiers](#sec-159)
- [Infinity](#sec-160)
- [Formatted numeric output](#sec-161)
- [Averages/Pythagorean means](#sec-162)
- [Range expansion](#sec-163)
- [Create a two-dimensional array at runtime](#sec-164)
- [Hello world/Standard error](#sec-165)
- [HTTP](#sec-166)
- [Zero to the zero power](#sec-167)
- [Greatest subsequential sum](#sec-168)
- [Pythagorean triples](#sec-169)
- [User input/Text](#sec-170)
- [Ordered words](#sec-171)
- [Sleep](#sec-172)
- [Align columns](#sec-173)
- [String matching](#sec-174)
- [Enumerations](#sec-175)
- [Sum digits of an integer](#sec-176)
- [Tree traversal](#sec-177)
- [Priority queue](#sec-178)
- [Pangram checker](#sec-179)
- [Create a file](#sec-180)
- [Amicable pairs](#sec-181)
- [Empty string](#sec-182)
- [Random numbers](#sec-183)
- [Evolutionary algorithm](#sec-184)
- [Gray code](#sec-185)
- [Harshad or Niven series](#sec-186)
- [Vector products](#sec-187)
- [Address of a variable](#sec-188)
- [Horner's rule for polynomial evaluation](#sec-189)
- [Man or boy test](#sec-190)
- [Strip whitespace from a string/Top and tail](#sec-191)
- [Check that file exists](#sec-192)
- [Hofstadter Q sequence](#sec-193)
- [Letter frequency](#sec-194)
- [Input loop](#sec-195)
- [Map range](#sec-196)
- [24 game](#sec-197)
- [Entropy](#sec-198)
- [Call a foreign-language function](#sec-199)
- [Reverse words in a string](#sec-200)
- [Hash from two arrays](#sec-201)
- [Fibonacci n-step number sequences](#sec-202)
- [Sorting algorithms/Merge sort](#sec-203)
- [Proper divisors](#sec-204)
- [Sort using a custom comparator](#sec-205)
- [N'th](#sec-206)
- [AKS test for primes](#sec-207)
- [Set](#sec-208)
- [Abundant, deficient and perfect number classifications](#sec-209)
- [Averages/Mode](#sec-210)
- [Digital root](#sec-211)
- [Count in octal](#sec-212)
- [Guess the number](#sec-213)
- [Best shuffle](#sec-214)
- [Here document](#sec-215)
- [Arithmetic/Rational](#sec-216)
- [Langton's ant](#sec-217)
- [Magic squares of odd order](#sec-218)
- [Amb](#sec-219)
- [String interpolation (included)](#sec-220)
- [Euler's sum of powers conjecture](#sec-221)
- [Monte Carlo methods](#sec-222)
- [Extend your language](#sec-223)
- [Shell one-liner](#sec-224)
- [String comparison](#sec-225)
- [Walk a directory/Recursively](#sec-226)
- [MD5](#sec-227)
- [Modulinos](#sec-228)
- [Read a configuration file](#sec-229)
- [Binary strings](#sec-230)
- [Iterated digits squaring](#sec-231)
- [Lucas-Lehmer test](#sec-232)
- [Show the epoch](#sec-233)
- [Almost prime](#sec-234)
- [File size](#sec-235)
- [Catamorphism](#sec-236)
- [Price fraction](#sec-237)
- [Guess the number/With feedback](#sec-238)
- [Sorting algorithms/Selection sort](#sec-239)
- [Playing cards](#sec-240)
- [Delete a file](#sec-241)
- [Quaternion type](#sec-242)
- [Random number generator (included)](#sec-243)
- [String append](#sec-244)
- [24 game/Solve](#sec-245)
- [Averages/Mean angle](#sec-246)
- [Linear congruential generator](#sec-247)
- [String prepend](#sec-248)
- [Numerical integration](#sec-249)
- [Cholesky decomposition](#sec-250)
- [Integer overflow](#sec-251)
- [Sequence of non-squares](#sec-252)
- [Singly-linked list/Element definition](#sec-253)
- [Emirp primes](#sec-254)
- [Vigen√®re cipher](#sec-255)
- [Fast Fourier transform](#sec-256)
- [Compare a list of strings](#sec-257)
- [CRC-32](#sec-258)
- [Currying](#sec-259)
- [Pick random element](#sec-260)
- [Extreme floating point values](#sec-261)
- [Self-describing numbers](#sec-262)
- [Convert seconds to compound duration](#sec-263)
- [Huffman coding](#sec-264)
- [Knight's tour](#sec-265)
- [Sorting algorithms/Heapsort](#sec-266)
- [Concurrent computing](#sec-267)
- [Walk a directory/Non-recursively](#sec-268)
- [Longest increasing subsequence](#sec-269)
- [9 billion names of God the integer](#sec-270)
- [Modular inverse](#sec-271)
- [Enforced immutability](#sec-272)
- [Rename a file](#sec-273)
- [Extensible prime generator](#sec-274)
- [The Twelve Days of Christmas](#sec-275)
- [Continued fraction](#sec-276)
- [Runge-Kutta method](#sec-277)
- [Unicode variable names](#sec-278)
- [Probabilistic choice](#sec-279)
- [Brownian tree](#sec-280)
- [Literals/Floating point](#sec-281)
- [Catalan numbers/Pascal's triangle](#sec-282)
- [Sorting algorithms/Bogosort](#sec-283)
- [Bulls and cows](#sec-284)
- [Sorting algorithms/Counting sort](#sec-285)
- [Bernoulli numbers](#sec-286)
- [Compile-time calculation](#sec-287)
- [Benford's law](#sec-288)
- [Hash join](#sec-289)
- [Ulam spiral (for primes)](#sec-290)
- [Semiprime](#sec-291)
- [IBAN](#sec-292)
- [Singly-linked list/Traversal](#sec-293)
- [Chinese remainder theorem](#sec-294)
- [Call an object method](#sec-295)
- [Metaprogramming](#sec-296)
- [Forest fire](#sec-297)
- [Constrained random points on a circle](#sec-298)
- [Department Numbers](#sec-299)
- [Read a specific line from a file](#sec-300)
- [Dutch national flag problem](#sec-301)
- [Two Sum](#sec-302)
- [Execute Brain\*\*\*\*](#sec-303)
- [Statistics/Basic](#sec-304)
- [Remove lines from a file](#sec-305)
- [Left factorials](#sec-306)
- [Rock-paper-scissors](#sec-307)
- [Circles of given radius through two points](#sec-308)
- [Call a function in a shared library](#sec-309)
- [First-class functions/Use numbers analogously](#sec-310)
- [Split a character string based on change of character](#sec-311)
- [Guess the number/With feedback (player)](#sec-312)
- [Menu](#sec-313)
- [Munchausen numbers](#sec-314)
- [Sort stability](#sec-315)
- [Sorting algorithms/Pancake sort](#sec-316)
- [One of n lines in a file](#sec-317)
- [SHA-256](#sec-318)
- [Fractal tree](#sec-319)
- [Singly-linked list/Element insertion](#sec-320)
- [Maximum triangle path sum](#sec-321)
- [General FizzBuzz](#sec-322)
- [Sorting algorithms/Sleep sort](#sec-323)
- [Keyboard input/Obtain a Y or N response](#sec-324)
- [Sorting algorithms/Stooge sort](#sec-325)
- [Fibonacci word](#sec-326)
- [Hello world/Web server](#sec-327)
- [Deepcopy](#sec-328)
- [Population count](#sec-329)
- [Generate Chess960 starting position](#sec-330)
- [Substring](#sec-331)
- [Synchronous concurrency](#sec-332)
- [Primorial numbers](#sec-333)
- [4-rings or 4-squares puzzle](#sec-334)
- [Unbias a random generator](#sec-335)
- [Dijkstra's algorithm](#sec-336)
- [Dining philosophers](#sec-337)
- [Convert decimal number to rational](#sec-338)
- [Empty directory](#sec-339)
- [Aliquot sequence classifications](#sec-340)
- [Animation](#sec-341)
- [Deal cards for FreeCell](#sec-342)
- [Parsing/Shunting-yard algorithm](#sec-343)
- [Random number generator (device)](#sec-344)
- [Extract file extension](#sec-345)
- [Draw a clock](#sec-346)
- [Lychrel numbers](#sec-347)
- [Repeat](#sec-348)
- [Knuth's algorithm S](#sec-349)
- [Constrained genericity](#sec-350)
- [DNS query](#sec-351)
- [Smith numbers](#sec-352)
- [Sparkline in unicode](#sec-353)
- [Execute HQ9+](#sec-354)
- [FASTA format](#sec-355)
- [15 Puzzle Game](#sec-356)
- [Take notes on the command line](#sec-357)
- [Element-wise operations](#sec-358)
- [Exponentiation order](#sec-359)
- [Perfect shuffle](#sec-360)
- [Visualize a tree](#sec-361)
- [Discordian date](#sec-362)
- [Continued fraction/Arithmetic/Construct from rational number](#sec-363)
- [Ray-casting algorithm](#sec-364)
- [Sockets](#sec-365)
- [JortSort](#sec-366)
- [Atomic updates](#sec-367)
- [Get system command output](#sec-368)
- [Rosetta Code/Count examples](#sec-369)
- [Parametric polymorphism](#sec-370)
- [Munching squares](#sec-371)
- [File extension is in extensions list](#sec-372)
- [Unix/ls](#sec-373)
- [Elementary cellular automaton](#sec-374)
- [Old lady swallowed a fly](#sec-375)
- [Mouse position](#sec-376)
- [Average loop length](#sec-377)
- [CUSIP](#sec-378)
- [Determine if only one instance is running](#sec-379)
- [Carmichael 3 strong pseudoprimes](#sec-380)
- [Vector](#sec-381)
- [Jaro distance](#sec-382)
- [Bitmap/Write a PPM file](#sec-383)
- [2048](#sec-384)
- [Doubly-linked list/Element definition](#sec-385)
- [Egyptian division](#sec-386)
- [Conjugate transpose](#sec-387)
- [Voronoi diagram](#sec-388)
- [Barnsley fern](#sec-389)
- [Doubly-linked list/Element insertion](#sec-390)
- [Echo server](#sec-391)
- [Word count](#sec-392)
- [Sutherland-Hodgman polygon clipping](#sec-393)
- [MD4](#sec-394)
- [Archimedean spiral](#sec-395)
- [Julia set](#sec-396)
- [Bitcoin/address validation](#sec-397)
- [Make directory path](#sec-398)
- [Pattern matching](#sec-399)
- [Arena storage pool](#sec-400)
- [Chaos game](#sec-401)
- [K-means++ clustering](#sec-402)
- [Cut a rectangle](#sec-403)
- [Check output device is a terminal](#sec-404)
- [Minesweeper game](#sec-405)
- [Euler's identity](#sec-406)
- [Find the intersection of a line with a plane](#sec-407)
- [Create an object at a given address](#sec-408)
- [Nonoblock](#sec-409)
- [Simulate input/Keyboard](#sec-410)
- [Elementary cellular automaton/Random Number Generator](#sec-411)
- [Parallel Brute Force](#sec-412)
- [Levenshtein distance/Alignment](#sec-413)
- [Apply a digital filter (direct form II transposed)](#sec-414)
- [Check input device is a terminal](#sec-415)
- [Mind boggling card trick](#sec-416)
- [Word break problem](#sec-417)
- [Simulate input/Mouse](#sec-418)
- [Draw a pixel](#sec-419)
- [Banker's algorithm](#sec-420)
- [Hello world/Line printer](#sec-421)


# Fibonacci sequence<a id="sec-1"></a>

The Fibonacci sequence is a sequence ¬† Fn ¬† of natural numbers defined recursively:

```
F0 = 0
F1 = 1
Fn = Fn-1 + Fn-2, if n>1

```

Task

Write a function to generate the ¬† nth ¬† Fibonacci number.

Solutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).

The sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:

```
Fn = Fn+2 - Fn+1, if n<0

```

support for negative ¬† ¬† n ¬† ¬† in the solution is optional.

Related tasks

¬† Fibonacci n-step number sequences‚Äé ¬† Leonardo numbers

References

¬† Wikipedia, Fibonacci number ¬† Wikipedia, Lucas number ¬† MathWorld, Fibonacci Number ¬† Some identities for r-Fibonacci numbers ¬† OEIS Fibonacci numbers ¬† OEIS Lucas numbers

Iterative[edit]

```rust
use std::mem;
fn main() {
    let mut prev = 0;
    // Rust needs this type hint for the checked_add method
    let mut curr = 1usize;
¬†
    while let Some(n) = curr.checked_add(prev) {
        prev = curr;
        curr = n;
        println!("{}", n);
    }
}
```

Recursive[edit]

```rust
use std::mem;
fn main() {
    fibonacci(0,1);
}
¬†
fn fibonacci(mut prev: usize, mut curr: usize) {
    mem::swap(&mut prev, &mut curr);
    if let Some(n) = curr.checked_add(prev) {
        println!("{}", n);
        fibonacci(prev, n);
    }
}
```

Analytic[edit]

This uses a feature from nightly Rust which makes it possible to (cleanly) return an iterator without the additional overhead of putting it on the heap. In stable Rust, we'd need to return a Box<Iterator<Item=u64>> which has the cost of an additional allocation and the overhead of dynamic dispatch. The version below does not require the use of the heap and is done entirely through static dispatch.

```rust
#![feature(conservative_impl_trait)]
¬†
fn main() {
    for num in fibonacci_gen(10) {
        println!("{}", num);
    }
}
¬†
fn fibonacci_gen(terms: i32) -> impl Iterator<Item=u64> {
    let sqrt_5 = 5.0f64.sqrt();
    let p  = (1.0 + sqrt_5) / 2.0;
    let q = 1.0/p;
    (1..terms).map(move |n| ((p.powi(n) + q.powi(n)) / sqrt_5 + 0.5) as u64)
}
```

Using an Iterator[edit]

Iterators are very idiomatic in rust, though they may be overkill for such a simple problem.

```rust
use std::mem;
¬†
struct Fib {
    prev: usize,
    curr: usize,
}
¬†
impl Fib {
    fn new() -> Self {
        Fib {prev: 0, curr: 1}
    }
}
¬†
impl Iterator for Fib {
    type Item = usize;
    fn next(&mut self) -> Option<Self::Item>{
        mem::swap(&mut self.curr, &mut self.prev);
        self.curr.checked_add(self.prev).map(|n| {
            self.curr = n;
            n
        })
    }
}
¬†
fn main() {
    for num in Fib::new() {
        println!("{}", num);
    }
}
```

# Conditional structures<a id="sec-2"></a>

Task

List the ¬† conditional structures ¬† offered by a programming language.

Common conditional structures are ¬† ¬† if-then-else ¬† ¬† and ¬† ¬† switch.

Compile-Time[edit]

Conditional compilation[edit]

Rust supports conditional compilation via the \`cfg\` annotation.

```rust
// This function will only be compiled if we are compiling on Linux
#[cfg(target_os = "linux")]
fn running_linux() {
    println!("This is linux");
}
#[cfg(not(target_os = "linux"))]
fn running_linux() {
    println!("This is not linux");
}
¬†
// If we are on linux, we must be using glibc
#[cfg_attr(target_os = "linux", target_env = "gnu")]
// We must either be compiling for ARM or on a little endian machine that doesn't have 32-bit pointers pointers, on a
// UNIX like OS and only if we are doing a test build
#[cfg(all(
        any(target_arch = "arm", target_endian = "little"),
        not(target_pointer_width = "32"),
        unix,
        test
        ))]
fn highly_specific_function() {}
¬†
```

Conditional compilation may also be achieved via the \`cfg!\` macro.

```rust
fn main() {
     if cfg!(target_os = "linux") {
         // Do something
     }
}
```

Generics (static dispatch)[edit]

By default, generics in Rust are monomorphized, so no vtable lookups at runtime are necessary.

```rust
trait PrintType {
    fn print_type(&self);
}
¬†
impl PrintType for char {
    fn print_type(&self) {
        println!("char");
    }
}
¬†
impl PrintType for f64 {
    fn print_type(&self) {
        println!("64-bit float");
    }
}
¬†
fn prints_type_of_args<T, U>(arg1: &T, arg2: &U)
    where T: PrintType,
          U: PrintType
{
    arg1.print_type();
    arg2.print_type();
}
¬†
fn main() {
    prints_type_of_args(&'a', &2.0);
    prints_type_of_args(&'a', &'b');
}
```

Runtime[edit]

If-statement[edit]

```rust
if some_conditional {
    do_stuff();
} else if some_other_conditional {
    do_other_stuff();
} else {
    destroy_humanity();
}
¬†
// If statements are also expressions and will yield the value of the last expression in each block
let x = if y > z { y + 1 } else { z * 4 };
¬†
// Pattern matching may also be used
struct Point {
    x: i32,
    y: i32,
}
fn some_function(p: Option<Point>) {
    if let Some(Point { x: x_coord, y: y_coord }) = p {
        // Do something with x_coord and y_coord
    }
}
```

Match statement[edit]

Match statements are essentially more powerful switch statements

```rust
fn some_other_function(p: Option<Point>) {
    match p {
        Some(Point { x: 0, y: 0 }) => println!("Point is on origin"),
        Some(Point { x: 0, y: _ }) | Some(Point { x: _, y: 0 }) => println!("Point is on an axis"),
        Some(Point {x: a, y: b}) if a == b => println!("x and y are the same value"),
        Some(Point {x: ref mut a, y: ref b}) if *a > 4 && *b < 2 => println!("we got a mutable reference to x-value and an immutable reference to y-value."),
        op @ Some(p) => println!("op is the Option<Point> while p is the contained Point"),
        None => println!("We didn't get a point"),
    }
}
```

Generics (dynamic dispatch)[edit]

Generics may also be accomplished via dynamic dispatch, so the actual code that is run is determined at compile time. Using the same trait defined in the static dispatch section:

```rust
fn prints_args_dynamic(arg1: &PrintType, arg2: &PrintType) {
    arg1.print_type();
    arg2.print_type();
}
fn main() {
   prints_args_dynamic(&'a', &2.0);
   prints_args_dynamic(&6.3,&'c');
}
```

# Factorial<a id="sec-3"></a>

Definitions ¬† The factorial of ¬† 0 ¬† (zero) ¬† is defined as being ¬† 1 ¬† (unity). ¬† The ¬† Factorial Function ¬† of a positive integer, ¬† n, ¬† is defined as the product of the sequence:

```
n, ¬† n-1, ¬† n-2, ¬† ... ¬† 1

```

Task

Write a function to return the factorial of a number.

Solutions can be iterative or recursive.

Support for trapping negative ¬† n ¬† errors is optional.

Related task

¬† Primorial numbers

```rust
fn factorial_recursive (n: u64) -> u64 {
    match n {
        0 => 1,
        _ => n * factorial_recursive(n-1)
    }
}
¬†
fn factorial_iterative(n: u64) -> u64 {
    (1..n+1).fold(1, |p, n| p*n)
}
¬†
fn main () {
    for i in 1..10 {
        println!("{}", factorial_recursive(i))
    }
    for i in 1..10 {
        println!("{}", factorial_iterative(i))
    }
}
¬†
```

# 100 doors<a id="sec-4"></a>

There are 100 doors in a row that are all initially closed.

You make 100 passes by the doors.

The first time through, visit every door and ¬†toggle¬† the door ¬†(if the door is closed, ¬†open it; ¬† if it is open,¬† close it).

The second time, only visit every 2nd door ¬† (door #2, #4, #6, &#x2026;), ¬† and toggle it.

The third time, visit every 3rd door ¬† (door #3, #6, #9, &#x2026;), etc, ¬† until you only visit the 100th door.

Task

Answer the question: ¬† what state are the doors in after the last pass? ¬† Which are open, which are closed?

Alternate: As noted in this page's ¬† discussion page, ¬† the only doors that remain open are those whose numbers are perfect squares.

Opening only those doors is an ¬† optimization ¬† that may also be expressed; however, as should be obvious, this defeats the intent of comparing implementations across programming languages.

```rust
fn main() {
    let mut door_open = [false; 100];
    for pass in 1..100 {
        let mut door = pass;
        while door <= 100 {
            door_open[door - 1] =¬†!door_open[door - 1];
            door += pass;
        }
    }
    for (i, &is_open) in door_open.iter().enumerate() {
        println!("Door {} is {}.", i + 1, if is_open {"open"} else {"closed"});
    }
}
}
```

Declarative version of above:

```rust
fn main() {
    let doors = vec![false; 100].iter_mut().enumerate()
                                .map(|(door, door_state)| (1..100).into_iter()
                                                                   .filter(|pass| door¬†% pass == 0)
                                                                   .map(|_| { *door_state =¬†!*door_state; *door_state })
                                                                   .last().unwrap()).collect::<Vec<_>>();
¬†
    println!("{:?}", doors);
}
¬†
```

Optimized version: (In this case the printing is the bottleneck so this version is not faster than the above one.)

```rust
fn main() {
    let squares: Vec<_> = (1..10).map(|n| n*n).collect();
    let is_square = |num| squares.binary_search(&num).is_ok();
¬†
    for i in 1..100 {
        let state = if is_square(i) {"open"} else {"closed"};
        println!("Door {} is {}", i, state);
    }
}
```

ultra-optimized: ported from Julia version

```rust
fn main() {
    for i in 1u32..10u32{
        println!("Door {} is open", i.pow(2));
    }
}
```

# Sieve of Eratosthenes<a id="sec-5"></a>

The Sieve of Eratosthenes is a simple algorithm that finds the prime numbers up to a given integer.

Task

Implement the ¬† Sieve of Eratosthenes ¬† algorithm, with the only allowed optimization that the outer loop can stop at the square root of the limit, and the inner loop may start at the square of the prime just found.

That means especially that you shouldn't optimize by using pre-computed wheels, i.e. don't assume you need only to cross out odd numbers (wheel based on 2), numbers equal to 1 or 5 modulo 6 (wheel based on 2 and 3), or similar wheels based on low primes.

If there's an easy way to add such a wheel based optimization, implement it as an alternative version.

Note

It is important that the sieve algorithm be the actual algorithm used to find prime numbers for the task.

Related tasks

¬† Emirp primes ¬† count in factors ¬† prime decomposition ¬† factors of an integer ¬† extensible prime generator ¬† primality by trial division ¬† factors of a Mersenne number ¬† trial factoring of a Mersenne number ¬† partition an integer X into N primes ¬† sequence of primes by Trial Division

Sieve of Eratosthenes - No optimization[edit]

```rust
fn simple_sieve(limit: usize) -> Vec<usize> {
¬†
    let mut is_prime = vec![true; limit+1];
    is_prime[0] = false;
    if limit >= 1 { is_prime[1] = false }
¬†
    for num in 2..limit+1 {
        if is_prime[num] {
            let mut multiple = num*num;
            while multiple <= limit {
                is_prime[multiple] = false;
                multiple += num;
            }
        }
    }
¬†
    is_prime.iter().enumerate()
        .filter_map(|(pr, &is_pr)| if is_pr {Some(pr)} else {None} )
        .collect()
}
¬†
fn main() {
    println!("{:?}", simple_sieve(100));
}
```

Output:

```rust
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
```

Basic Version slightly optimized, Iterator output[edit]

The above code doesn't even do the basic optimizing of only culling composites by primes up to the square root of the range as allowed in the task; it also outputs a vector of resulting primes, which consumes memory. The following code fixes both of those, outputting the results as an Iterator:

```rust
use std::iter::{empty, once};
use std::time::Instant;
¬†
fn basic_sieve(limit: usize) -> Box<Iterator<Item = usize>> {
    if limit < 2 { return Box::new(empty()) }
¬†
    let mut is_prime = vec![true; limit+1];
    is_prime[0] = false;
    if limit >= 1 { is_prime[1] = false }
    let sqrtlmt = (limit as f64).sqrt() as usize + 1; 
¬†
    for num in 2..sqrtlmt {
        if is_prime[num] {
            let mut multiple = num * num;
            while multiple <= limit {
                is_prime[multiple] = false;
                multiple += num;
            }
        }
    }
¬†
    Box::new(is_prime.into_iter().enumerate()
                .filter_map(|(p, is_prm)| if is_prm { Some(p) } else { None }))
¬†
}
¬†
fn main() {
    let n = 1000000;
    let vrslt = basic_sieve(100).collect::<Vec<_>>();
    println!("{:?}", vrslt);
    let strt = Instant::now();
¬†
    // do it 1000 times to get a reasonable execution time span...
    let rslt = (1..1000).map(|_| basic_sieve(n)).last().unwrap();
¬†
    let elpsd = strt.elapsed();
¬†
    let count = rslt.count();
    println!("{}", count);
¬†
    let secs = elpsd.as_secs();
    let millis = (elpsd.subsec_nanos() / 1000000) as u64;
    let dur = secs * 1000 + millis;
    println!("Culling composites took {} milliseconds.", dur);
}
```

Output:

```rust
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
78498
Culling composites took 4595 milliseconds.
```

The sieving operation is run for 1000 loops in order to get a reasonable execution time for comparison.

Odds-only bit-packed array, Iterator output[edit]

The following code improves the above code by sieving only odd composite numbers as 2 is the only even prime for a reduction in number of operations by a factor of about two and a half with reduction of memory use by a factor of two, and bit-packs the composite sieving array for a further reduction of memory use by a factor of eight and with some saving in time due to better CPU cache use for a given sieving range; it also demonstrates how to eliminate the redundant array bounds check:

```rust
fn optimized_sieve(limit: usize) -> Box<Iterator<Item = usize>> {
    if limit < 3 {
        return if limit < 2 { Box::new(empty()) } else { Box::new(once(2)) }
    }
¬†
    let ndxlmt = (limit - 3) / 2 + 1;
    let bfsz = ((limit - 3) / 2) / 32 + 1;
    let mut cmpsts = vec![0u32; bfsz];
    let sqrtndxlmt = ((limit as f64).sqrt() as usize - 3) / 2 + 1;
¬†
    for ndx in 0..sqrtndxlmt {
        if (cmpsts[ndx >> 5] & (1u32 << (ndx & 31))) == 0 {
            let p = ndx + ndx + 3;
            let mut cullpos = (p * p - 3) / 2;
            while cullpos < ndxlmt {
                unsafe { // avoids array bounds check, which is already done above
              let cptr = cmpsts.get_unchecked_mut(cullpos >> 5);
              *cptr |= 1u32 << (cullpos & 31);
                }
//                cmpsts[cullpos >> 5] |= 1u32 << (cullpos & 31); // with bounds check
                cullpos += p;
            }
        }
    }
¬†
    Box::new((-1 .. ndxlmt as isize).into_iter().filter_map(move |i| {
                if i < 0 { Some(2) } else {
                    if cmpsts[i as usize >> 5] & (1u32 << (i & 31)) == 0 {
                        Some((i + i + 3) as usize) } else { None } }
    }))
}
```

The above function can be used just by substituting "optimized<sub>sieve</sub>" for "basic<sub>sieve</sub>" in the previous "main" function, and the outputs are the same except that the time is only 1584 milliseconds, or about three times as fast.

Unbounded Page-Segmented bit-packed odds-only version with Iterator[edit]

Caution! This implementation is used in the Extensible prime generator task, so be sure not to break that implementation when changing this code.

While that above code is quite fast, as the range increases above the 10's of millions it begins to lose efficiency due to loss of CPU cache associativity as the size of the one-large-array used for culling composites grows beyond the limits of the various CPU caches. Accordingly the following page-segmented code where each culling page can be limited to not larger than the L1 CPU cache is about four times faster than the above for the range of one billion:

```rust
use std::iter::{empty, once};
use std::rc::Rc;
use std::cell::RefCell;
use std::time::Instant;
¬†
const RANGE: u64 = 1000000000;
const SZ_PAGE_BTS: u64 = (1 << 14) * 8; // this should be the size of the CPU L1 cache
const SZ_BASE_BTS: u64 = (1 << 7) * 8;
static CLUT: [u8; 256] = [
  8, 7, 7, 6, 7, 6, 6, 5, 7, 6, 6, 5, 6, 5, 5, 4, 7, 6, 6, 5, 6, 5, 5, 4, 6, 5, 5, 4, 5, 4, 4, 3, 
  7, 6, 6, 5, 6, 5, 5, 4, 6, 5, 5, 4, 5, 4, 4, 3, 6, 5, 5, 4, 5, 4, 4, 3, 5, 4, 4, 3, 4, 3, 3, 2, 
  7, 6, 6, 5, 6, 5, 5, 4, 6, 5, 5, 4, 5, 4, 4, 3, 6, 5, 5, 4, 5, 4, 4, 3, 5, 4, 4, 3, 4, 3, 3, 2, 
  6, 5, 5, 4, 5, 4, 4, 3, 5, 4, 4, 3, 4, 3, 3, 2, 5, 4, 4, 3, 4, 3, 3, 2, 4, 3, 3, 2, 3, 2, 2, 1, 
  7, 6, 6, 5, 6, 5, 5, 4, 6, 5, 5, 4, 5, 4, 4, 3, 6, 5, 5, 4, 5, 4, 4, 3, 5, 4, 4, 3, 4, 3, 3, 2, 
  6, 5, 5, 4, 5, 4, 4, 3, 5, 4, 4, 3, 4, 3, 3, 2, 5, 4, 4, 3, 4, 3, 3, 2, 4, 3, 3, 2, 3, 2, 2, 1, 
  6, 5, 5, 4, 5, 4, 4, 3, 5, 4, 4, 3, 4, 3, 3, 2, 5, 4, 4, 3, 4, 3, 3, 2, 4, 3, 3, 2, 3, 2, 2, 1, 
  5, 4, 4, 3, 4, 3, 3, 2, 4, 3, 3, 2, 3, 2, 2, 1, 4, 3, 3, 2, 3, 2, 2, 1, 3, 2, 2, 1, 2, 1, 1, 0 ];
¬†
fn count_page(lmti: usize, pg: &[u32]) -> i64 {
  let pgsz = pg.len(); let pgbts = pgsz * 32;
  let (lmt, icnt) = if lmti >= pgbts { (pgsz, 0) } else {
    let lstw = lmti / 32;
    let msk = 0xFFFFFFFEu32 << (lmti & 31);
    let v = (msk | pg[lstw]) as usize;
    (lstw, (CLUT[v & 0xFF] + CLUT[(v >> 8) & 0xFF]
      + CLUT[(v >> 16) & 0xFF] + CLUT[v >> 24]) as u32)
  };
  let mut count = 0u32;
  for i in 0 .. lmt {
    let v = pg[i] as usize;
    count += (CLUT[v & 0xFF] + CLUT[(v >> 8) & 0xFF]
          + CLUT[(v >> 16) & 0xFF] + CLUT[v >> 24]) as u32;
  }
  (icnt + count) as i64
}
¬†
fn primes_pages() -> Box<Iterator<Item = (u64, Vec<u32>)>> {
  // a memoized iterable enclosing a Vec that grows as needed from an Iterator...
  type Bpasi = Box<Iterator<Item = (u64, Vec<u32>)>>; // (lwi, base cmpsts page)
  type Bpas = Rc<(RefCell<Bpasi>, RefCell<Vec<Vec<u32>>>)>; // interior mutables
  struct Bps(Bpas); // iterable wrapper for base primes array state
  struct Bpsi<'a>(usize, &'a Bpas); // iterator with current pos, state ref's
  impl<'a> Iterator for Bpsi<'a> {
    type Item = &'a Vec<u32>;
    fn next(&mut self) -> Option<Self::Item> {
      let n = self.0; let bpas = self.1;
      while n >= bpas.1.borrow().len() { // not thread safe
        let nbpg = match bpas.0.borrow_mut().next() {
                Some(v) => v, _ => (0, vec!()) };
        if nbpg.1.is_empty() { return None } // end if no source iter
        bpas.1.borrow_mut().push(cnvrt2bppg(nbpg));
      }
      self.0 += 1; // unsafe pointer extends interior -> exterior lifetime
      // multi-threading might drop following Vec while reading - protect
      let ptr = &bpas.1.borrow()[n] as *const Vec<u32>;
      unsafe { Some(&(*ptr)) }
    }
  }
  impl<'a> IntoIterator for &'a Bps {
    type Item = &'a Vec<u32>;
    type IntoIter = Bpsi<'a>;
    fn into_iter(self) -> Self::IntoIter {
      Bpsi(0, &self.0)
    }
  }
  fn make_page(lwi: u64, szbts: u64, bppgs: &Bpas)
      -> (u64, Vec<u32>) {
    let nxti = lwi + szbts;
    let pbts = szbts as usize;
    let mut cmpsts = vec!(0u32; pbts / 32);
    'outer: for bpg in Bps(bppgs.clone()).into_iter() { // in the inner tight loop...
      let pgsz = bpg.len();
      for i in 0 .. pgsz {
        let p = bpg[i] as u64; let pc = p as usize;
        let s = (p * p - 3) / 2;
        if s >= nxti { break 'outer; } else { // page start address:
          let mut cp = if s >= lwi { (s - lwi) as usize } else {
            let r = ((lwi - s)¬†% p) as usize;
            if r == 0 { 0 } else { pc - r }
          };
          while cp < pbts {
            unsafe { // avoids array bounds check, which is already done above
              let cptr = cmpsts.get_unchecked_mut(cp >> 5);
              *cptr |= 1u32 << (cp & 31); // about as fast as it gets...
            }
//						cmpsts[cp >> 5] |= 1u32 << (cp & 31);
            cp += pc;
          }
        }
      }
    }
    (lwi, cmpsts)
  }
  fn pages_from(lwi: u64, szbts: u64, bpas: Bpas)
      -> Box<Iterator<Item = (u64, Vec<u32>)>> {
    struct Gen(u64,  u64);
    impl Iterator for Gen {
      type Item = (u64, u64);
      #[inline]
      fn next(&mut self) -> Option<(u64, u64)> {
        let v = self.0; let inc = self.1; // calculate variable size here
        self.0 = v + inc;
        Some((v, inc))
      }
    }
    Box::new(Gen(lwi, szbts)
          .map(move |(lwi, szbts)| make_page(lwi, szbts, &bpas)))
  }
  fn cnvrt2bppg(cmpsts: (u64, Vec<u32>)) -> Vec<u32> {
    let (lwi, pg) = cmpsts;
    let pgbts = pg.len() * 32;
    let cnt = count_page(pgbts, &pg) as usize;
    let mut bpv = vec!(0u32; cnt);
    let mut j = 0; let bsp = (lwi + lwi + 3) as usize;
    for i in 0 .. pgbts {
      if (pg[i >> 5] & (1u32 << (i & 0x1F))) == 0u32 {
        bpv[j] = (bsp + i + i) as u32; j += 1;
      }
    }
    bpv
  }
  // recursive Rc/RefCell variable bpas - used only for init, then fixed ...
  // start with just enough base primes to init the first base primes page...
  let base_base_prms = vec!(3u32,5u32,7u32);
  let rcvv = RefCell::new(vec!(base_base_prms));
  let bpas: Bpas = Rc::new((RefCell::new(Box::new(empty())), rcvv));
  let initpg = make_page(0, 32, &bpas); // small base primes page for SZ_BASE_BTS = 2^7 * 8
  *bpas.1.borrow_mut() = vec!(cnvrt2bppg(initpg)); // use for first page
  let frstpg = make_page(0, SZ_BASE_BTS, &bpas); // init bpas for first base prime page
  *bpas.0.borrow_mut() = pages_from(SZ_BASE_BTS, SZ_BASE_BTS, bpas.clone()); // recurse bpas
  *bpas.1.borrow_mut() = vec!(cnvrt2bppg(frstpg)); // fixed for subsequent pages
  pages_from(0, SZ_PAGE_BTS, bpas) // and bpas also used here for main pages
}
¬†
fn primes_paged() -> Box<Iterator<Item = u64>> {
  fn list_paged_primes(cmpstpgs: Box<Iterator<Item = (u64, Vec<u32>)>>)
      -> Box<Iterator<Item = u64>> {
    Box::new(cmpstpgs.flat_map(move |(lwi, cmpsts)| {
      let pgbts = (cmpsts.len() * 32) as usize;
      (0..pgbts).filter_map(move |i| {
        if cmpsts[i >> 5] & (1u32 << (i & 31)) == 0 {
          Some((lwi + i as u64) * 2 + 3) } else { None } }) }))
  }
  Box::new(once(2u64).chain(list_paged_primes(primes_pages())))
}
¬†
fn count_primes_paged(top: u64) -> i64 {
  if top < 3 { if top < 2 { return 0i64 } else { return 1i64 } }
  let topi = (top - 3u64) / 2;
  primes_pages().take_while(|&(lwi, _)| lwi <= topi)
    .map(|(lwi, pg)| { count_page((topi - lwi) as usize, &pg) })
    .sum::<i64>() + 1
}
¬†
fn main() {
  let n = 262146;
  let vrslt = primes_paged()
      .take_while(|&p| p <= 100)
      .collect::<Vec<_>>();
  println!("{:?}", vrslt);
¬†
  let strt = Instant::now();
¬†
//	let count = primes_paged().take_while(|&p| p <= RANGE).count(); // slow way to count
  let count = count_primes_paged(RANGE); // fast way to count
¬†
  let elpsd = strt.elapsed();
¬†
  println!("{}", count);
¬†
  let secs = elpsd.as_secs();
  let millis = (elpsd.subsec_nanos() / 1000000) as u64;
  let dur = secs * 1000 + millis;
  println!("Culling composites took {} milliseconds.", dur);
}
```

The output is about the same as the previous codes except much faster; as well as cache size improvements mentioned above, it has a population count primes counting function that is able to determine the number of found primes about twice as fast as using the Iterator count() method (commented out and labelled as "the slow way" in the main function).

As listed above, the code maintains its efficiency up to about sixteen billion, and can easily be extended to be useful above that point by having the buffer size dynamically calculated to be proportional to the square root of the current range as commented in the code.

It would also be quite easy to extend the code to use multi-threading per page so that the time would be reduced proportionally to the number of true CPU cores used (not Hyper-Threaded ones) as in four true cores for many common high end desktop CPU's.

Before being extended to truly huge ranges such a 1e14, the code should have maximum wheel factorization added (2;3;5;7 wheels and the culling buffers further pre-culled by the primes (11;13;17; and maybe 19), which would speed it up by another factor of four or so for the range of one billion. It would also be possible to use extreme loop unrolling techniques such as used by "primesieve" written in C/C++ to increase the speed for this range by another factor of two or so.

The above code demonstrates some techniques to work within the limitations of Rust's ownership/borrowing/lifetime memory model as it: 1) uses a recursive secondary base primes Iterator made persistent by using a Vec that uses its own value as a source of its own page stream, 2) this is done by using a recursive variable that accessed as a Rc reference counted heap value with internal mutability by a pair of RefCell's, 3) note that the above secondary stream is not thread safe and needs to have the Rc changed to an Arc, the RefCell's changed to Mutex'es or (probably preferably RwLock's that enclose/lock all reading and writing operations in the secondary stream "Bpsi"'s next() method, and 4) the use of Iterators where their performance doesn't matter (at the page level) while using tight loops at more inner levels.

# Arrays<a id="sec-6"></a>

This task is about arrays.

For hashes or associative arrays, please see Creating an Associative Array.

For a definition and in-depth discussion of what an array is, see Array.

Task

Show basic array syntax in your language.

Basically, create an array, assign a value to it, and retrieve an element ¬† (if available, show both fixed-length arrays and dynamic arrays, pushing a value into it).

Please discuss at Village Pump: ¬† Arrays.

Please merge code in from these obsolete tasks:

¬† Creating an Array ¬† Assigning Values to an Array ¬† Retrieving an Element of an Array

Related tasks

¬† Collections ¬† Creating an Associative Array ¬† Two-dimensional array (runtime)

The Rust book has a tutorial on arrays.

By default, arrays are immutable unless defined otherwise.

```rust
let a = [1, 2, 3]; // immutable array
let mut m = [1, 2, 3]; // mutable array
let zeroes = [0; 200]; // creates an array of 200 zeroes
```

To get the length and iterate,

```rust
let a = [1, 2, 3];
a.len();
for e in a.iter() {
    e;
}
```

Accessing a particular element uses subscript notation, starting from 0.

```rust
let names = ["Graydon", "Brian", "Niko"];
names[1]; // second element
```

Dynamic arrays in Rust are called vectors.

```rust
let v = vec![1, 2, 3];
```

However, this defines an immutable vector. To add elements to a vector, we need to define v to be mutable.

```rust
let mut v = vec![1, 2, 3];
v.push(4);
v.len(); // 4
```

# Hello world/Text<a id="sec-7"></a>

Task

Display the string Hello world! on a text console.

Related tasks

¬† Hello world/Graphical ¬† Hello world/Line Printer ¬† Hello world/Newline omission ¬† Hello world/Standard error ¬† Hello world/Web server

```rust
¬†
fn main () {
   print!("Hello world!");
}
¬†
```

or

```rust
¬†
fn main () {
   println!("Hello world!");
}
¬†
```

# FizzBuzz<a id="sec-8"></a>

Task

Write a program that prints the integers from ¬† 1 ¬† to ¬† 100 ¬† (inclusive).

But:

¬† for multiples of three, ¬† print ¬† Fizz ¬† ¬† (instead of the number) ¬† for multiples of five, ¬† print ¬† Buzz ¬† ¬† (instead of the number) ¬† for multiples of both three and five, ¬† print ¬† FizzBuzz ¬† ¬† (instead of the number)

The ¬† FizzBuzz ¬† problem was presented as the lowest level of comprehension required to illustrate adequacy.

Also see

¬† (a blog) ¬† dont-overthink-fizzbuzz ¬† (a blog) ¬† fizzbuzz-the-programmers-stairway-to-heaven

A version using an iterator and immutable data:

```rust
use std::borrow::Cow; // Allows us to avoid unnecessary allocations
fn main() {
    (1..101).map(|n| match (n¬†% 3, n¬†% 5) {
        (0, 0) => "FizzBuzz".into(),
        (0, _) => "Fizz".into(),
        (_, 0) => "Buzz".into(),
        _ => Cow::from(n.to_string())
    }).for_each(|n| println!("{}", n));
}
¬†
```

Or a version unwrapping the iterator into a loop:

```rust
¬†
use std::borrow::Cow;
fn main() {
    for i in 1..101 {
        println!("{}", match (i¬†% 3, i¬†% 5) {
            (0, 0) => "FizzBuzz".into(),
            (0, _) => "Fizz".into(),
            (_, 0) => "Buzz".into(),
            _ => Cow::from(i.to_string()),
        });
    }
}
```

Or the ultimate optimized version with hardcoded output, no standard library or main function, and direct assembly syscalls to write to stdout.

```rust
 #![no_std]
#![feature(asm, lang_items, libc, no_std, start)]
¬†
extern crate libc;
¬†
const LEN: usize = 413;
static OUT: [u8; LEN] = *b"\
    1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n\
    16\n17\nFizz\n19\nBuzz\nFizz\n22\n23\nFizz\nBuzz\n26\nFizz\n28\n29\nFizzBuzz\n\
    31\n32\nFizz\n34\nBuzz\nFizz\n37\n38\nFizz\nBuzz\n41\nFizz\n43\n44\nFizzBuzz\n\
    46\n47\nFizz\n49\nBuzz\nFizz\n52\n53\nFizz\nBuzz\n56\nFizz\n58\n59\nFizzBuzz\n\
    61\n62\nFizz\n64\nBuzz\nFizz\n67\n68\nFizz\nBuzz\n71\nFizz\n73\n74\nFizzBuzz\n\
    76\n77\nFizz\n79\nBuzz\nFizz\n82\n83\nFizz\nBuzz\n86\nFizz\n88\n89\nFizzBuzz\n\
    91\n92\nFizz\n94\nBuzz\nFizz\n97\n98\nFizz\nBuzz\n";
¬†
#[start]
fn start(_argc: isize, _argv: *const *const u8) -> isize {
    unsafe {
        asm!(
            "
            mov $$1,¬†%rax
            mov $$1,¬†%rdi
            mov $0,¬†%rsi
            mov $1,¬†%rdx
            syscall
            "
           ¬†:
           ¬†: "r" (&OUT[0]) "r" (LEN)
           ¬†: "rax", "rdi", "rsi", "rdx"
           ¬†:
        );
    }
    0
}
¬†
#[lang = "eh_personality"] extern fn eh_personality() {}
#[lang = "panic_fmt"] extern fn panic_fmt() {}
```

# String length<a id="sec-9"></a>

Task

Find the character and byte length of a string.

This means encodings like UTF-8 need to be handled properly, as there is not necessarily a one-to-one relationship between bytes and characters.

By character, we mean an individual Unicode code point, not a user-visible grapheme containing combining characters.

For example, the character length of "m√∏√∏se" is 5 but the byte length is 7 in UTF-8 and 10 in UTF-16.

Non-BMP code points (those between 0x10000 and 0x10FFFF) must also be handled correctly: answers should produce actual character counts in code points, not in code unit counts.

Therefore a string like "ùîòùî´ùî¶ùî†ùî¨ùî°ùî¢" (consisting of the 7 Unicode characters U+1D518 U+1D52B U+1D526 U+1D520 U+1D52C U+1D521 U+1D522) is 7 characters long, not 14 UTF-16 code units; and it is 28 bytes long whether encoded in UTF-8 or in UTF-16.

Please mark your examples with `==Character Length==` or `==Byte Length==`.

If your language is capable of providing the string length in graphemes, mark those examples with `==Grapheme Length==`.

For example, the string "JÃ≤oÃ≤sÃ≤√©Ã≤" ("J\x{332}o\x{332}s\x{332}e\x{301}\x{332}") has 4 user-visible graphemes, 9 characters (code points), and 14 bytes when encoded in UTF-8.

Metrics: length

Sub-string search: Count occurrences of a substring

Multi-string operations: LCP, LCS, concatenation

Manipulation: reverse, lower- and uppercase

Byte Length[edit]

```rust
¬†
fn main() {
    let s = "ÊñáÂ≠óÂåñ„Åë";  // UTF-8
    println!("Byte Length: {}", s.len());
}
¬†
```

Character Length[edit]

```rust
¬†
fn main() {
    let s = "ÊñáÂ≠óÂåñ„Åë";  // UTF-8
    println!("Character length: {}", s.chars().count());
}
¬†
```

# Comments<a id="sec-10"></a>

Task

Show all ways to include text in a language source file that's completely ignored by the compiler or interpreter.

Related tasks

¬† Documentation ¬† Here<sub>document</sub>

See also

¬† Wikipedia ¬† xkcd (Humor: hand gesture denoting // for "commenting out" people.)

```rust
// A single line comment
¬†
/*
    This is a multi-line (aka block) comment
¬†
    /*
        containing nested multi-line comment
        (nesting supported since 0.9-pre https://github.com/mozilla/rust/issues/9468)
    */
*/
¬†
¬†
/// Outer single line Rustdoc comments apply to the next item.
¬†
/**
    Outer multi-line Rustdoc comments.
¬†
 *  Leading asterisk (*) in multi-line Rustdoc comments
 *  is not considered to be part of the comment text,
 *  blanks and tabs preceding the initial asterisk (*) are also stripped.
*/
¬†
fn example() {
¬†
    //! Inner single line Rustdoc comments apply to their enclosing item.
¬†
    /*!
        Inner multi-line Rustdoc comments.
        See also https://github.com/mozilla/rust/wiki/Doc-using-rustdoc
    */
}
¬†
#[doc = "Unsugared outer Rustdoc comments.
        (outer attributes are not terminated by a semi-colon)"]
fn example() {
    #[doc = "Unsugared inner Rustdoc comments.
            (inner attributes are terminated by a semi-colon)
            See also https://github.com/mozilla/rust/blob/master/doc/rust.md#attributes"];
}
```

# Function definition<a id="sec-11"></a>

A function is a body of code that returns a value.

The value returned may depend on arguments provided to the function.

Task

Write a definition of a function called "multiply" that takes two arguments and returns their product.

(Argument types should be chosen so as not to distract from showing how functions are created and values returned).

Related task

¬† Function prototype

```rust
fn multiply(a: i32, b: i32) -> i32 {
    a * b
}
```

# Ackermann function<a id="sec-12"></a>

The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.

The Ackermann function is usually defined as follows:

{\displaystyle A(m,n)={\begin{cases}n+1&{\mbox{if }}m=0\\\A(m-1,1)&{\mbox{if }}m>0{\mbox{ and }}n=0\\\A(m-1,A(m,n-1))&{\mbox{if }}m>0{\mbox{ and }}n>0.\end{cases}}}

Its arguments are never negative and it always terminates. Write a function which returns the value of {\displaystyle A(m,n)} . Arbitrary precision is preferred (since the function grows so quickly), but not required.

See also

Conway chained arrow notation for the Ackermann function.

```rust
fn ack(m: isize, n: isize) -> isize {
    if m == 0 {
        n + 1
    } else if n == 0 {
        ack(m - 1, 1)
    } else {
        ack(m - 1, ack(m, n - 1))
    }
}
¬†
fn main() {
    let a = ack(3, 4);
    println!("{}", a); // 125
}
¬†
```

Or:

```rust
¬†
fn ack(m: u64, n: u64) -> u64 {
  match (m, n) {
    (0, n) => n + 1,
    (m, 0) => ack(m - 1, 1),
    (m, n) => ack(m - 1, ack(m, n - 1)),
  }
}
¬†
```

# Hello world/Newbie<a id="sec-13"></a>

Task

Guide a new user of a language through the steps necessary to install the programming language and selection of a text editor if needed, to run the languages' example in the Hello world/Text task.

Assume the language-newbie is a programmer in another language. Assume the language-newbie is competent in installing software for the platform. Assume the language-newbie can use one simple text editor for the OS/platform, (but that may not necessarily be a particular one if the installation needs a particular editor). Refer to, (and link to), already existing documentation as much as possible (but provide a summary here). Remember to state where to view the output. If particular IDE's or editors are required that are not standard, then point to/explain their installation too.

Note:

If it is more natural for a language to give output via a GUI or to a file etc, then use that method of output rather than as text to a terminal/command-line, but remember to give instructions on how to view the output generated. You may use sub-headings if giving instructions for multiple platforms.

A complete description of how to install the language can be found on the Install page of the Rust web site. However, for the purposes of trying out code examples, use the online REPL which allows you to enter code, compile it and run it within a single browser window.

```rust
fn main() {
    println!("Hello world!");
}
```

# Collections<a id="sec-14"></a>

Collections are abstractions to represent sets of values.

In statically-typed languages, the values are typically of a common data type.

Task

Create a collection, and add a few values to it.

See also

Array Associative array: Creation, Iteration Collections Compound data type Doubly-linked list: Definition, Element definition, Element insertion, Traversal Linked list Queue: Definition, Usage Set Singly-linked list: Element definition, Element insertion, Traversal Stack

Rust has quite a few collections built in.

Stack-allocated collections[edit]

Array[edit]

Arrays ([T]) are stack allocated, fixed size collections of items of the same type.

```rust
let a = [1u8,2,3,4,5]; // a is of type [u8; 5];
let b = [0;256] // Equivalent to `let b = [0,0,0,0,0,0... repeat 256 times]`
```

Slice[edit]

Slices (&[T]) are dynamically sized views into contiguous sequences (arrays, vectors, strings)

```rust
let array = [1,2,3,4,5];
let slice = &array[0..2]
println!("{:?}", slice);
```

Output:

```rust
[1,2]
```

String slice[edit]

String slices are (str) are slices of Unicode characters. Plain strs are almost never seen in Rust. Instead either heap-allocated Strings or borrowed string slices (&str which is basically equivalent to a slice of bytes: &[u8]) are more often used. It should be noted that strings are not indexable as they are UTF-8 (meaning that characters are not necessarily of a fixed size) however iterators can be created over codepoints or graphemes.

Heap-allocated collections[edit]

Vector[edit]

Vectors (Vec<T>) are a growable list type. According to the Rust documentation, you want to use a Vector if:

You want to collect items up to be processed or sent elsewhere later, and don't care about any properties of the actual values being stored. You want a sequence of elements in a particular order, and will only be appending to (or near) the end. You want a stack. You want a resizable array. You want a heap-allocated array.

```rust
let mut v = Vec::new();
v.push(1);
v.push(2);
v.push(3);
// Or (mostly) equivalently via a convenient macro in the standard library
let v = vec![1,2,3];
```

String[edit]

Strings are growable strings stored as a UTF-8 buffer which are just Vec<u8>s under the hood. Like strs, they are not indexable (for the same reasons) but iterators can be created over the graphemes, codepoints or bytes therein.

```rust
let x = "abc"; // x is of type &str (a borrowed string slice)
let s = String::from(x);
// or alternatively
let s = x.to_owned();
```

VecDequeue[edit]

A growable ring buffer. According to the Rust documentation you should use VecDequeue<T> when:

You want a Vec that supports efficient insertion at both ends of the sequence. You want a queue. You want a double-ended queue (deque).

Linked List[edit]

A doubly-linked list. According to the Rust documentation, you should use it when:

You want a Vec or VecDeque of unknown size, and can't tolerate amortization. You want to efficiently split and append lists. You are absolutely certain you really, truly, want a doubly linked list.

HashMap[edit]

A hash map implementation which uses linear probing with Robin Hood bucket stealing. According to the Rust documentation, you should use it when:

You want to associate arbitrary keys with an arbitrary value. You want a cache. You want a map, with no extra functionality.

BTreeMap[edit]

A map based on a B-Tree. According to the Rust documentation, you should use it when:

You're interested in what the smallest or largest key-value pair is. You want to find the largest or smallest key that is smaller or larger than something. You want to be able to get all of the entries in order on-demand. You want a sorted map.

HashSet/BTreeSet[edit]

Set implementations that use an empty tuple () as the value of their respective maps (and implement different methods). They should be used when:

You just want to remember which keys you've seen. There is no meaningful value to associate with your keys. You just want a set.

BinaryHeap[edit]

A priority queue implemented with a binary heap. You should use it when

You want to store a bunch of elements, but only ever want to process the "biggest" or "most important" one at any given time. You want a priority queue.

# Reverse a string<a id="sec-15"></a>

Task

Take a string and reverse it.

For example, "asdf" becomes "fdsa".

Extra credit

Preserve Unicode combining characters.

For example, "as‚ÉùdfÃÖ" becomes "fÃÖds‚Éùa", not "ÃÖfd‚Éùsa".

Metrics: length

Sub-string search: Count occurrences of a substring

Multi-string operations: LCP, LCS, concatenation

Manipulation: reverse, lower- and uppercase

```rust
extern crate unicode_segmentation;
use unicode_segmentation::UnicodeSegmentation;
¬†
fn main() {
    let s = "‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ";
    let s2 = "as‚ÉùdfÃÖ";
    let reversed: String = s.chars().rev().collect();
    let reversed2: String = UnicodeSegmentation::graphemes(s2, true)
        .rev().collect();
    println!("{}", reversed);
    println!("{}", reversed2);
}
```

Output:

ÂçÅ‰πùÂÖ´‰∏ÉÂÖ≠‰∫îÂõõ‰∏â‰∫å‰∏Ä

fÃÖds‚Éùa

# Greatest common divisor<a id="sec-16"></a>

Task

Find the greatest common divisor of two integers.

num crate[edit]

```rust
extern crate num;
use num::integer::gcd;
```

Iterative Euclid algorithm[edit]

```rust
fn gcd(mut m: i32, mut n: i32) -> i32 {
   while m¬†!= 0 {
       let old_m = m;
       m = n¬†% m;
       n = old_m;
   }
   n.abs()
}
```

Recursive Euclid algorithm[edit]

```rust
fn gcd(m: i32, n: i32) -> i32 {
   if m == 0 {
      n.abs()
   } else {
      gcd(n¬†% m, m)
   }
}
```

Stein's Algorithm[edit]

Stein's algorithm is very much like Euclid's except that it uses bitwise operators (and consequently slightly more performant) and the integers must be unsigned. The following is a recursive implementation that leverages Rust's pattern matching.

```rust
use std::cmp::{min, max};
fn gcd(a: usize, b: usize) -> usize {
    match ((a, b), (a & 1, b & 1)) {
        ((x, y), _) if x == y               => y,
        ((0, x), _) | ((x, 0), _)           => x,
        ((x, y), (0, 1)) | ((y, x), (1, 0)) => gcd(x >> 1, y),
        ((x, y), (0, 0))                    => gcd(x >> 1, y >> 1) << 1,
        ((x, y), (1, 1))                    => { let (x, y) = (min(x, y), max(x, y)); 
                                                 gcd((y - x) >> 1, x) 
                                               }
        _                                   => unreachable!(),
    }
}
```

Tests[edit]

```rust
¬†
   println!("{}",gcd(399,-3999));
   println!("{}",gcd(0,3999));
   println!("{}",gcd(13*13,13*29));
¬†
3
3999
13
```

# Hailstone sequence<a id="sec-17"></a>

The Hailstone sequence of numbers can be generated from a starting positive integer, ¬† n ¬† by:

¬† If ¬† n ¬† is ¬† ¬† 1 ¬† ¬† then the sequence ends. ¬† If ¬† n ¬† is ¬† even then the next ¬† n ¬† of the sequence ¬† = n/2 ¬† If ¬† n ¬† is ¬† odd ¬† then the next ¬† n ¬† of the sequence ¬† = (3 \* n) + 1

The (unproven) Collatz conjecture is that the hailstone sequence for any starting number always terminates.

The hailstone sequence is also known as hailstone numbers (because the values are usually subject to multiple descents and ascents like hailstones in a cloud), or as the Collatz sequence.

Task

Create a routine to generate the hailstone sequence for a number. Use the routine to show that the hailstone sequence for the number 27 has 112 elements starting with 27, 82, 41, 124 and ending with 8, 4, 2, 1 Show the number less than 100,000 which has the longest hailstone sequence together with that sequence's length. ¬† (But don't show the actual sequence!)

See also

¬† xkcd (humourous).

```rust
fn hailstone(start¬†: u32) -> Vec<u32> {
    let mut res = Vec::new();
    let mut next = start;
¬†
    res.push(start);
¬†
    while next¬†!= 1  {
        next = if next¬†% 2 == 0 { next/2 } else { 3*next+1 };
        res.push(next);
    }
    res
}
¬†
¬†
fn main() {
    let test_num = 27;
    let test_hailseq = hailstone(test_num);
¬†
    println!("For {} number of elements is {} ", test_num, test_hailseq.len());
¬†
    let fst_slice = test_hailseq[0..4].iter()
                        .fold("".to_owned(), |acc, i| { acc + &*(i.to_string()).to_owned() + ", " });
    let last_slice = test_hailseq[test_hailseq.len()-4..].iter()
                        .fold("".to_owned(), |acc, i| { acc + &*(i.to_string()).to_owned() + ", " });
¬†
    println!("  hailstone starting with {} ending with {} ", fst_slice, last_slice);
¬†
    let max_range = 100000;
    let mut max_len = 0;
    let mut max_seed = 0;
    for i_seed in 1..max_range {
        let i_len = hailstone(i_seed).len();
¬†
        if i_len > max_len {
            max_len = i_len;
            max_seed = i_seed;
        }
    }
    println!("Longest sequence is {} element long for seed {}", max_len, max_seed);
}
```

Output:

```rust
For 27 number of elements is 112 
  hailstone starting with 27, 82, 41, 124,  ending with 8, 4, 2, 1,  
Longest sequence is 351 element long for seed 77031
```

# A+B<a id="sec-18"></a>

A+B ¬† ‚îÄ‚îÄ‚îÄ a classic problem in programming contests, ¬† it's given so contestants can gain familiarity with the online judging system being used.

Task

Given two integer, ¬† A and B.

Their sum needs to be calculated.

Input data

Two integers are written in the input stream, separated by space(s):

{\displaystyle (-1000&le; A,B&le; +1000)}

Output data

The required output is one integer: ¬† the sum of A and B.

Example

input ¬† output ¬† 2 2 4 3 2 5

```rust
use std::io;
¬†
fn main() {
    let mut line = String::new();
    io::stdin().read_line(&mut line).expect("reading stdin");
¬†
    let mut i: i64 = 0;
    for word in line.split_whitespace() {
        i += word.parse::<i64>().expect("trying to interpret your input as numbers");
    }
    println!("{}", i);
}
```

or

```rust
use std::io;
¬†
fn main() {
    let mut line = String::new();
    io::stdin().read_line(&mut line).expect("reading stdin");
¬†
    let sum: i64 = line.split_whitespace()
                       .map(|x| x.parse::<i64>().expect("Not an integer"))
                       .sum(); 
    println!("{}", sum);
}
```

# Hamming numbers<a id="sec-19"></a>

Hamming numbers are numbers of the form ¬†

```
H  =  2i √ó 3j √ó 5k 

```

where

```
i, j, k  ‚â•  0 

```

Hamming numbers ¬† are also known as ¬† ugly numbers ¬† and also ¬† 5-smooth numbers ¬† (numbers whose prime divisors are less or equal to 5).

Task

Generate the sequence of Hamming numbers, in increasing order. ¬† In particular:

Show the ¬† first twenty ¬† Hamming numbers. Show the ¬† 1691st ¬† Hamming number (the last one below ¬† 231). Show the ¬† one millionth ¬† Hamming number (if the language ‚Äì or a convenient library ‚Äì supports arbitrary-precision integers).

References

Hamming numbers Smooth number Hamming problem from Dr. Dobb's CodeTalk (dead link as of Sep 2011; parts of the thread here and here).

Library: num

Basic version[edit]

Translation of: D

Improved by minimizing the number of BigUint comparisons:

```rust
extern crate num;
num::bigint::BigUint;
¬†
use std::time::Instant;
¬†
fn basic_hamming(n: usize) -> BigUint {
    let two = BigUint::from(2u8);
    let three = BigUint::from(3u8);
    let five = BigUint::from(5u8);
    let mut h = vec![BigUint::from(0u8); n];
    h[0] = BigUint::from(1u8);
    let mut x2 = BigUint::from(2u8);
    let mut x3 = BigUint::from(3u8);
    let mut x5 = BigUint::from(5u8);
    let mut i = 0usize; let mut j = 0usize; let mut k = 0usize;
¬†
    // BigUint comparisons are expensive, so do it only as necessary...
    fn min3(x: &BigUint, y: &BigUint, z: &BigUint) -> (usize, BigUint) {
        let (cs, r1) = if y == z { (0x6, y) } 
                        else if y < z { (2, y) } else { (4, z) };
        if x == r1 { (cs | 1, x.clone()) }
        else if x < r1 { (1, x.clone()) } else { (cs, r1.clone()) }
    }
¬†
    let mut c = 1;
    while c < n { // satisfy borrow checker with extra blocks: {  }
        let (cs, e1) = { min3(&x2, &x3, &x5) };
        h[c] = e1; // vector now owns the generated value
        if (cs & 1)¬†!= 0 { i += 1; x2 = &two * &h[i] }
        if (cs & 2)¬†!= 0 { j += 1; x3 = &three * &h[j] }	
        if (cs & 4)¬†!= 0 { k += 1; x5 = &five * &h[k] }
        c += 1;
    }
¬†
    match h.pop() {
        Some(v) => v,
        _ => panic!("basic_hamming: arg is zero; no elements")
    }
}
¬†
fn main() {
    print!("[");
    for (i, h) in (1..21).map(basic_hamming).enumerate() {
        if i¬†!= 0 { print!(",") }
        print!(" {}", h)
    }
    println!(" ]");
    println!("{}", basic_hamming(1691));
¬†
    let strt = Instant::now();
¬†
    let rslt = basic_hamming(1000000);
¬†
    let elpsd = strt.elapsed();
    let secs = elpsd.as_secs();
    let millis = (elpsd.subsec_nanos() / 1000000)as u64;
    let dur = secs * 1000 + millis;
¬†
    let rs = rslt.to_str_radix(10);
    let mut s = rs.as_str();
    println!("{} digits:", s.len());
        while s.len() > 100 {
            let (f, r) = s.split_at(100);
            s = r;
            println!("{}", f);
        }
        println!("{}", s);
¬†
    println!("This last took {} milliseconds", dur);
}
```

Output:

```rust
[ 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36 ]
2125764000
84 digits:
519312780448388736089589843750000000000000000000000000000000000000000000000000000000
This last took 677 milliseconds.
```

Eliminating duplicate calculations[edit]

Much of the time above is wasted doing big integer multiplications that are duplicated elsewhere as in 2 times 3 and 3 times 2, etc. The following code eliminates such duplicate multiplications and reduces the number of comparisons, as follows:

```rust
fn nodups_hamming(n: usize) -> BigUint {
    let two = BigUint::from(2u8);
    let three = BigUint::from(3u8);
    let five = BigUint::from(5u8);
    let mut m = vec![BigUint::from(0u8); 1];
    m[0] = BigUint::from(1u8);
    let mut h = vec![BigUint::from(0u8); n];
    h[0] = BigUint::from(1u8);
    if n > 1 {
        m.push(BigUint::from(3u8)); // for initial x53 advance
        h[1] = BigUint::from(2u8); // for initial x532 advance
    }
    let mut x5 = BigUint::from(5u8);
    let mut x53 = BigUint::from(9u8); // 3 times 3 because already merged one step
    let mut mrg = BigUint::from(3u8);
    let mut x532 = BigUint::from(2u8);
¬†
    let mut i = 0usize; let mut j = 1usize;
    let mut c = 1usize;
    while c < n { // satisfy borrow checker with extra blocks: {  }
        if &x532 < &mrg { h[c] = x532; i += 1; x532 = &two * &h[i]; }
        else {	h[c] = mrg;
                if &x53 < &x5 { mrg = x53; j += 1; x53 = &three * &m[j]; }
                else { mrg = x5.clone(); x5 = &five * &x5; };
                m.push(mrg.clone()); };
        c += 1;
    }
    match h.pop() {
        Some(v) => v,
        _ => panic!("nodups_hamming: arg is zero; no elements")
    }
}
```

Substitute the calls to the above code for the calls to "basic<sub>hamming</sub>" (three places) in the "main" function above. The output is the same except that the time expended is less (249 milliseconds), for over two and a half times faster.

Much faster logarithmic version with low memory use[edit]

The above versions spend much of their time doing BigUint calculations. The below version eliminates much of that time by using integer powers of 2, 3, and 5 representations and all normal integer calculations except for the final conversion to a BitUint for the final result for about a 30 times speed-up.

Another problem is that the above versions use so much memory that they can't compute even the billionth hamming number without running out of memory on a 16 Gigabyte machine. This version greatly reduces the memory use to about O(n<sup>(2/3)</sup>) by eliminating no longer required back values in batches so that with about 9 Gigabytes it will calculate the hamming numbers to 1.2e13 (it's limit due to the ranges of the exponents) in a day or so. The code is as follows:

```rust
fn log_nodups_hamming(n: u64) -> BigUint {
    if n <= 0 { panic!("nodups_hamming: arg is zero; no elements") }
    if n < 2 { return BigUint::from(1u8) } // trivial case for n == 1
    if n > 1.2e13 as u64 { panic!("log_nodups_hamming: argument too large to guarantee results!") }
¬†
    // constants as expanded integers to minimize round-off errors, and
    // reduce execution time using integer operations not float...
    const LAA2: u64 = 35184372088832; // 2.0f64.powi(45)).round() as u64;
    const LBA2: u64 = 55765910372219; // 3.0f64.log2() * 2.0f64.powi(45)).round() as u64;
    const LCA2: u64 = 81695582054030; // 5.0f64.log2() * 2.0f64.powi(45)).round() as u64;
¬†
    #[derive(Clone, Copy)]
    struct Logelm { // log representation of an element with only allowable powers
        exp2: u16,
        exp3: u16,
        exp5: u16,
        logr: u64 // log representation used for comparison only - not exact
    }
¬†
    impl Logelm {
        fn lte(&self, othr: &Logelm) -> bool {
            if self.logr <= othr.logr { true } else { false }
        }
        fn mul2(&self) -> Logelm {
            Logelm { exp2: self.exp2 + 1, logr: self.logr + LAA2, .. *self }
        }
        fn mul3(&self) -> Logelm {
            Logelm { exp3: self.exp3 + 1, logr: self.logr + LBA2, .. *self }
        }
        fn mul5(&self) -> Logelm {
            Logelm { exp5: self.exp5 + 1, logr: self.logr + LCA2, .. *self }
        }
    }
¬†
    let one = Logelm { exp2: 0, exp3: 0, exp5: 0, logr: 0 };
    let mut x532 = one.mul2();
    let mut mrg = one.mul3();
    let mut x53 = one.mul3().mul3(); // advance as mrg has the former value...
    let mut x5 = one.mul5();
¬†
    let mut h = Vec::with_capacity(65536); // vec!(one.clone(); 0);
    let mut m = Vec::<Logelm>::with_capacity(65536); // vec!(one.clone(); 0);
¬†
    let mut i = 0usize; let mut j = 0usize;
    for _ in 1 .. n {
        let cph = h.capacity();
        if i > cph / 2 { // drain extra unneeded values...
            h.drain(0 .. i);
            i = 0;
        }
        if x532.lte(&mrg) {
            h.push(x532);
            x532 = h[i].mul2();
            i += 1;
        } else {
            h.push(mrg);
            if x53.lte(&x5) {
                mrg = x53;
                x53 = m[j].mul3();
                j += 1;
            } else {
                mrg = x5;
                x5 = x5.mul5();
            }
            let cpm = m.capacity();
            if j > cpm / 2 { // drain extra unneeded values...
                m.drain(0 .. j);
                j = 0;
            }
            m.push(mrg);
        }
    }
¬†
    let o = &h[&h.len() - 1];
    let two = BigUint::from(2u8);
    let three = BigUint::from(3u8);
    let five = BigUint::from(5u8);
    let mut ob = BigUint::from(1u8); // convert to BigUint at the end
    for _ in 0 .. o.exp2 { ob = ob * &two }
    for _ in 0 .. o.exp3 { ob = ob * &three }
    for _ in 0 .. o.exp5 { ob = ob * &five }
    ob
}
```

Again, this function can be used with the same "main" as above and the outputs are the same except that the execution time is only 7 milliseconds. It calculates the hamming number to a billion and just over a second and to one hundred billion in just over 100 seconds - O(n) time complexity. As well as eliminating duplicate calculations and calculating using exponents rather than BitUint operations, it also reduces the time required as compared to other similar algorithms by scaling the logarithms of two, three, and five into 64-bit integers so no floating point operations are required. The scaling is such that round-off errors will not affect the order of results for well past the usable range.

Memory used is greatly reduced to O(n<sup>(2/3)</sup>) by draining the arrays of back values no longer required in batches (rather than one by one) so that less time is used. It also saves time by not requiring as many allocations and de-allocations as the draining is done in place, thus making the current capacity of arrays longer usable.

Sequence version[edit]

As the task actually asks for a sequence of Hamming numbers, any of the above three solutions can easily be adapted to output an Iterator sequence; in this case the last fastest one is converted as follows:

```rust
extern crate num; // requires dependency on the num library
use num::bigint::BigUint;
¬†
use std::time::Instant;
¬†
fn log_nodups_hamming_iter() -> Box<Iterator<Item = (u16, u16, u16)>> {
    // constants as expanded integers to minimize round-off errors, and
    // reduce execution time using integer operations not float...
    const LAA2: u64 = 35184372088832; // 2.0f64.powi(45)).round() as u64;
    const LBA2: u64 = 55765910372219; // 3.0f64.log2() * 2.0f64.powi(45)).round() as u64;
    const LCA2: u64 = 81695582054030; // 5.0f64.log2() * 2.0f64.powi(45)).round() as u64;
¬†
    #[derive(Clone, Copy)]
    struct Logelm { // log representation of an element with only allowable powers
        exp2: u16,
        exp3: u16,
        exp5: u16,
        logr: u64 // log representation used for comparison only - not exact
    }
    impl Logelm {
        fn lte(&self, othr: &Logelm) -> bool {
            if self.logr <= othr.logr { true } else { false }
        }
        fn mul2(&self) -> Logelm {
            Logelm { exp2: self.exp2 + 1, logr: self.logr + LAA2, .. *self }
        }
        fn mul3(&self) -> Logelm {
            Logelm { exp3: self.exp3 + 1, logr: self.logr + LBA2, .. *self }
        }
        fn mul5(&self) -> Logelm {
            Logelm { exp5: self.exp5 + 1, logr: self.logr + LCA2, .. *self }
        }
    }
¬†
    let one = Logelm { exp2: 0, exp3: 0, exp5: 0, logr: 0 };
    let mut x532 = one.mul2();
    let mut mrg = one.mul3();
    let mut x53 = one.mul3().mul3(); // advance as mrg has the former value...
    let mut x5 = one.mul5();
¬†
    let mut h = Vec::with_capacity(65536);
    let mut m = Vec::<Logelm>::with_capacity(65536);
¬†
    let mut i = 0usize; let mut j = 0usize;
    Box::new((0u64 .. ).map(move |it| if it < 1 { (0, 0, 0) } else {
        let cph = h.capacity();
        if i > cph / 2 {
            h.drain(0 .. i);
            i = 0;
        }
        if x532.lte(&mrg) {
            h.push(x532);
            x532 = h[i].mul2();
            i += 1;
        } else {
            h.push(mrg);
            if x53.lte(&x5) {
                mrg = x53;
                x53 = m[j].mul3();
                j += 1;
            } else {
                mrg = x5;
                x5 = x5.mul5();
            }
            let cpm = m.capacity();
            if j > cpm / 2 {
                m.drain(0 .. j);
                j = 0;
            }
            m.push(mrg);
        }
        let o = &h[&h.len() - 1];
        (o.exp2, o.exp3, o.exp5)
    }))
}
¬†
fn convert_log2big(o: (u16, u16, u16)) -> BigUint {
    let two = BigUint::from(2u8);
    let three = BigUint::from(3u8);
    let five = BigUint::from(5u8);
    let (x2, x3, x5) = o;
    let mut ob = BigUint::from(1u8); // convert to BigUint at the end
    for _ in 0 .. x2 { ob = ob * &two }
    for _ in 0 .. x3 { ob = ob * &three }
    for _ in 0 .. x5 { ob = ob * &five }
    ob
}
¬†
fn main() {
    print!("[");
    for (i, h) in log_nodups_hamming_iter().take(20).map(convert_log2big).enumerate() {
        if i¬†!= 0 { print!(",") }
        print!(" {}", h)
    }
    println!(" ]");
    println!("{}", convert_log2big(log_nodups_hamming_iter().take(1691).last().unwrap()));
¬†
    let strt = Instant::now();
¬†
//  let rslt = convert_log2big(log_nodups_hamming_iter().take(1000000000).last().unwrap());
    let mut it = log_nodups_hamming_iter().into_iter();
    for _ in 0 .. 100-1 { // a little faster; less one level of iteration
        let _ = it.next();
    }
    let rslt = convert_log2big(it.next().unwrap());
¬†
    let elpsd = strt.elapsed();
    let secs = elpsd.as_secs();
    let millis = (elpsd.subsec_nanos() / 1000000)as u64;
    let dur = secs * 1000 + millis;
¬†
    println!("2^{} times 3^{} times 5^{}", rslt.0, rslt.1, rslt.2);
    let rs = convert_log2big(rslt).to_str_radix(10);
    let mut s = rs.as_str();
    println!("{} digits:", s.len());
    let lg3 = 3.0f64.log2();
    let lg5 = 5.0f64.log2();
    let lg = (rslt.0 as f64 + rslt.1 as f64 * lg3
           + rslt.2 as f64 * lg5) * 2.0f64.log10();
    println!("Approximately {}E+{}", 10.0f64.powf(lg.fract()), lg.trunc());
    if s.len() <= 10000 {
        while s.len() > 100 {
            let (f, r) = s.split_at(100);
            s = r;
            println!("{}", f);
        }
        println!("{}", s);
    }
¬†
    println!("This last took {} milliseconds.", dur);
}
```

Output:

```rust
[ 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36 ]
2125764000
2^55 times 3^47 times 5^64
84 digits:
Approximately 5.193127804483804E+83
519312780448388736089589843750000000000000000000000000000000000000000000000000000000
This last took 17 milliseconds.
```

The above final output is the same as the last one, but the function is called differently; also note that it is somewhat slower than the last version due to the extra function calls required to enumerate over an Iterator. It can enumerate the Hamming numbers up to a billion in about 20 seconds instead of the about ten seconds for the last version - about O(n) time complexity, and has the same O(n<sup>(2/3)</sup>) space complexity as the last version.

Functional sequence version avoiding duplicates[edit]

It has been said by some that Rust is basically a functional language; however that isn't quite true in several respects, at least as per the following:

It does not guaranty tail call optimization for functions, thus sometimes requiring imperative forms of code to produce that effect. It does not have currying or partial application of function arguments without using kludges of nested function/closure calls. move closures cannot use recursive shared values without using interior mutability inside a reference counted value (required here) Closures are not recursive without using a trick involving shared state reference counted values (demonstrated here). It currently does not have a standard library implementation of a lazily computed value (required to implement a Lazy List, and It accordingly is not as easy as in most other languages to implement Co-Inductive Streams or (also memoized) Lazy Lists (a form of Lazy List is required here).

Many of these come about due to the Rust memory model where pieces of programs "own" data and its disposal but can assign references to other pieces of code (with limits if mutability is required), instead of the Garbage Collected model used by most other functional languages where variables are owned by the system and program code just uses references to that data other than for primitives which are owned by whoever uses them.

The lack of the Lazy type and thus the Lazy List type is partly due to Rust's still being relatively unstable, as Lazy requires a "thunk" (a zero argument move closure acting on owned data - FnOnce in Rust), and in Rust these must be boxed (allocated on the heap) to be usable; however "Box<FnOnce() -> T>" does not currently work, the stopgap measure of "FnBox" is marked as unstable and thus can only be used in (unstable) "nightly" version of the compiler, and the "thunk" standard library which implemented the "Invoke" trait boilerplate code that made it possible was removed from the current version in anticipation of something better. In this code I have accordingly resurrected just enough of the old standard library code to make this work.

Jeremy Reems had implemented Lazy and also LazyList, but they haven't been maintained for many years and don't compile (likely waiting for stable features). According, I have implemented enough of this functionality as required by this algorithm, as per the following code (tested on Rust version 1.13):

Translation of: Haskell

```rust
extern crate num;
use num::bigint::BigUint;
¬†
use std::rc::Rc;
use std::iter::FromIterator;
use std::cell::{UnsafeCell, RefCell};
use std::mem;
¬†
use std::time::Instant;
¬†
// since Box<FnOnce() -> T + 'a> doesn't currently work and
// FnBox, which does work, (version 1.13) is UnStable;
// use the boilerplate Invoke trait and Thunk
// from the old removed thunk standard library... 
¬†
pub trait Invoke<R = ()> {
    fn invoke(self: Box<Self>) -> R;
}
¬†
impl<R, F: FnOnce() -> R> Invoke<R> for F {
    #[inline(always)]
    fn invoke(self: Box<F>) -> R { (*self)() }
}
¬†
pub struct Thunk<'a, R>(Box<Invoke<R> + 'a>);
¬†
impl<'a, R: 'a> Thunk<'a, R> {
    #[inline(always)]
    fn new<F: 'a + FnOnce() -> R>(func: F) -> Thunk<'a, R> {
        Thunk(Box::new(func))
    }
    #[inline(always)]
    fn invoke(self) -> R { self.0.invoke() }
}
¬†
// actual Lazy implementation starts here...
¬†
use self::LazyState::*;
¬†
pub struct Lazy<'a, T: 'a>(UnsafeCell<LazyState<'a, T>>);
¬†
enum LazyState<'a, T: 'a> {
    Unevaluated(Thunk<'a, T>),
    EvaluationInProgress,
    Evaluated(T)
}
¬†
impl<'a, T: 'a> Lazy<'a, T>{
    #[inline]
    pub fn new<'b, F>(thunk: F) -> Lazy<'b, T>
            where F: 'b + FnOnce() -> T {
        Lazy(UnsafeCell::new(Unevaluated(Thunk::new(thunk))))
    }
    #[inline]
    pub fn evaluated(val: T) -> Lazy<'a, T> {
        Lazy(UnsafeCell::new(Evaluated(val)))
    }
    #[inline]
    fn force<'b>(&'b self) { // not thread-safe
        unsafe {
            match *self.0.get() {
                Evaluated(_) => return, // nothing required; already Evaluated
                EvaluationInProgress => panic!("Lazy::force called recursively!!!"),
                _ => () // need to do following something else if Unevaluated...
            } // following eliminates recursive race; drops neither on replace...
            match mem::replace(&mut *self.0.get(), EvaluationInProgress) {
                Unevaluated(thnk) => { // thnk can't call force on the same Lazy
                    *self.0.get() = Evaluated(thnk.invoke());
                },
                _ => unreachable!() // already took care of other cases in above match.
            }
        }
    }
    #[inline]
    pub fn value<'b>(&'b self) -> &'b T {
        self.force(); // evaluatate if not evealutated
        match unsafe { &*self.0.get() } {
            &Evaluated(ref v) => v, // return value
            _ => { unreachable!() } // previous force guarantees never not Evaluated
        }
    }
    #[inline]
    pub fn unwrap<'b>(self) -> T where T: 'b { // consumes the object to produce the value
        self.force(); // evaluatate if not evealutated
        match unsafe { self.0.into_inner() } {
            Evaluated(v) => v,
            _ => unreachable!() // previous code guarantees never not Evaluated
        }
    }
}
¬†
// now for immutable persistent shareable (memoized) LazyList via Lazy above
¬†
type RcLazyListNode<'a, T: 'a> = Rc<Lazy<'a, LazyList<'a, T>>>;
¬†
use self::LazyList::*;
¬†
#[derive(Clone)]
enum LazyList<'a, T: 'a + Clone> {
    /// The Empty List
    Empty,
    /// A list with one member and possibly another list.
    Cons(T, RcLazyListNode<'a, T>)
}
¬†
impl<'a, T: 'a + Clone> LazyList<'a, T> {
    #[inline]
    pub fn cons<F>(v: T, cntf: F) -> LazyList<'a, T>
            where F: 'a + FnOnce() -> LazyList<'a, T> {
        Cons(v, Rc::new(Lazy::new(cntf)))
    }
    #[inline]
    pub fn head<'b>(&'b self) -> &'b T {
        if let Cons(ref hd, _) = *self { return hd }
        panic!("LazyList::head called on an Empty LazyList!!!")
    }
    #[inline]
    pub fn tail<'b>(&'b self) -> &'b Lazy<'a, LazyList<'a, T>> {
        if let Cons(_, ref rlln) = *self { return &*rlln }
        panic!("LazyList::tail called on an Empty LazyList!!!")
    }
    #[inline]
    pub fn unwrap(self) -> (T, RcLazyListNode<'a, T>) { // consumes the object
        if let Cons(hd, rlln) = self {
            return (hd, rlln) }
        panic!("LazyList::unwrap called on an Empty LazyList!!!")
    }
}
¬†
impl<'a, T: 'a + Clone> Iterator for LazyList<'a, T> {
    type Item = T;
    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        if let Empty = *self { return None }
        let oldll = mem::replace(self, Empty);
        let (hd, rlln) = oldll.unwrap();
        let mut newll = rlln.value().clone();
        mem::swap(self, &mut newll); // self now contains tail, newll contains the Empty
        Some(hd)
    }
}
¬†
// implements worker wrapper recursion closures using shared RcMFn variable...
¬†
type RcMFn<'a, T: 'a> = Rc<UnsafeCell<Box<FnMut(T) -> T + 'a>>>;
¬†
//#[derive(Clone)]
//struct RcMFn<'a, T: 'a>(Rc<UnsafeCell<Box<FnMut() -> T + 'a>>>);
¬†
trait RcMFnMethods<'a, T> {
    fn create<F: FnMut(T) -> T + 'a>(v: F) -> RcMFn<'a, T>;
    fn invoke(&self, v: T) -> T;
    fn set<F: FnMut(T) -> T + 'a>(&self, v: F);
}
¬†
impl<'a, T: 'a> RcMFnMethods<'a, T> for RcMFn<'a, T> {
    fn create<F: FnMut(T) -> T + 'a>(v: F) -> RcMFn<'a, T> { // creates new value wrapper
        Rc::new(UnsafeCell::new(Box::new(v)))
    }
    #[inline(always)] // needs to be faster to be worth it
    fn invoke(&self, v: T) -> T {
        unsafe { (*(*(*self).get()))(v) }
    }
    fn set<F: FnMut(T) -> T + 'a>(&self, v: F) {
        unsafe { *self.get() = Box::new(v); }
    }
}
¬†
// implementation for a reference-counted, interior-mutable variable
// necessary for such things as sharing data and recursive variables
¬†
type RcMVar<T> = Rc<RefCell<T>>;
¬†
//#[derive(Clone)]
//struct RcMVar<T>(Rc<RefCell<T>>);
¬†
trait RcMVarMethods<T> {
    fn create(v: T) -> Self;
    fn get(self: &Self) -> T;
    fn set(self: &Self, v: T);
}
¬†
impl<T: Clone> RcMVarMethods<T> for RcMVar<T> {
    fn create(v: T) -> RcMVar<T> { // creates new value wrapped in RcMVar
        Rc::new(RefCell::new(v))
    }
    #[inline]
    fn get(&self) -> T {
        self.borrow().clone()
    }
    fn set(&self, v: T) {
        *self.borrow_mut() = v;
    }
}
¬†
// finally what the task objective requires...
¬†
fn hammings() -> Box<Iterator<Item = Rc<BigUint>>> {
    type LL<'a> = LazyList<'a, Rc<BigUint>>;
    fn merge<'a>(x: LL<'a>, y: LL<'a>) -> LL<'a> {
        let lte = { x.head() <= y.head() }; // private context for borrow
        if lte {
            let (hdx, tlx) = x.unwrap();
            LL::cons(hdx, move || merge(tlx.value().clone(), y))
        } else {
            let (hdy, tly) = y.unwrap();
            LL::cons(hdy, move || merge(x, tly.value().clone()))
        }
    }
    fn smult<'a>(m: BigUint, s: LL<'a>) -> LL<'a> { // like map m * but faster...
        let smlt = RcMFn::create(move |ss: LL<'a>| ss);
        let csmlt = smlt.clone();
        smlt.set(move |ss: LL<'a>| {
            let (hd, tl) = ss.unwrap();
            let ccsmlt = csmlt.clone();
            LL::cons(Rc::new(&m * &*hd), move || ccsmlt.invoke(tl.value().clone()))
        });
        smlt.invoke(s)
    }
    fn u<'a>(s: LL<'a>, n: usize) -> LL<'a> {
        let nb = BigUint::from(n);
        let rslt = RcMVar::create(Empty);
        let crslt = rslt.clone(); // same interior data...
        let cll = LL::cons(Rc::new(BigUint::from(1u8)), move || crslt.get()); // gets future value
        // below sets future value for above closure...
        rslt.set(if let Empty = s { smult(nb, cll) } else { merge(s, smult(nb, cll)) });
        rslt.get()
    }
    fn rll<'a>() -> LL<'a> { [5, 3, 2].into_iter()
                                .fold(Empty, |ll, n| u(ll, *n) ) }
    let hmng = LL::cons(Rc::new(BigUint::from(1u8)), move || rll());
    Box::new(hmng.into_iter())
}
¬†
// and the required test outputs...
¬†
fn main() {
    print!("[");
    for (i, h) in hammings().take(20).enumerate() {
        if i¬†!= 0 { print!(",") }
        print!(" {}", h)
    }
    println!(" ]");
¬†
    println!("{}", hammings().take(1691).last().unwrap());
¬†
    let strt = Instant::now();
¬†
    let rslt = hammings().take(1000000).last().unwrap();
¬†
    let elpsd = strt.elapsed();
    let secs = elpsd.as_secs();
    let millis = (elpsd.subsec_nanos() / 1000000)as u64;
    let dur = secs * 1000 + millis;
¬†
    println!("{}", rslt);
¬†
    println!("This last took {} milliseconds.", dur);
}
```

As can be seen, there is little code necessary for the "hammings" and "main" functions if the rest were available in libraries, as they really should be once Rust is more stable.

Output:

```rust
[ 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36 ]
2125764000
519312780448388736089589843750000000000000000000000000000000000000000000000000000000
This last took 408 milliseconds.
```

In order to run this fast. the BigUint LazyList values are wrapped in a reference counted heap wrapper to make it more efficient for cloning operations as necessary to extract interior values from the nested RcLazyListNode structure.

This is reasonably fast, with it a little slower than some languages as the BigUint library isn't as fast as some, but about 75% of the time is spent on LazyList processing. This is likely due to the many heap allocations and de-allocations required as well as the time required to process all of the reference counting. At that, on the same machine (Intel Sky Lake i5-6500 @ 3.2 Gigahertz) it is still about four times faster than F# and two times faster than C# running the same functional algorithm. However, it is about three times slower than Java JVM based languages (Scala, Kotlin, Clojure, etc.) and about four times slower than Haskell, likely due to those languages having very efficient memory management for many frequent small-byte-sizes per allocation/collection as for such functional algorithms, and as well not requiring reference counting due to garbage collection.

So Rust can be used to implement purely functional algorithms, but it isn't the best at it neither for conciseness of code nor for performance.

Extremely fast non-sequence version by calculation of top band of Hamming numbers[edit]

One might ask "What could possibly be done to further speed up finding Hamming numbers?": the answer is quite a lot, but one has to dump the ability to iterate a sequence as that depends on being able to refer to past calculated values by back pointers to the memorized O(n<sup>(2/3)</sup>) arrays or lists and thus quite large amounts of memory. If one just wants to find very large Hamming numbers individually, one looks to the [mathematical analysis of Hamming/regular numbers on Wikipedia](<https://en.wikipedia.org/wiki/Regular_number>) and finds there is quite an exact relationship between 'n', the sequence number, and the logarithmic magnitude of the resulting Hamming number, and that the error term is directly proportional to the logarithm of that output number. This means that only the band of Hamming values as wide of this error and including the estimated value need to be generated, and that we need only iterate over two of the three prime exponents, thus O(n<sup>(2/3)</sup>) time complexity and O(n<sup>(1/3)</sup>) space complexity. The following code was adapted from [an article in DDJ](<http://www.drdobbs.com/architecture-and-design/hamming-problem/228700538>) and the Haskell code with the further refinements to decrease the memory requirements as described above:

Translation of: Haskell

```rust
extern crate num; // requires dependency on the num library
use num::bigint::BigUint;
¬†
use std::time::Instant;
¬†
fn nth_hamming(n: u64) -> (u32, u32, u32) {
    if n < 2 {
        if n <= 0 { panic!("nth_hamming: argument is zero; no elements") }
        return (0, 0, 0) // trivial case for n == 1
    }
¬†
    let lg3 = 3.0f64.ln() / 2.0f64.ln(); // log base 2 of 3
    let lg5 = 5.0f64.ln() / 2.0f64.ln(); // log base 2 of 5
    let fctr = 6.0f64 * lg3 * lg5;
    let crctn = 30.0f64.sqrt().ln() / 2.0f64.ln(); // log base 2 of sqrt 30
    let lgest = (fctr * n as f64).powf(1.0f64/3.0f64)
                    - crctn; // from WP formula
    let frctn = if n < 1000000000 { 0.509f64 } else { 0.105f64 };
    let lghi = (fctr * (n as f64 + frctn * lgest)).powf(1.0f64/3.0f64)
                    - crctn; // calculate hi log limit based on log(N) - WP article
    let lglo = 2.0f64 * lgest - lghi; // and a lower limit of the upper "band"
    let mut count = 0; // need to use extended precision, might go over
    let mut bnd = Vec::with_capacity(0);
    let klmt = (lghi / lg5) as u32 + 1;
    for k in 0 .. klmt { // i, j, k values can be just u32 values
        let p = k as f64 * lg5;
        let jlmt = ((lghi - p) / lg3) as u32 + 1;
        for j in 0 .. jlmt {
            let q = p + j as f64 * lg3;
            let ir = lghi - q;
            let lg = q + (ir as u32) as f64; // current log value (estimated)
            count += ir as u64 + 1;
            if lg >= lglo {
                bnd.push((lg, (ir as u32, j, k)))
            }
        }
    }
    if n > count { panic!("nth_hamming: band high estimate is too low!") };
    let ndx = (count - n) as usize;
    if ndx >= bnd.len() { panic!("nth_hamming: band low estimate is too high!") };
    bnd.sort_by(|a, b| b.0.partial_cmp(&a.0).unwrap()); // sort decreasing order
¬†
    bnd[ndx].1
}
¬†
fn convert_log2big(o: (u32, u32, u32)) -> BigUint {
    let two = BigUint::from(2u8);
    let three = BigUint::from(3u8);
    let five = BigUint::from(5u8);
    let (x2, x3, x5) = o;
    let mut ob = BigUint::from(1u8); // convert to BigUint at the end
    for _ in 0 .. x2 { ob = ob * &two }
    for _ in 0 .. x3 { ob = ob * &three }
    for _ in 0 .. x5 { ob = ob * &five }
    ob
}
¬†
fn main() {
    print!("[");
    for (i, h) in (1 .. 21).map(nth_hamming).enumerate() {
        if i¬†!= 0 { print!(",") }
        print!(" {}", convert_log2big(h))
    }
    println!(" ]");
    println!("{}", convert_log2big(nth_hamming(1691)));
¬†
    let strt = Instant::now();
¬†
    let rslt = nth_hamming(1000000);
¬†
    let elpsd = strt.elapsed();
    let secs = elpsd.as_secs();
    let millis = (elpsd.subsec_nanos() / 1000000)as u64;
    let dur = secs * 1000 + millis;
¬†
    println!("2^{} times 3^{} times 5^{}", rslt.0, rslt.1, rslt.2);
    let rs = convert_log2big(rslt).to_str_radix(10);
    let mut s = rs.as_str();
    println!("{} digits:", s.len());
    let lg3 = 3.0f64.log2();
    let lg5 = 5.0f64.log2();
    let lg = (rslt.0 as f64 + rslt.1 as f64 * lg3
            + rslt.2 as f64 * lg5) * 2.0f64.log10();
    println!("Approximately {}E+{}", 10.0f64.powf(lg.fract()), lg.trunc());
    if s.len() <= 10000 {
        while s.len() > 100 {
            let (f, r) = s.split_at(100);
            s = r;
            println!("{}", f);
        }
        println!("{}", s);
    }
¬†
    println!("This last took {} milliseconds.", dur);
}
```

```rust
[ 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36 ]
2125764000
2^55 times 3^47 times 5^64
84 digits:
Approximately 5.193127804483804E+83
519312780448388736089589843750000000000000000000000000000000000000000000000000000000
This last took 0 milliseconds.
```

The above code takes too little time to calculate the millionth Hamming numbers to be measured (as seen above), calculates the billionth number in under 10 milliseconds, calculates the trillionth in less than a second, and the thousand trillionth (10<sup>15</sup>) in just over a minute (72 seconds). However, the program needs to be tuned for correctness for ranges of about the 100 trillionth value and above as the precision of the log approximation is not sufficient above about that level to maintain the proper sort order, and thus the answers will start to be out by one value or more. The answers are likely correct up to that point as they are the same to a trillion as the equivalent Haskell program, although this version is much faster due to no garbage collection (the Haskell version spends about half its time garbage collecting) and doing the calculations using loops and array/vector accesses rather than the lazy list processing used in the Haskell version. The program should be able to determine the 10<sup>19th</sup> hamming number in a few hours and can't quite find the 2<sup>64th</sup> (18446744073709551615th) Hamming number due to a slight overflow near the limit.

The above code uses the library vector sort capabilities; custom sorting versions could be written but with the reduced array size, sorting is a very small percentage of the execution time and maximum space requirements are only a few 10's of Megabytes so that neither the time nor the space used for sorting are a concern.

Note that I'm not knocking Haskell, just that (as here) many Haskell programmers like to use lazy list processing which has its costs; the Haskell version could be re-written to use arrays and functional loops and likely be about the same speed although perhaps not as concise. By simply converting the Haskell program to force strictness and to use this same method of determining the width of the upper band, the Haskell program would have the same time and space complexity as here, but would still be a constant factor of almost eight times slower due to the list processing (with a constant factor for extra space as well). Use of a mutable array or vector would solve that, but unfortunately not as easily as here as there would be the question of "unboxed" versus "boxed" arrays/vectors, and the complexities of implementing the (faster) unboxed type in which to sort the band - in short, not as easy as here in Rust.

# Empty program<a id="sec-20"></a>

Task

Create the simplest possible program that is still considered "correct."

```rust
fn main(){}
```

# Greatest element of a list<a id="sec-21"></a>

Task

Create a function that returns the maximum value in a provided set of values, where the number of values may not be known until run-time.

This is built in functionality for everything that can be iterated over. It returns an Option<T>, meaning Some(e) if there are elements in the iterator and None if it is empty.

```rust
fn main() {
    let nums = [1,2,39,34,20];
    println!("{:?}", nums.iter().max());
    println!("{}", nums.iter().max().unwrap());
}
```

Output:

```rust
Some(39)
39
```

# Palindrome detection<a id="sec-22"></a>

A palindrome is a phrase which reads the same backward and forward.

Task[edit]

Write a function or program that checks whether a given sequence of characters (or, if you prefer, bytes) is a palindrome.

For extra credit:

Support Unicode characters. Write a second function (possibly as a wrapper to the first) which detects inexact palindromes, i.e. phrases that are palindromes if white-space and punctuation is ignored and case-insensitive comparison is used.

Hints

It might be useful for this task to know how to reverse a string. This task's entries might also form the subjects of the task Test a function.

Related tasks

Word plays

Ordered words Palindrome detection Semordnilap Anagrams Anagrams/Deranged anagrams

```rust
¬†
fn is_palindrome(string: &str) -> bool {
    let half_len = string.len()/2;
    string.chars().take(half_len).eq(string.chars().rev().take(half_len))
}
¬†
macro_rules! test {
    ( $( $x:tt ),* ) => { $( println!("'{}': {}", $x, is_palindrome($x)); )* };
}
¬†
fn main() {
    test!("",
          "a",
          "ada",
          "adad",
          "ingirumimusnocteetconsumimurigni",
          "‰∫∫‰∫∫ÁÇ∫Êàë,ÊàëÁÇ∫‰∫∫‰∫∫",
          "–Ø –∏–¥—É —Å –º–µ—á–µ–º, —Å—É–¥–∏—è",
          "ÏïÑÎì§Îî∏Îì§ÏïÑ",
          "The quick brown fox");
}
¬†
```

Output:

```rust
'': true
'a': true
'ada': true
'adad': false
'ingirumimusnocteetconsumimurigni': true
'‰∫∫‰∫∫ÁÇ∫Êàë,ÊàëÁÇ∫‰∫∫‰∫∫': true
'–Ø –∏–¥—É —Å –º–µ—á–µ–º, —Å—É–¥–∏—è': false
'ÏïÑÎì§Îî∏Îì§ÏïÑ': true
'The quick brown fox': false

```

The above soluion checks if the codepoints form a pallindrome, but it is perhaps more correct to consider if the graphemes form a pallindrome. This can be accomplished with an external library and a slight modification to is<sub>palindrome</sub>.

```rust
extern crate unicode_segmentation;
use unicode_segmentation::UnicodeSegmentation;
fn is_palindrome(string: &str) -> bool {
    string.graphemes(true).eq(string.graphemes(true).rev())
}
```

# Call a function<a id="sec-23"></a>

Task

Demonstrate the different syntax and semantics provided for calling a function.

This may include:

¬† Calling a function that requires no arguments ¬† Calling a function with a fixed number of arguments ¬† Calling a function with optional arguments ¬† Calling a function with a variable number of arguments ¬† Calling a function with named arguments ¬† Using a function in statement context ¬† Using a function in first-class context within an expression ¬† Obtaining the return value of a function ¬† Distinguishing built-in functions and user-defined functions ¬† Distinguishing subroutines and functions ¬† Stating whether arguments are passed by value or by reference ¬† Is partial application possible and how

This task is not about defining functions.

```rust
fn main() {
    // Rust has a lot of neat things you can do with functions: let's go over the basics first
    fn no_args() {}
    // Run function with no arguments
    no_args();
¬†
    // Calling a function with fixed number of arguments.
    // adds_one takes a 32-bit signed integer and returns a 32-bit signed integer
    fn adds_one(num: i32) -> i32 {
        // the final expression is used as the return value, though `return` may be used for early returns
        num + 1
    }
    adds_one(1);
¬†
    // Optional arguments
    // The language itself does not support optional arguments, however, you can take advantage of
    // Rust's algebraic types for this purpose
    fn prints_argument(maybe: Option<i32>) {
        match maybe {
            Some(num) => println!("{}", num),
            None => println!("No value given"),
        };
    }
    prints_argument(Some(3));
    prints_argument(None);
¬†
    // You could make this a bit more ergonomic by using Rust's Into trait
    fn prints_argument_into<I>(maybe: I)
        where I: Into<Option<i32>>
    {
        match maybe.into() {
            Some(num) => println!("{}", num),
            None => println!("No value given"),
        };
    }
    prints_argument_into(3);
    prints_argument_into(None);
¬†
    // Rust does not support functions with variable numbers of arguments. Macros fill this niche
    // (println! as used above is a macro for example)
¬†
    // Rust does not support named arguments
¬†
    // We used the no_args function above in a no-statement context
¬†
    // Using a function in an expression context
    adds_one(1) + adds_one(5); // evaluates to eight
¬†
    // Obtain the return value of a function.
    let two = adds_one(1);
¬†
    // In Rust there are no real built-in functions (save compiler intrinsics but these must be
    // manually imported)
¬†
    // In rust there are no such thing as subroutines
¬†
    // In Rust, there are three ways to pass an object to a function each of which have very important
    // distinctions when it comes to Rust's ownership model and move semantics. We may pass by
    // value, by immutable reference, or mutable reference.
¬†
    let mut v = vec![1, 2, 3, 4, 5, 6];
¬†
    // By mutable reference
    fn add_one_to_first_element(vector: &mut Vec<i32>) {
        vector[0] += 1;
    }
    add_one_to_first_element(&mut v);
    // By immutable reference
    fn print_first_element(vector: &Vec<i32>) {
        println!("{}", vector[0]);
    }
    print_first_element(&v);
¬†
    // By value
    fn consume_vector(vector: Vec<i32>) {
        // We can do whatever we want to vector here
    }
    consume_vector(v);
    // Due to Rust's move semantics, v is now inaccessible because it was moved into consume_vector
    // and was then dropped when it went out of scope
¬†
    // Partial application is not possible in rust without wrapping the function in another
    // function/closure e.g.:
    fn average(x: f64, y: f64) -> f64 {
        (x + y) / 2.0
    }
    let average_with_four = |y| average(4.0, y);
    average_with_four(2.0);
¬†
¬†
}
```

# Quine<a id="sec-24"></a>

A Quine is a self-referential program that can, without any external access, output its own source.

It is named after the philosopher and logician who studied self-reference and quoting in natural language, as for example in the paradox "'Yields falsehood when preceded by its quotation' yields falsehood when preceded by its quotation."

"Source" has one of two meanings. It can refer to the text-based program source. For languages in which program source is represented as a data structure, "source" may refer to the data structure: quines in these languages fall into two categories: programs which print a textual representation of themselves, or expressions which evaluate to a data structure which is equivalent to that expression.

The usual way to code a Quine works similarly to this paradox: The program consists of two identical parts, once as plain code and once quoted in some way (for example, as a character string, or a literal data structure). The plain code then accesses the quoted code and prints it out twice, once unquoted and once with the proper quotation marks added. Often, the plain code and the quoted code have to be nested.

Task

Write a program that outputs its own source code in this way. If the language allows it, you may add a variant that accesses the code directly. You are not allowed to read any external files with the source code. The program should also contain some sort of self-reference, so constant expressions which return their own value which some top-level interpreter will print out. Empty programs producing no output are not allowed.

There are several difficulties that one runs into when writing a quine, mostly dealing with quoting:

Part of the code usually needs to be stored as a string or structural literal in the language, which needs to be quoted somehow. However, including quotation marks in the string literal itself would be troublesome because it requires them to be escaped, which then necessitates the escaping character (e.g. a backslash) in the string, which itself usually needs to be escaped, and so on. Some languages have a function for getting the "source code representation" of a string (i.e. adds quotation marks, etc.); in these languages, this can be used to circumvent the quoting problem. Another solution is to construct the quote character from its character code, without having to write the quote character itself. Then the character is inserted into the string at the appropriate places. The ASCII code for double-quote is 34, and for single-quote is 39. Newlines in the program may have to be reproduced as newlines in the string, which usually requires some kind of escape sequence (e.g. "\n"). This causes the same problem as above, where the escaping character needs to itself be escaped, etc. If the language has a way of getting the "source code representation", it usually handles the escaping of characters, so this is not a problem. Some languages allow you to have a string literal that spans multiple lines, which embeds the newlines into the string without escaping. Write the entire program on one line, for free-form languages (as you can see for some of the solutions here, they run off the edge of the screen), thus removing the need for newlines. However, this may be unacceptable as some languages require a newline at the end of the file; and otherwise it is still generally good style to have a newline at the end of a file. (The task is not clear on whether a newline is required at the end of the file.) Some languages have a print statement that appends a newline; which solves the newline-at-the-end issue; but others do not.

Next to the Quines presented here, many other versions can be found on the Quine page.

A short quine (works with Rust 1.3.0):

```rust
fn main() {
    let x = "fn main() {\n    let x = ";
    let y = "print!(\"{}{:?};\n    let y = {:?};\n    {}\", x, x, y, y)\n}\n";
    print!("{}{:?};
    let y = {:?};
    {}", x, x, y, y)
}
```

Using the method on Wikipedia (0.9-pre-compatible, does not compile on Rust 1.0.0 and newer):

```rust
¬†
fn main()
{
        let q = 34u8;
        let p = 44u8;
        let l = [
        "fn main()",
        "{",
        "        let q = 34u8;",
        "        let p = 44u8;",
        "        let l = [",
        "        ",
        "        ];",
        "        let mut i = 0;",
        "        while i < 5",
        "        {",
        "                println(l[i]);",
        "                i+=1;",
        "        }",
        "        i = 0;",
        "        while i < l.len()",
        "        {",
        "                print(l[5]);",
        "                print((q as char).to_str());",
        "                print(l[i]);",
        "                print((q as char).to_str());",
        "                println((p as char).to_str());",
        "                i+=1;",
        "        }",
        "        i = 6;",
        "        while i < l.len()",
        "        {",
        "                println(l[i]);",
        "                i+=1;",
        "        }",
        "}",
        ];
        let mut i = 0;
        while i < 5
        {
                println(l[i]);
                i+=1;
        }
        i = 0;
        while i < l.len()
        {
                print(l[5]);
                print((q as char).to_str());
                print(l[i]);
                print((q as char).to_str());
                println((p as char).to_str());
                i+=1;
        }
        i = 6;
        while i < l.len()
        {
                println(l[i]);
                i+=1;
        }
}
¬†
```

A quine in the shape of a circle:

```rust
¬†
                                                      fn main(){let q:&[u8]=&[
                                                32,00,00,00,00,00,00,00,61,27,80,82,
                                       73,78,84,76,78,01,08,02,91,93,70,78,00,77,65,73,78,08,
                                 09,91,91,76,69,84,00,81,26,06,59,85,24,61,29,06,59,02,12,00,51,84,
                              82,73,78,71,26,26,70,82,79,77,63,85,84,70,24,08,86,69,67,01,59,66,07,00,
                           07,27,00,21,20,61,09,14,85,78,87,82,65,80,08,09,09,27,76,69,84,00,82,29,08,81,
                     14,76,69,78,08,09,65,83,00,70,22,20,15,83,84,68,26,26,70,22,20,32,00,00,00,00,00,00,00,00,
                  00,26,26,67,79,78,83,84,83,26,26,48,41,09,14,83,81,82,84,08,09,65,83,00,73,19,18,11,20,27,76,69,
                  84,00,77,85,84,00,66,26,00,54,69,67,28,08,73,19,18,12,00,73,19,18,09,00,30,29,00,54,69,67,26,26,
               78,69,87,08,09,27,00,15,10,00,00,00,79,79,69,82,00,00,10,15,00,76,69,84,00,77,85,84,00,88,29,82,13,17,
            27,00,76,69,84,00,77,85,84,00,89,29,16,27,32,00,00,00,00,00,00,00,00,00,00,76,69,84,00,77,85,84,00,75,29,17,
         27,76,69,84,00,77,85,84,00,74,29,17,27,76,69,84,00,77,85,84,00,69,29,75,00,13,08,82,28,28,17,09,27,87,72,73,76,69,
         00,88,30,29,89,91,66,14,80,85,83,72,08,08,82,11,88,12,82,11,89,09,09,27,66,14,80,85,83,72,08,08,82,11,89,12,82,11,
      88,09,09,27,00,66,14,80,85,83,72,08,08,82,13,89,12,82,11,88,09,32,00,00,00,00,00,00,00,00,00,00,00,00,00,09,27,66,14,80,
      85,83,72,08,08,82,13,88,12,00,82,11,89,09,09,27,66,14,80,85,83,72,08,08,82,13,88,12,82,13,89,09,09,27,66,14,80,85,83,72,
      08,08,82,13,89,12,82,13,88,09,09,27,00,66,14,80,85,83,72,08,08,82,11,89,12,82,13,88,09,09,27,66,14,80,85,83,72,08,08,82,
   11,88,12,82,13,89,09,09,27,00,73,70,00,69,28,29,16,91,32,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,89,11,29,17,27,69,11,
   29,74,27,74,11,29,18,27,93,73,70,00,69,30,16,00,91,88,13,29,17,27,75,11,29,18,27,69,11,29,75,13,08,82,28,28,17,09,27,93,93,76,
   69,84,00,77,85,84,00,84,29,81,14,73,84,69,82,08,09,27,07,79,26,70,79,82,00,89,00,73,78,00,17,14,14,82,10,18,00,91,00,76,69,84,
   00,76,26,00,54,69,67,32,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,28,73,19,18,30,00,29,00,66,14,73,84,69,82,08,
   09,14,70,73,76,84,69,82,08,92,88,92,00,88,14,17,29,29,89,09,14,77,65,80,08,92,88,92,00,88,14,16,09,14,67,79,76,76,69,67,84,08,
   09,27,00,76,69,84,00,88,00,29,00,76,14,73,84,69,82,08,09,14,67,76,79,78,69,68,08,09,14,70,79,76,68,08,16,12,32,00,00,00,00,00,
   00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,73,19,18,26,26,77,65,88,09,27,00,76,69,84,00,78,00,29,76,14,73,84,69,82,08,09,
   14,67,76,79,78,69,68,08,09,14,70,79,76,68,08,25,25,25,12,00,73,19,18,26,26,77,73,78,09,27,76,69,84,00,77,29,88,13,78,27,00,70,
   79,82,00,63,00,73,78,00,16,14,14,78,00,91,00,80,82,73,78,84,01,32,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
   00,00,00,00,08,02,00,00,00,02,09,27,93,70,79,82,00,63,00,73,78,00,16,14,14,77,91,00,73,70,00,76,69,84,00,51,79,77,69,08,86,09,
   00,29,00,84,14,78,69,88,84,08,09,00,91,80,82,73,78,84,01,08,02,91,26,16,18,93,12,02,12,86,09,27,93,00,69,76,83,69,91,00,66,82,
   69,65,75,32,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,07,79,27,00,93,93,00,80,82,73,
   78,84,01,08,02,60,78,02,09,27,00,93,00,70,79,82,00,78,00,73,78,00,81,14,73,84,69,82,08,09,00,91,00,80,82,73,78,84,01,08,02,91,
      93,02,12,00,08,73,70,00,10,78,29,29,19,18,91,17,16,93,00,69,76,83,69,32,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,
      00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,91,10,78,11,19,18,93,09,00,65,83,00,67,72,65,82,09,27,93,80,82,73,
      78,84,01,08,02,60,78,02,09,27,93,00,15,15,00,71,73,84,72,85,66,14,67,79,77,15,75,73,82,74,65,86,65,83,67,82,73,80,84,
       ];println!("{}fn main(){{let q:&[u8]=&[", String::from_utf8(vec![b' '; 54]).unwrap());let r=(q.len()as f64/std::f64
        ¬†::consts::PI).sqrt()as i32+4;let mut b: Vec<(i32, i32) >= Vec::new(); /*   ooer  */ let mut x=r-1; let mut y=0;
          let mut k=1;let mut j=1;let mut e=k -(r<<1);while x>=y{b.push((r+x,r+y));b.push((r+y,r+x)); b.push((r-y,r+x)
             );b.push((r-x, r+y));b.push((r-x,r-y));b.push((r-y,r-x)); b.push((r+y,r-x));b.push((r+x,r-y)); if e<=0{
                y+=1;e+=j;j+=2;}if e>0 {x-=1;k+=2;e+=k-(r<<1);}}let mut t=q.iter();'o:for y in 1..r*2 { let l: Vec
                   <i32> = b.iter().filter(|x| x.1==y).map(|x| x.0).collect(); let x = l.iter().cloned().fold(0,
                     i32::max); let n =l.iter().cloned().fold(999, i32::min);let m=x-n; for _ in 0..n { print!
                        ("   ");}for _ in 0..m{ if let Some(v) = t.next() {print!("{:02},",v);} else{ break
                            'o; }} print!("\n"); } for n in q.iter() { print!("{}", (if *n==32{10} else
                                  {*n+32}) as char);}print!("\n");} // github.com/kirjavascript
¬†
```

# Generic swap<a id="sec-25"></a>

Task

Write a generic swap function or operator which exchanges the values of two variables (or, more generally, any two storage places that can be assigned), regardless of their types.

If your solution language is statically typed please describe the way your language provides genericity.

If variables are typed in the given language, it is permissible that the two variables be constrained to having a mutually compatible type, such that each is permitted to hold the value previously stored in the other without a type violation. That is to say, solutions do not have to be capable of exchanging, say, a string and integer value, if the underlying storage locations are not attributed with types that permit such an exchange.

Generic swap is a task which brings together a few separate issues in programming language semantics.

Dynamically typed languages deal with values in a generic way quite readily, but do not necessarily make it easy to write a function to destructively swap two variables, because this requires indirection upon storage places or upon the syntax designating storage places.

Functional languages, whether static or dynamic, do not necessarily allow a destructive operation such as swapping two variables regardless of their generic capabilities.

Some static languages have difficulties with generic programming due to a lack of support for (Parametric Polymorphism).

Do your best!

```rust
fn main() {
    let mut a="Anna".to_owned();
    let mut b="Bob".to_owned();
    std::mem::swap(&mut a, &mut b);
    println!("a={},b={}",a,b);
}
```

# Loop over multiple arrays simultaneously<a id="sec-26"></a>

Task

Loop over multiple arrays ¬† (or lists or tuples or whatever they're called in your language) ¬† and display the ¬† i th ¬† element of each.

Use your language's ¬† "for each" ¬† loop if it has one, otherwise iterate through the collection in order with some other loop.

For this example, loop over the arrays:

```
(a,b,c)
(A,B,C) 
(1,2,3) 

```

to produce the output:

```
aA1
bB2
cC3

```

If possible, also describe what happens when the arrays are of different lengths.

Related tasks

¬† Loop over multiple arrays simultaneously ¬† Loops/Break ¬† Loops/Continue ¬† Loops/Do-while ¬† Loops/Downward for ¬† Loops/For ¬† Loops/For with a specified step ¬† Loops/Foreach ¬† Loops/Increment loop index within loop body ¬† Loops/Infinite ¬† Loops/N plus one half ¬† Loops/Nested ¬† Loops/While ¬† Loops/with multiple ranges ¬† Loops/Wrong ranges

```rust
fn main() {
    let a1 = ["a", "b", "c"];
    let a2 = ["A", "B", "C"];
    let a3 = [1, 2, 3];
¬†
    for ((&x, &y), &z) in a1.iter().zip(a2.iter()).zip(a3.iter()) {
        println!("{}{}{}", x, y, z);
    }
}
```

Output:

```rust
aA1
bB2
cC3
```

# Repeat a string<a id="sec-27"></a>

Take a string and repeat it some number of times.

Example: repeat("ha", 5) ¬† => ¬† "hahahahaha"

If there is a simpler/more efficient way to repeat a single ‚Äúcharacter‚Äù (i.e. creating a string filled with a certain character), you might want to show that as well (i.e. repeat-char("**", 5) => "**\*\*****").

```rust
std::iter::repeat("ha").take(5).collect::<String>(); // ==> "hahahahaha"
```

Since 1.16:

```rust
"ha".repeat(5); // ==> "hahahahaha"
```

# 99 Bottles of Beer<a id="sec-28"></a>

Task

Display the complete lyrics for the song: ¬† ¬† 99 Bottles of Beer on the Wall.

The beer song

The lyrics follow this form:

99 bottles of beer on the wall 99 bottles of beer Take one down, pass it around 98 bottles of beer on the wall

98 bottles of beer on the wall 98 bottles of beer Take one down, pass it around 97 bottles of beer on the wall

&#x2026; and so on, until reaching 0.

Grammatical support for "1 bottle of beer" is optional.

As with any puzzle, try to do it in as creative/concise/comical a way as possible (simple, obvious solutions allowed, too).

Related tasks

¬† The Twelve Days of Christmas ¬† Old<sub>lady</sub><sub>swallowed</sub><sub>a</sub><sub>fly</sub> ¬† Mad Libs

See also

¬† <http://99-bottles-of-beer.net/> ¬† Category:99<sub>Bottles</sub><sub>of</sub><sub>Beer</sub> ¬† Category:Programming language families ¬† Wikipedia 99 bottles of beer

# Associative array/Creation<a id="sec-29"></a>

Task

The goal is to create an associative array (also known as a dictionary, map, or hash).

Related tasks:

Associative arrays/Iteration Hash from two arrays

See also

Array Associative array: Creation, Iteration Collections Compound data type Doubly-linked list: Definition, Element definition, Element insertion, Traversal Linked list Queue: Definition, Usage Set Singly-linked list: Element definition, Element insertion, Traversal Stack

```rust
use std::collections::HashMap;
fn main() {
    let mut olympic_medals = HashMap::new();
    olympic_medals.insert("United States", (1072, 859, 749));
    olympic_medals.insert("Soviet Union", (473, 376, 355));
    olympic_medals.insert("Great Britain", (246, 276, 284));
    olympic_medals.insert("Germany", (252, 260, 270));
    println!("{:?}", olympic_medals);
}
```

# Averages/Arithmetic mean<a id="sec-30"></a>

Task[edit]

Write a program to find the mean (arithmetic average) of a numeric vector.

In case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.

See also

Tasks for calculating statistical measures

in one go moving (sliding window) moving (cumulative) Mean Arithmetic Statistics/Basic Averages/Arithmetic mean Averages/Pythagorean means

Averages/Simple moving average

Geometric Averages/Pythagorean means

Harmonic Averages/Pythagorean means

Quadratic Averages/Root mean square

Circular Averages/Mean angle Averages/Mean time of day

Median Averages/Median

Mode Averages/Mode

Standard deviation Statistics/Basic

Cumulative standard deviation

```rust
fn sum(arr: &[f64]) -> f64 {
    arr.iter().fold(0.0, |p,&q| p + q)
}
¬†
fn mean(arr: &[f64]) -> f64 {
    sum(arr) / arr.len() as f64
}
¬†
fn main() {
    let v = &[2.0, 3.0, 5.0, 7.0, 13.0, 21.0, 33.0, 54.0];
    println!("mean of {:?}: {:?}", v, mean(v));
¬†
    let w = &[];
    println!("mean of {:?}: {:?}", w, mean(w));
}
```

Output:

```rust
mean of [2, 3, 5, 7, 13, 21, 33, 54]: 17.25
mean of []: NaN
```

# Apply a callback to an array<a id="sec-31"></a>

Task

Take a combined set of elements and apply a function to each element.

```rust
fn echo(n: &i32) {
    println!("{}", n);
}
¬†
fn main() {
    let a: [i32; 5];
    a = [1, 2, 3, 4, 5];
    let _: Vec<_> = a.into_iter().map(echo).collect();
}
```

# Loops/Foreach<a id="sec-32"></a>

Loop through and print each element in a collection in order.

Use your language's "for each" loop if it has one, otherwise iterate through the collection in order with some other loop.

Related tasks

¬† Loop over multiple arrays simultaneously ¬† Loops/Break ¬† Loops/Continue ¬† Loops/Do-while ¬† Loops/Downward for ¬† Loops/For ¬† Loops/For with a specified step ¬† Loops/Foreach ¬† Loops/Increment loop index within loop body ¬† Loops/Infinite ¬† Loops/N plus one half ¬† Loops/Nested ¬† Loops/While ¬† Loops/with multiple ranges ¬† Loops/Wrong ranges

Rust's for-loop already is a foreach-loop.

```rust
let collection = vec![1,2,3,4,5];
for elem in collection {
    println!("{}", elem);
}
```

Do note that Rust moves values by default and doesn't copy them. A vector would be unusable after looping over it like above. To preserve it, borrow it or use an Iter, to mutate values do a mutable borrow or create an IterMut. To get an immutable reference omit the mut-part.

```rust
let mut collection = vec![1,2,3,4,5];
for mut_ref in &mut collection {
// alternatively:
// for mut_ref in collection.iter_mut() {
    *mut_ref *= 2;
    println!("{}", *mut_ref);
}
¬†
// immutable borrow
for immut_ref in &collection {
// alternatively:
// for immut_ref in collection.iter() {
    println!("{}", *immut_ref);
}
```

# Remove duplicate elements<a id="sec-33"></a>

There are basically three approaches seen here:

Put the elements into a hash table which does not allow duplicates. The complexity is O(n) on average, and O(n2) worst case. This approach requires a hash function for your type (which is compatible with equality), either built-in to your language, or provided by the user. Sort the elements and remove consecutive duplicate elements. The complexity of the best sorting algorithms is O(n log n). This approach requires that your type be "comparable", i.e., have an ordering. Putting the elements into a self-balancing binary search tree is a special case of sorting. Go through the list, and for each element, check the rest of the list to see if it appears again, and discard it if it does. The complexity is O(n2). The up-shot is that this always works on any type (provided that you can test for equality).

```rust
use std::collections::HashSet;
use std::hash::Hash;
¬†
fn remove_duplicate_elements_hashing<T: Hash + Eq>(elements: &mut Vec<T>) {
    let set: HashSet<_> = elements.drain(..).collect();
    elements.extend(set.into_iter());
}
¬†
fn remove_duplicate_elements_sorting<T: Ord>(elements: &mut Vec<T>) {
    elements.sort_unstable(); // order does not matter
    elements.dedup();
}
¬†
fn main() {
    let mut sample_elements = vec![0, 0, 1, 1, 2, 3, 2];
    println!("Before removal of duplicates¬†: {:?}", sample_elements);
    remove_duplicate_elements_sorting(&mut sample_elements);
    println!("After removal of duplicates¬†: {:?}", sample_elements);
}
```

Output:

```rust
Before removal of duplicates¬†: [0, 0, 1, 1, 2, 3, 2]
After removal of duplicates¬†: [1, 0, 3, 2]

```

# Hello world/Graphical<a id="sec-34"></a>

Task

Display the string ¬† ¬† ¬† Goodbye, World! ¬† ¬† ¬† on a GUI object ¬† (alert box, plain window, text area, etc.).

Related task

¬† Hello world/Text

Library: GTK [edit]

```rust
// cargo-deps:  gtk
extern crate gtk;
use gtk::traits::*;
use gtk::{Window, WindowType, WindowPosition};
use gtk::signal::Inhibit;
¬†
fn main() {
    gtk::init().unwrap();
    let window = Window::new(WindowType::Toplevel).unwrap();
¬†
    window.set_title("Goodbye, World!");
    window.set_border_width(10);
    window.set_window_position(WindowPosition::Center);
    window.set_default_size(350, 70);
    window.connect_delete_event(|_,_| {
        gtk::main_quit();
        Inhibit(false)
    });
¬†
    window.show_all();
    gtk::main();
}
```

# Binary search<a id="sec-35"></a>

A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a "divide and conquer" algorithm.

As an analogy, consider the children's game "guess a number." The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.

As the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.

Task

Given the starting point of a range, the ending point of a range, and the "secret value", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.

There are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.

All of the following code examples use an "inclusive" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using "exclusive" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):

change high = N-1 to high = N change high = mid-1 to high = mid (for recursive algorithm) change if (high < low) to if (high <= low) (for iterative algorithm) change while (low <= high) to while (low < high)

Traditional algorithm

The algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the "insertion point" for it (the index that the value would have if it were inserted into the array).

Recursive Pseudocode:

```
// initially called with low = 0, high = N-1
BinarySearch(A[0..N-1], value, low, high) {
    // invariants: value > A[i] for all i < low
                   value < A[i] for all i > high
    if (high < low)
        return not_found // value would be inserted at index "low"
    mid = (low + high) / 2
    if (A[mid] > value)
        return BinarySearch(A, value, low, mid-1)
    else if (A[mid] < value)
        return BinarySearch(A, value, mid+1, high)
    else
        return mid
}

```

Iterative Pseudocode:

```
BinarySearch(A[0..N-1], value) {
    low = 0
    high = N - 1
    while (low <= high) {
        // invariants: value > A[i] for all i < low
                       value < A[i] for all i > high
        mid = (low + high) / 2
        if (A[mid] > value)
            high = mid - 1
        else if (A[mid] < value)
            low = mid + 1
        else
            return mid
    }
    return not_found // value would be inserted at index "low"
}

```

Leftmost insertion point

The following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.

Recursive Pseudocode:

```
// initially called with low = 0, high = N - 1
BinarySearch_Left(A[0..N-1], value, low, high) {
    // invariants: value > A[i] for all i < low
                   value <= A[i] for all i > high
    if (high < low)
        return low
    mid = (low + high) / 2
    if (A[mid] >= value)
        return BinarySearch_Left(A, value, low, mid-1)
    else
        return BinarySearch_Left(A, value, mid+1, high)
}

```

Iterative Pseudocode:

```
BinarySearch_Left(A[0..N-1], value) {
    low = 0
    high = N - 1
    while (low <= high) {
        // invariants: value > A[i] for all i < low
                       value <= A[i] for all i > high
        mid = (low + high) / 2
        if (A[mid] >= value)
            high = mid - 1
        else
            low = mid + 1
    }
    return low
}

```

Rightmost insertion point

The following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.

Recursive Pseudocode:

```
// initially called with low = 0, high = N - 1
BinarySearch_Right(A[0..N-1], value, low, high) {
    // invariants: value >= A[i] for all i < low
                   value < A[i] for all i > high
    if (high < low)
        return low
    mid = (low + high) / 2
    if (A[mid] > value)
        return BinarySearch_Right(A, value, low, mid-1)
    else
        return BinarySearch_Right(A, value, mid+1, high)
}

```

Iterative Pseudocode:

```
BinarySearch_Right(A[0..N-1], value) {
    low = 0
    high = N - 1
    while (low <= high) {
        // invariants: value >= A[i] for all i < low
                       value < A[i] for all i > high
        mid = (low + high) / 2
        if (A[mid] > value)
            high = mid - 1
        else
            low = mid + 1
    }
    return low
}

```

Extra credit

Make sure it does not have overflow bugs.

The line in the pseudo-code above to calculate the mean of two integers:

```
mid = (low + high) / 2
```

could produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.

One way to fix it is to manually add half the range to the low number:

```
mid = low + (high - low) / 2
```

Even though this is mathematically equivalent to the above, it is not susceptible to overflow.

Another way for signed integers, possibly faster, is the following:

```
mid = (low + high) >>> 1
```

where >>> is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.

Related task Guess the number/With Feedback (Player)

See also wp:Binary search algorithm Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken.

Standard Library

```rust
let arr = ["a", "bc", "def", "ghij"];
arr.binary_search(&"a"); // Search lexicographically
arr.binary_search_by(|e| e.len().cmp(&1)); // Search by length
```

Iterative

```rust
use std::cmp::Ordering::*;
fn binary_search<T: Ord>(arr: &[T], elem: &T) -> Option<usize>
{
    let mut size = arr.len();
    let mut base = 0;
¬†
    while size > 0 {
        size /= 2;
        let mid = base + size;
        base = match arr[mid].cmp(elem) {
            Less    => mid,
            Greater => base,
            Equal   => return Some(mid)
        };
    }
¬†
    None
}
¬†
```

# ABC Problem<a id="sec-36"></a>

You are given a collection of ABC blocks ¬† (maybe like the ones you had when you were a kid).

There are twenty blocks with two letters on each block.

A complete alphabet is guaranteed amongst all sides of the blocks.

The sample collection of blocks:

```
(B O)
(X K)
(D Q)
(C P)
(N A)
(G T)
(R E)
(T G)
(Q D)
(F S)
(J W)
(H U)
(V I)
(A N)
(O B)
(E R)
(F S)
(L Y)
(P C)
(Z M)

```

Task

Write a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.

The rules are simple:

¬† Once a letter on a block is used that block cannot be used again ¬† The function should be case-insensitive ¬† Show the output on this page for the following 7 words in the following example

Example

```
>>> can_make_word("A")
True
>>> can_make_word("BARK")
True
>>> can_make_word("BOOK")
False
>>> can_make_word("TREAT")
True
>>> can_make_word("COMMON")
False
>>> can_make_word("SQUAD")
True
>>> can_make_word("CONFUSE")
True
```

This implementation uses a backtracking search.

```rust
use std::iter::repeat;
¬†
fn rec_can_make_word(index: usize, word: &str, blocks: &[&str], used: &mut[bool]) -> bool {
    let c = word.chars().nth(index).unwrap().to_uppercase().next().unwrap();
    for i in 0..blocks.len() {
        if¬†!used[i] && blocks[i].chars().any(|s| s == c) {
            used[i] = true;
            if index == 0 || rec_can_make_word(index - 1, word, blocks, used) {
                return true;
            }
            used[i] = false;
        }
    }
    false
}
¬†
fn can_make_word(word: &str, blocks: &[&str]) -> bool {
    return rec_can_make_word(word.chars().count() - 1, word, blocks, 
                             &mut repeat(false).take(blocks.len()).collect::<Vec<_>>());
}
¬†
fn main() {
    let blocks = [("BO"), ("XK"), ("DQ"), ("CP"), ("NA"), ("GT"), ("RE"), ("TG"), ("QD"), ("FS"), 
                  ("JW"), ("HU"), ("VI"), ("AN"), ("OB"), ("ER"), ("FS"), ("LY"), ("PC"), ("ZM")];
    let words = ["A", "BARK", "BOOK", "TREAT", "COMMON", "SQUAD", "CONFUSE"];
    for word in &words {
        println!("{} -> {}", word, can_make_word(word, &blocks))
    }
}
¬†
```

Output:

```rust
A -> true
BARK -> true
BOOK -> false
TREAT -> true
COMMON -> false
SQUAD -> true
CONFUSE -> true

```

# Loops/For<a id="sec-37"></a>

‚ÄúFor‚Äù ¬† loops are used to make some block of code be iterated a number of times, setting a variable or parameter to a monotonically increasing integer value for each execution of the block of code.

Common extensions of this allow other counting patterns or iterating over abstract structures other than the integers.

Task

Show how two loops may be nested within each other, with the number of iterations performed by the inner for loop being controlled by the outer for loop.

Specifically print out the following pattern by using one for loop nested in another:

```
*
**
***
****
*****
```

Related tasks

¬† Loop over multiple arrays simultaneously ¬† Loops/Break ¬† Loops/Continue ¬† Loops/Do-while ¬† Loops/Downward for ¬† Loops/For ¬† Loops/For with a specified step ¬† Loops/Foreach ¬† Loops/Increment loop index within loop body ¬† Loops/Infinite ¬† Loops/N plus one half ¬† Loops/Nested ¬† Loops/While ¬† Loops/with multiple ranges ¬† Loops/Wrong ranges

Reference

For loop Wikipedia.

The compiler warns when you create an unused variable; here we use \_ to avoid this effect.

```rust
fn main() {
    for i in 0..5 {
        for _ in 0..(i + 1) {
            print!("*");
        }
¬†
        println!();
    }
}
```

# N-queens problem<a id="sec-38"></a>

Solve the eight queens puzzle.

You can extend the problem to solve the puzzle with a board of size ¬† NxN.

For the number of solutions for small values of ¬† N, ¬† see ¬† oeis.org sequence A170.

Related tasks

A\* search algorithm Solve a Hidato puzzle Solve a Holy Knight's tour Knight's tour Solve a Hopido puzzle Solve a Numbrix puzzle Solve the no connection puzzle

```rust
const N: usize = 8;
¬†
fn try(mut board: &mut [[bool; N]; N], row: usize, mut count: &mut i64) {
   if row == N {
       *count += 1;
       for r in board.iter() {
           println!("{}", r.iter().map(|&x| if x {"x"} else {"."}.to_string()).collect::<Vec<String>>().join(" "))
       }
       println!("");
       return
   }
   for i in 0..N {
       let mut ok: bool = true;
       for j in 0..row {
           if board[j][i]
               || i+j >= row && board[j][i+j-row]
               || i+row < N+j && board[j][i+row-j]
           { ok = false }
       }
       if ok {
           board[row][i] = true;
           try(&mut board, row+1, &mut count);
           board[row][i] = false;
       }
   }
}
¬†
fn main() {
   let mut board: [[bool; N]; N] = [[false; N]; N];
   let mut count: i64 = 0;
   try (&mut board, 0, &mut count);
   println!("Found {} solutions", count)
}
```

Using Iterators[edit]

Solution to the puzzle using an iterator that yields the 92 solutions for 8 queens.

```rust
use std::collections::LinkedList;
use std::iter::IntoIterator;
¬†
fn main() {
    for (n, s) in NQueens::new(8).enumerate() {
        println!("Solution #{}:\n{}\n", n + 1, s.to_string());
    }
}
¬†
fn permutations<'a, T, I>(collection: I) -> Box<Iterator<Item=LinkedList<T>> + 'a>
    where I: 'a + IntoIterator<Item=T> + Clone,
          T: 'a + PartialEq + Copy + Clone {
    if collection.clone().into_iter().count() == 0 {
        Box::new(vec![LinkedList::new()].into_iter())
    }
    else { 
        Box::new(
            collection.clone().into_iter().flat_map(move |i| {
                permutations(collection.clone().into_iter()
                    .filter(move |&i0| i¬†!= i0)
                    .collect::<Vec<_>>())
                    .map(move |mut l| {l.push_front(i); l})
            })
        )
    }
}
¬†
pub struct NQueens {
    iterator: Box<Iterator<Item=NQueensSolution>>
}
¬†
impl NQueens {
    pub fn new(n: u32) -> NQueens {
        NQueens {
            iterator: Box::new(permutations(0..n)
                .filter(|vec| {
                    let iter = vec.iter().enumerate();
                    iter.clone().all(|(col, &row)| {
                        iter.clone().filter(|&(c,_)| c¬†!= col)
                            .all(|(ocol, &orow)| {
                            col as i32 - row as i32¬†!= 
                                ocol as i32 - orow as i32 &&
                            col as u32 + row¬†!= ocol as u32 + orow 
                        })
                    })
                })
                .map(|vec| NQueensSolution(vec))
            )
        }
    }
}
¬†
impl Iterator for NQueens {
    type Item = NQueensSolution;
    fn next(&mut self) -> Option<NQueensSolution> {
        self.iterator.next()
    }
}
¬†
pub struct NQueensSolution(LinkedList<u32>);
¬†
impl ToString for NQueensSolution {
    fn to_string(&self) -> String {
        let mut str = String::new();
        for &row in self.0.iter() {
            for r in 0..self.0.len() as u32 {
                if r == row {
                    str.push_str("Q ");
                } else {
                    str.push_str("- ");
                }
            }
            str.push('\n');
        }
        str
    }
}
```

# Happy numbers<a id="sec-39"></a>

From Wikipedia, the free encyclopedia:

A happy number is defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals ¬† 1 ¬† (where it will stay), ¬† or it loops endlessly in a cycle which does not include ¬† 1. ¬† Those numbers for which this process ends in ¬† 1 ¬† are happy numbers, ¬† while those that do not end in ¬† 1 ¬† are unhappy numbers.

Display an example of your output here.

task

Find and print the first 8 happy numbers.

See also

The ¬† ¬† happy numbers on OEIS: ¬† A007770 The unhappy numbers on OEIS; ¬† A031177

In Rust, using a tortoise/hare cycle detection algorithm (generic for integer types)

```rust
#![feature(core)]
¬†
fn sumsqd(mut n: i32) -> i32 {
    let mut sq = 0;
    while n > 0 {
        let d = n¬†% 10;
        sq += d*d;
        n /= 10
    }
    sq
}
¬†
use std::num::Int;
fn cycle<T: Int>(a: T, f: fn(T) -> T) -> T {
    let mut t = a;
    let mut h = f(a);
¬†
    while t¬†!= h {
        t = f(t);
        h = f(f(h))
    }
    t
}
¬†
fn ishappy(n: i32) -> bool {
    cycle(n, sumsqd) == 1
}
¬†
fn main() {
    let happy = std::iter::count(1, 1)
                    .filter(|&n| ishappy(n))
                    .take(8)
                    .collect::<Vec<i32>>();
¬†
    println!("{:?}", happy)
}
```

Output:

```rust
[1, 7, 10, 13, 19, 23, 28, 31]

```

# Pascal's triangle<a id="sec-40"></a>

Pascal's triangle is an arithmetic and geometric figure often associated with the name of Blaise Pascal, but also studied centuries earlier in India, Persia, China and elsewhere.

Its first few rows look like this:

```
   1
  1 1
 1 2 1
1 3 3 1

```

where each element of each row is either 1 or the sum of the two elements right above it.

For example, the next row of the triangle would be:

¬† 1 ¬† (since the first element of each row doesn't have two elements above it) ¬† 4 ¬† (1 + 3) ¬† 6 ¬† (3 + 3) ¬† 4 ¬† (3 + 1) ¬† 1 ¬† (since the last element of each row doesn't have two elements above it)

So the triangle now looks like this:

```
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1

```

Each row ¬† n ¬† (starting with row ¬† 0 ¬† at the top) shows the coefficients of the binomial expansion of ¬† (x + y)n.

Task

Write a function that prints out the first ¬† n ¬† rows of the triangle ¬† (with ¬† f(1) ¬† yielding the row consisting of only the element 1).

This can be done either by summing elements from the previous rows or using a binary coefficient or combination function.

Behavior for ¬† n ‚â§ 0 ¬† does not need to be uniform, but should be noted.

See also

Evaluate binomial coefficients

Translation of: C

```rust
¬†
fn pascal_triangle(n: u64)
{
¬†
  for i in 0..n {
    let mut c = 1;
    for _j in 1..2*(n-1-i)+1 {
      print!(" ");
    }
    for k in 0..i+1 {
      print!("{:2} ", c);
      c = c * (i-k)/(k+1);
    }
    println!();
  }
}
¬†
```

# Arithmetic/Integer<a id="sec-41"></a>

Task

Get two integers from the user, ¬† and then (for those two integers), display their:

¬† sum ¬† difference ¬† product ¬† integer quotient ¬† remainder ¬† exponentiation ¬† (if the operator exists)

Don't include error handling.

For quotient, indicate how it rounds ¬† (e.g. towards zero, towards negative infinity, etc.).

For remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.

Note that this code cannot be run within the Rust playpen as it does not support console input.

```rust
use std::env;
¬†
fn main() {
    let args: Vec<_> = env::args().collect();
    let a = args[1].parse::<i32>().unwrap();
    let b = args[2].parse::<i32>().unwrap();
¬†
    println!("sum:              {}", a + b);
    println!("difference:       {}", a - b);
    println!("product:          {}", a * b);
    println!("integer quotient: {}", a / b); // truncates towards zero
    println!("remainder:        {}", a¬†% b); // same sign as first operand
}
```

# Day of the week<a id="sec-42"></a>

A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).

Task

In what years between 2008 and 2121 will the 25th of December be a Sunday?

Using any standard date handling libraries of your programming language; compare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to ¬† y2k ¬† type problems.

```rust
extern crate chrono;
¬†
use chrono::prelude::*;
¬†
fn main() {
    let years = (2008..2121).filter(|&y| Local.ymd(y, 12, 25).weekday() == Weekday::Sun).collect::<Vec<i32>>();
    println!("Years = {:?}", years);
}
```

Output:

```rust
Years = [2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118]

```

# Filter<a id="sec-43"></a>

Task

Select certain elements from an Array into a new Array in a generic way.

To demonstrate, select all even numbers from an Array.

As an option, give a second solution which filters destructively, by modifying the original Array rather than creating a new Array.

```rust
fn main() {
    println!("new vec filtered: ");
    let nums: Vec<i32> = (1..20).collect();
    let evens: Vec<i32> = nums.iter().cloned().filter(|x| x¬†% 2 == 0).collect();
    println!("{:?}", evens);
¬†
    // Filter an already existing vector
    println!("original vec filtered: ");
    let mut nums: Vec<i32> = (1..20).collect();
    nums.retain(|x| x¬†% 2 == 0);
    println!("{:?}", nums);
}
```

Output:

```rust
new vec filtered:
[2, 4, 6, 8, 10, 12, 14, 16, 18]
original vec filtered:
[2, 4, 6, 8, 10, 12, 14, 16, 18]
```

# Array concatenation<a id="sec-44"></a>

Task

Show how to concatenate two arrays in your language.

If this is as simple as array1 + array2, so be it.

```rust
fn main() {
    let a_vec = vec![1, 2, 3, 4, 5];
    let b_vec = vec![6; 5];
¬†
    let c_vec = concatenate_arrays(&a_vec, &b_vec);
¬†
    println!("{:?} ~ {:?} => {:?}", a_vec, b_vec, c_vec);
}
¬†
fn concatenate_arrays<T: Clone>(x: &[T], y: &[T]) -> Vec<T> {
    let mut concat = x.to_vec();
    concat.extend_from_slice(y);
¬†
    concat
}
¬†
```

Or, with iterators:

```rust
fn concatenate_arrays<T: Clone>(x: &[T], y: &[T]) -> Vec<T> {
    x.iter().chain(y).cloned().collect()
}
¬†
```

# Even or odd<a id="sec-45"></a>

Task

Test whether an integer is even or odd.

There is more than one way to solve this task:

Use the even and odd predicates, if the language provides them. Check the least significant digit. With binary integers, i bitwise-and 1 equals 0 iff i is even, or equals 1 iff i is odd. Divide i by 2. The remainder equals 0 iff i is even. The remainder equals +1 or -1 iff i is odd. Use modular congruences: i ‚â° 0 (mod 2) iff i is even. i ‚â° 1 (mod 2) iff i is odd.

Checking the last significant digit:

```rust
let is_odd = |x: i32| x & 1 == 1;
let is_even = |x: i32| x & 1 == 0;
```

Using modular congruences:

```rust
let is_odd = |x: i32| x¬†% 2¬†!= 0;
let is_even = |x: i32| x¬†% 2 == 0;
```

# Binary digits<a id="sec-46"></a>

Task

Create and display the sequence of binary digits for a given ¬† non-negative integer.

```
The decimal value ¬†    5 ¬† should produce an output of ¬†             101
The decimal value ¬†   50 ¬† should produce an output of ¬†          110010
The decimal value ¬† 9000 ¬† should produce an output of ¬†  10001100101000

```

The results can be achieved using built-in radix functions within the language ¬† (if these are available), ¬† or alternatively a user defined function can be used.

The output produced should consist just of the binary digits of each number followed by a ¬† newline.

There should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.

```rust
fn main() {
    for i in 0..8 {
        println!("{:b}", i)
    }
}
```

Outputs:

```rust
0
1
10
11
100
101
110
111
```

# Roman numerals/Encode<a id="sec-47"></a>

Task

Create a function taking a positive integer as its parameter and returning a string containing the Roman numeral representation of that integer. Modern Roman numerals are written by expressing each digit separately, starting with the left most digit and skipping any digit with a value of zero.

In Roman numerals:

1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC 2008 is written as 2000=MM, 8=VIII; or MMVIII 1666 uses each Roman symbol in descending order: MDCLXVI

```rust
struct RomanNumeral {
    symbol: &'static str,
    value: u32
}
¬†
const NUMERALS: [RomanNumeral; 13] = [
    RomanNumeral {symbol: "M",  value: 1000},
    RomanNumeral {symbol: "CM", value: 900},
    RomanNumeral {symbol: "D",  value: 500},
    RomanNumeral {symbol: "CD", value: 400},
    RomanNumeral {symbol: "C",  value: 100},
    RomanNumeral {symbol: "XC", value: 90},
    RomanNumeral {symbol: "L",  value: 50},
    RomanNumeral {symbol: "XL", value: 40},
    RomanNumeral {symbol: "X",  value: 10},
    RomanNumeral {symbol: "IX", value: 9},
    RomanNumeral {symbol: "V",  value: 5},
    RomanNumeral {symbol: "IV", value: 4},
    RomanNumeral {symbol: "I",  value: 1}
];
¬†
fn to_roman(mut number: u32) -> String {
    let mut min_numeral = String::new();
    for numeral in NUMERALS.iter() {
        while numeral.value <= number {
            min_numeral = min_numeral + numeral.symbol;
            number -= numeral.value;
        }
    }
    min_numeral
}
¬†
fn main() {
    let nums = [2014, 1999, 25, 1666, 3888];
    for &n in nums.iter() {
        // 4 is minimum printing width, for alignment
        println!("{:2$} = {}", n, to_roman(n), 4);
    }
}
```

Output:

```rust
2014 = MMXIV
1999 = MCMXCIX
  25 = XXV
1666 = MDCLXVI
3888 = MMMDCCCLXXXVIII

```

# Loops/While<a id="sec-48"></a>

Task

Start an integer value at ¬† 1024.

Loop while it is greater than zero.

Print the value (with a newline) and divide it by two each time through the loop.

Related tasks

¬† Loop over multiple arrays simultaneously ¬† Loops/Break ¬† Loops/Continue ¬† Loops/Do-while ¬† Loops/Downward for ¬† Loops/For ¬† Loops/For with a specified step ¬† Loops/Foreach ¬† Loops/Increment loop index within loop body ¬† Loops/Infinite ¬† Loops/N plus one half ¬† Loops/Nested ¬† Loops/While ¬† Loops/with multiple ranges ¬† Loops/Wrong ranges

```rust
fn main() {
    let mut n: i32 = 1024;
    while n > 0 {
        println!("{}", n);
        n /= 2;
    }
}
```

# Loops/For with a specified step<a id="sec-49"></a>

Demonstrate a for-loop where the step-value is greater than one.

Related tasks

¬† Loop over multiple arrays simultaneously ¬† Loops/Break ¬† Loops/Continue ¬† Loops/Do-while ¬† Loops/Downward for ¬† Loops/For ¬† Loops/For with a specified step ¬† Loops/Foreach ¬† Loops/Increment loop index within loop body ¬† Loops/Infinite ¬† Loops/N plus one half ¬† Loops/Nested ¬† Loops/While ¬† Loops/with multiple ranges ¬† Loops/Wrong ranges

```rust
fn main() {
    let mut i = 2;
    while i <= 8 {
        print!("{}, ", i);
        i += 2;
    }
    println!("who do we appreciate?!");
}
```

Prettier, but currently feature gated version (Rust 1.0)

Does not work in stable Rust

```rust
#![feature(step_by)]
¬†
fn main() {
  for i in (2..8+1).step_by(2) {
    print!("{}", i);
  }
  println!("who do we appreciate?!");
}
```

Additionally, there is a crate on crates.io called cfor which allows for the use of a C-like for loop.

```rust
 #[macro_use]
extern crate cfor;
¬†
fn main() {
    cfor!(let mut i = 2; i <= 8; i+=2; {
        println!("{}", i);
    });
    println!("Who do we appreciate?");
}
```

# Tokenize a string<a id="sec-50"></a>

Separate the string "Hello,How,Are,You,Today" by commas into an array (or list) so that each element of it stores a different word. Display the words to the 'user', in the simplest manner possible, separated by a period. To simplify, you may display a trailing period.

Related tasks:

Tokenize a string with escaping

```rust
fn main() {
    let s = "Hello,How,Are,You,Today";
    let tokens: Vec<&str> = s.split(",").collect();
    println!("{}", tokens.join("."));
}
```

# Factors of an integer<a id="sec-51"></a>

Task

Compute the ¬† factors ¬† of a positive integer.

These factors are the positive integers by which the number being factored can be divided to yield a positive integer result.

(Though the concepts function correctly for zero and negative integers, the set of factors of zero has countably infinite members, and the factors of negative integers can be obtained from the factors of related positive numbers without difficulty; ¬† this task does not require handling of either of these cases).

Note that every prime number has two factors: ¬† 1 ¬† and itself.

Related tasks

¬† count in factors ¬† prime decomposition ¬† Sieve of Eratosthenes ¬† primality by trial division ¬† factors of a Mersenne number ¬† trial factoring of a Mersenne number ¬† partition an integer X into N primes ¬† sequence of primes by Trial Division

```rust
fn main() {
    assert_eq!(vec![1, 2, 4, 5, 10, 10, 20, 25, 50, 100], factor(100)); // asserts that two expressions are equal to each other
    assert_eq!(vec![1, 101], factor(101));
¬†
}
¬†
fn factor(num: i32) -> Vec<i32> {
    let mut factors: Vec<i32> = Vec::new(); // creates a new vector for the factors of the number
¬†
    for i in 1..((num as f32).sqrt() as i32 + 1) { 
        if num¬†% i == 0 {
            factors.push(i); // pushes smallest factor to factors
            factors.push(num/i); // pushes largest factor to factors
        }
    }
    factors.sort(); // sorts the factors into numerical order for viewing purposes
    factors // returns the factors
}
```

# Sorting algorithms/Quicksort<a id="sec-52"></a>

This page uses content from Wikipedia. The original article was at Quicksort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Task

Sort an array (or list) elements using the ¬† quicksort ¬† algorithm.

The elements must have a ¬† strict weak order ¬† and the index of the array can be of any discrete type.

For languages where this is not possible, sort an array of integers.

Quicksort, also known as ¬† partition-exchange sort, ¬† uses these steps.

¬† Choose any element of the array to be the pivot. ¬† Divide all other elements (except the pivot) into two partitions. ¬† All elements less than the pivot must be in the first partition. ¬† All elements greater than the pivot must be in the second partition. ¬† Use recursion to sort both partitions. ¬† Join the first sorted partition, the pivot, and the second sorted partition.

The best pivot creates partitions of equal length (or lengths differing by ¬† 1).

The worst pivot creates an empty partition (for example, if the pivot is the first or last element of a sorted array).

The run-time of Quicksort ranges from ¬† O(n log n) ¬† with the best pivots, to ¬† O(n2) ¬† with the worst pivots, where ¬† n ¬† is the number of elements in the array.

This is a simple quicksort algorithm, adapted from Wikipedia.

```
function quicksort(array)
    less, equal, greater := three empty arrays
    if length(array) > 1  
        pivot := select any element of array
        for each x in array
            if x < pivot then add x to less
            if x = pivot then add x to equal
            if x > pivot then add x to greater
        quicksort(less)
        quicksort(greater)
        array := concatenate(less, equal, greater)

```

A better quicksort algorithm works in place, by swapping elements within the array, to avoid the memory allocation of more arrays.

```
function quicksort(array)
    if length(array) > 1
        pivot := select any element of array
        left := first index of array
        right := last index of array
        while left ‚â§ right
            while array[left] < pivot
                left¬†:= left + 1
            while array[right] > pivot
                right¬†:= right - 1
            if left ‚â§ right
                swap array[left] with array[right]
                left¬†:= left + 1
                right¬†:= right - 1
        quicksort(array from first index to right)
        quicksort(array from left to last index)

```

Quicksort has a reputation as the fastest sort. Optimized variants of quicksort are common features of many languages and libraries. One often contrasts quicksort with ¬† merge sort, ¬† because both sorts have an average time of ¬† O(n log n).

"On average, mergesort does fewer comparisons than quicksort, so it may be better when complicated comparison routines are used. Mergesort also takes advantage of pre-existing order, so it would be favored for using sort() to merge several sorted arrays. On the other hand, quicksort is often faster for small arrays, and on arrays of a few distinct values, repeated many times." ‚Äî <http://perldoc.perl.org/sort.html>

Quicksort is at one end of the spectrum of divide-and-conquer algorithms, with merge sort at the opposite end.

Quicksort is a conquer-then-divide algorithm, which does most of the work during the partitioning and the recursive calls. The subsequent reassembly of the sorted partitions involves trivial effort. Merge sort is a divide-then-conquer algorithm. The partioning happens in a trivial way, by splitting the input array in half. Most of the work happens during the recursive calls and the merge phase.

With quicksort, every element in the first partition is less than or equal to every element in the second partition. Therefore, the merge phase of quicksort is so trivial that it needs no mention!

This task has not specified whether to allocate new arrays, or sort in place. This task also has not specified how to choose the pivot element. (Common ways to are to choose the first element, the middle element, or the median of three elements.) Thus there is a variety among the following implementations.

```rust
fn main() {
    println!("Sort numbers in descending order");
    let mut numbers = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1];
    println!("Before: {:?}", numbers);
¬†
    quick_sort(&mut numbers, &|x,y| x > y);
    println!("After:  {:?}\n", numbers);
¬†
    println!("Sort strings alphabetically");
    let mut strings = ["beach", "hotel", "airplane", "car", "house", "art"];
    println!("Before: {:?}", strings);
¬†
    quick_sort(&mut strings, &|x,y| x < y);
    println!("After:  {:?}\n", strings);
¬†
    println!("Sort strings by length");
    println!("Before: {:?}", strings);
¬†
    quick_sort(&mut strings, &|x,y| x.len() < y.len());
    println!("After:  {:?}", strings);    
}
¬†
fn quick_sort<T,F>(v: &mut [T], f: &F) 
    where F: Fn(&T,&T) -> bool
{
    let len = v.len();
    if len >= 2 {
        let pivot_index = partition(v, f);
        quick_sort(&mut v[0..pivot_index], f);
        quick_sort(&mut v[pivot_index + 1..len], f);
    }
}
¬†
fn partition<T,F>(v: &mut [T], f: &F) -> usize 
    where F: Fn(&T,&T) -> bool
{
    let len = v.len();
    let pivot_index = len / 2;
¬†
    v.swap(pivot_index, len - 1);
¬†
    let mut store_index = 0;
    for i in 0..len - 1 {
        if f(&v[i], &v[len - 1]) {
            v.swap(i, store_index);
            store_index += 1;
        }
    }
¬†
    v.swap(store_index, len - 1);
    store_index
}
```

Output:

```rust
Sort numbers in descending order
Before: [4, 65, 2, -31, 0, 99, 2, 83, 782, 1]
After:  [782, 99, 83, 65, 4, 2, 2, 1, 0, -31]

Sort strings alphabetically
Before: ["beach", "hotel", "airplane", "car", "house", "art"]
After:  ["airplane", "art", "beach", "car", "hotel", "house"]

Sort strings by length
Before: ["airplane", "art", "beach", "car", "hotel", "house"]
After:  ["car", "art", "house", "hotel", "beach", "airplane"]
```

# Loops/Infinite<a id="sec-53"></a>

Task

Print out ¬† ¬† ¬† SPAM ¬† ¬† ¬† followed by a ¬† newline ¬† in an infinite loop.

Related tasks

¬† Loop over multiple arrays simultaneously ¬† Loops/Break ¬† Loops/Continue ¬† Loops/Do-while ¬† Loops/Downward for ¬† Loops/For ¬† Loops/For with a specified step ¬† Loops/Foreach ¬† Loops/Increment loop index within loop body ¬† Loops/Infinite ¬† Loops/N plus one half ¬† Loops/Nested ¬† Loops/While ¬† Loops/with multiple ranges ¬† Loops/Wrong ranges

```rust
fn main() {
    loop {
        println!("SPAM");
    }
}
```

# Boolean values<a id="sec-54"></a>

Task

Show how to represent the boolean states "true" and "false" in a language.

If other objects represent "true" or "false" in conditionals, note it.

Related tasks

¬† Logical operations

Booleans are expressed using the bool type and the two literals true and false. The compiler prevents any other values from being assigned to a bool variable. This behavior is not guaranteed inside blocks labeled as unsafe, where it is the programmers responsibility to ensure this behavior.

# Caesar cipher<a id="sec-55"></a>

Task

Implement a Caesar cipher, both encoding and decoding. The key is an integer from 1 to 25.

This cipher rotates (either towards left or right) the letters of the alphabet (A to Z).

The encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A). So key 2 encrypts "HI" to "JK", but key 20 encrypts "HI" to "BC".

This simple "mono-alphabetic substitution cipher" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.

Caesar cipher is identical to Vigen√®re cipher with a key of length 1. Also, Rot-13 is identical to Caesar cipher with key 13.

Related tasks

Rot-13 Substitution Cipher Vigen√®re Cipher/Cryptanalysis

This example shows proper error handling. It skips non-ASCII characters.

```rust
use std::io::{self, Write};
use std::fmt::Display;
use std::{env, process};
¬†
fn main() {
    let shift: u8 = env::args().nth(1)
        .unwrap_or_else(|| exit_err("No shift provided", 2))
        .parse()
        .unwrap_or_else(|e| exit_err(e, 3));
¬†
    let plain = get_input()
        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));
¬†
    let cipher = plain.chars()
        .map(|c| {
            let case = if c.is_uppercase() {'A'} else {'a'} as u8;
            if c.is_alphabetic() { (((c as u8 - case + shift)¬†% 26) + case) as char } else { c }
        }).collect::<String>();
¬†
    println!("Cipher text: {}", cipher.trim());
}
¬†
¬†
fn get_input() -> io::Result<String> {
    print!("Plain text:  ");
    try!(io::stdout().flush());
¬†
    let mut buf = String::new();
    try!(io::stdin().read_line(&mut buf));
    Ok(buf)
}
¬†
fn exit_err<T: Display>(msg: T, code: i32) ->¬†! {
    let _ = writeln!(&mut io::stderr(), "ERROR: {}", msg);
    process::exit(code);
}
```

# Increment a numerical string<a id="sec-56"></a>

Task

Increment a numerical string.

```rust
fn next_string(input: &str) -> String {
    (input.parse::<i64>().unwrap() + 1).to_string()
}
¬†
fn main() {
    let s = "-1";
    let s2 = next_string(s);
    println!("{:?}", s2);
}
```

Output:

```rust
"0"
```

# Sum and product of an array<a id="sec-57"></a>

Compute the sum and product of an array of integers.

```rust
¬†
¬†
fn main() {
    let arr = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];
¬†
    // using fold
    let sum = arr.iter().fold(0i32, |a, &b| a + b);
    let product = arr.iter().fold(1i32, |a, &b| a * b);
    println!("the sum is {} and the product is {}", sum, product);
¬†
    // or using sum and product
    let sum = arr.iter().sum::<i32>();
    let product = arr.iter().product::<i32>();
    println!("the sum is {} and the product is {}", sum, product);
}
¬†
```

# Anagrams<a id="sec-58"></a>

When two or more words are composed of the same characters, but in a different order, they are called anagrams.

Task[edit]

Using the word list at ¬† <http://www.puzzlers.org/pub/wordlists/unixdict.txt>, find the sets of words that share the same characters that contain the most words in them.

Related tasks

Word plays

Ordered words Palindrome detection Semordnilap Anagrams Anagrams/Deranged anagrams

Sorting[edit]

Unicode is hard so the solution depends on what you consider to be an anagram: two strings that have the same bytes, the same codepoints, or the same graphemes. The first two are easily accomplished in Rust proper, but the latter requires an external library. Graphemes are probably the most correct way, but it is also the least efficient since graphemes are variable size and thus require a heap allocation per grapheme.

```rust
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead,BufReader};
use std::borrow::ToOwned;
¬†
extern crate unicode_segmentation;
use unicode_segmentation::{UnicodeSegmentation};
¬†
fn main () {
    let file = BufReader::new(File::open("unixdict.txt").unwrap());
    let mut map = HashMap::new();
    for line in file.lines() {
        let s = line.unwrap();
        //Bytes:      let mut sorted = s.trim().bytes().collect::<Vec<_>>();
        //Codepoints: let mut sorted = s.trim().chars().collect::<Vec<_>>();
        let mut sorted = s.trim().graphemes(true).map(ToOwned::to_owned).collect::<Vec<_>>();
        sorted.sort();
¬†
        map.entry(sorted).or_insert_with(Vec::new).push(s);
    }
¬†
    if let Some(max_len) = map.values().map(|v| v.len()).max() {
        for anagram in map.values().filter(|v| v.len() == max_len) {
            for word in anagram {
                print!("{} ", word);
            }
            println!();
        }
    }
}
```

Output:

```rust
alger glare lager large regal
angel angle galen glean lange
elan lane lean lena neal
evil levi live veil vile
caret carte cater crate trace
abel able bale bela elba

```

Using prime factors[edit]

If we assume an ASCII string, we can map each character to a prime number and multiply these together to create a number which uniquely maps to each anagram.

```rust
use std::collections::HashMap;
use std::path::Path;
use std::io::{self, BufRead, BufReader};
use std::fs::File;
¬†
fn main() {
    if let Ok(anagrams) = find_anagrams("unixdict.txt") {
        for anagram in anagrams {
            for word in anagram {
                print!("{} ", word);
            }
            println!();
        }
    }
}
¬†
const PRIMES: [u64; 256] = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127
                           ,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257
                           ,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401
                           ,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563
                           ,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709
                           ,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877
                           ,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033
                           ,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171
                           ,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301
                           ,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453
                           ,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583
                           ,1597,1601,1607,1609,1613,1619];
¬†
fn find_anagrams<P: AsRef<Path>>(file: P) -> io::Result<Vec<Vec<String>>> {
    let file = BufReader::new(File::open(file)?);
    let mut map = HashMap::new();
    for line in file.lines() {
        let string = line?;
        let mut num = 1;
        for ch in string.trim().bytes() {
            num *= PRIMES[ch as usize];
        }
        map.entry(num).or_insert_with(Vec::new).push(string);
    }
    Ok(map.into_iter().map(|(_, entry)| entry).collect())
}
```

# File input/output<a id="sec-59"></a>

Task

Create a file called ¬† "output.txt", ¬† and place in it the contents of the file ¬† "input.txt", ¬† via an intermediate variable.

In other words, your program will demonstrate:

¬† how to read from a file into a variable ¬† how to write a variable's contents into a file

Oneliners that skip the intermediate variable are of secondary interest ‚Äî operating systems have copy commands for that.

```rust
use std::fs::File;
use std::io::{Read, Write};
¬†
fn main() {
    let mut file = File::open("input.txt").unwrap();
    let mut data = Vec::new();
    file.read_to_end(&mut data).unwrap();
    let mut file = File::create("output.txt").unwrap();
    file.write_all(&data).unwrap();
}
¬†
```

The above program will panic with any sort of error. The following shows proper error handling:

```rust
use std::fs::File;
use std::io::{self, Read,  Write};
use std::path::Path;
use std::{env, fmt, process};
¬†
fn main() {
    let files: Vec<_> = env::args_os().skip(1).take(2).collect();
¬†
    if files.len()¬†!= 2 {
        exit_err("Both an input file and output file are required", 1);
    }
¬†
    copy(&files[0], &files[1]).unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));
}
¬†
fn copy<P: AsRef<Path>>(infile: P, outfile: P) -> io::Result<()> {
    let mut vec = Vec::new();
¬†
    Ok(try!(File::open(infile)
         .and_then(|mut i| i.read_to_end(&mut vec))
         .and_then(|_| File::create(outfile))
         .and_then(|mut o| o.write_all(&vec))))
}
¬†
fn exit_err<T: fmt::Display>(msg: T, code: i32) ->¬†! {
    writeln!(&mut io::stderr(), "ERROR: {}", msg).expect("Could not write to stdout");
    process::exit(code);
}
```

# Permutations<a id="sec-60"></a>

Task

Write a program that generates all ¬† permutations ¬† of ¬† n ¬† different objects. ¬† (Practically numerals!)

Related tasks

¬† Find the missing permutation ¬† Permutations/Derangements

The number of samples of size k from n objects. With combinations and permutations generation tasks. Order Unimportant Order Important Without replacement {\displaystyle {\binom {n}{k}}=<sup>n</sup>\operatorname {C} \_{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)&hellip; 1}}}

{\displaystyle ^{n}\operatorname {P} \_{k}=n&sdot; (n-1)&sdot; (n-2)&ctdot; (n-k+1)}

Task: Combinations Task: Permutations With replacement {\displaystyle {\binom {n+k-1}{k}}=<sup>n+k-1</sup>\operatorname {C} \_{k}={(n+k-1)! \over (n-1)!k!}}

{\displaystyle n<sup>k</sup>}

Task: Combinations with repetitions Task: Permutations with repetitions

Iterative[edit]

Uses Heap's algorithm. An in-place version is possible but is incompatible with Iterator.

```rust
pub fn permutations(size: usize) -> Permutations {
    Permutations { idxs: (0..size).collect(), swaps: vec![0; size], i: 0 }
}
¬†
pub struct Permutations {
    idxs: Vec<usize>,
    swaps: Vec<usize>,
    i: usize,
}
¬†
impl Iterator for Permutations {
    type Item = Vec<usize>;
¬†
    fn next(&mut self) -> Option<Self::Item> {
        if self.i > 0 {
            loop {
                if self.i >= self.swaps.len() { return None; }
                if self.swaps[self.i] < self.i { break; }
                self.swaps[self.i] = 0;
                self.i += 1;
            }
            self.idxs.swap(self.i, (self.i & 1) * self.swaps[self.i]);
            self.swaps[self.i] += 1;
        }
        self.i = 1;
        Some(self.idxs.clone())
    }
}
¬†
fn main() {
    let perms = permutations(3).collect::<Vec<_>>();
    assert_eq!(perms, vec![
        vec![0, 1, 2],
        vec![1, 0, 2],
        vec![2, 0, 1],
        vec![0, 2, 1],
        vec![1, 2, 0],
        vec![2, 1, 0],
    ]);
}
```

Recursive[edit]

```rust
use std::collections::VecDeque;
¬†
fn permute<T, F: Fn(&[T])>(used: &mut Vec<T>, unused: &mut VecDeque<T>, action: &F) {
    if unused.is_empty() {
        action(used);
    } else {
        for _ in 0..unused.len() {
            used.push(unused.pop_front().unwrap());
            permute(used, unused, action);
            unused.push_back(used.pop().unwrap());
        }
    }
}
¬†
fn main() {
    let mut queue = (1..4).collect::<VecDeque<_>>();
    permute(&mut Vec::new(), &mut queue, &|perm| println!("{:?}", perm));
}
```

# Character codes<a id="sec-61"></a>

Task

Given a character value in your language, print its code ¬† (could be ASCII code, Unicode code, or whatever your language uses).

Example

The character ¬† 'a' ¬† (lowercase letter A) ¬† has a code of 97 in ASCII ¬† (as well as Unicode, as ASCII forms the beginning of Unicode).

Conversely, given a code, print out the corresponding character.

```rust
use std::char::from_u32;
¬†
fn main() {
    //ascii char
    println!("{}", 'a' as u8);
    println!("{}", 97 as char);
¬†
    //unicode char
    println!("{}", 'œÄ' as u32);
    println!("{}", from_u32(960).unwrap());
}
```

Output:

```rust
97
a
960
œÄ
```

# Stack<a id="sec-62"></a>

A stack is a container of elements with ¬† last in, first out ¬† access policy. ¬† Sometimes it also called LIFO.

The stack is accessed through its top.

The basic stack operations are:

¬† push ¬† stores a new element onto the stack top; ¬† pop ¬† returns the last pushed stack element, while removing it from the stack; ¬† empty ¬† tests if the stack contains no elements.

Sometimes the last pushed stack element is made accessible for immutable access (for read) or mutable access (for write):

¬† top ¬† (sometimes called peek to keep with the p theme) returns the topmost element without modifying the stack.

Stacks allow a very simple hardware implementation.

They are common in almost all processors.

In programming, stacks are also very popular for their way (LIFO) of resource management, usually memory.

Nested scopes of language objects are naturally implemented by a stack (sometimes by multiple stacks).

This is a classical way to implement local variables of a re-entrant or recursive subprogram. Stacks are also used to describe a formal computational framework.

See stack machine.

Many algorithms in pattern matching, compiler construction (e.g. recursive descent parsers), and machine learning (e.g. based on tree traversal) have a natural representation in terms of stacks.

Task

Create a stack supporting the basic operations: push, pop, empty.

See also

Array Associative array: Creation, Iteration Collections Compound data type Doubly-linked list: Definition, Element definition, Element insertion, Traversal Linked list Queue: Definition, Usage Set Singly-linked list: Element definition, Element insertion, Traversal Stack

Using the standard library[edit]

One could just use a vector (Vec<T>) which is part of the standard library

```rust
fn main() {
    let mut stack = Vec::new();
    stack.push("Element1");
    stack.push("Element2");
    stack.push("Element3");
¬†
    assert_eq!(Some(&"Element3"), stack.last());
    assert_eq!(Some("Element3"), stack.pop());
    assert_eq!(Some("Element2"), stack.pop());
    assert_eq!(Some("Element1"), stack.pop());
    assert_eq!(None, stack.pop());
}
```

Simple implementation[edit]

Simply uses a singly-linked list.

```rust
type Link<T> = Option<Box<Frame<T>>>;
¬†
pub struct Stack<T> {
    head: Link<T>,
}
struct Frame<T> { 
    elem: T,
    next: Link<T>,
}
¬†
/// Iterate by value (consumes list)
pub struct IntoIter<T>(Stack<T>); 
impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        self.0.pop()
    }
}
¬†
/// Iterate by immutable reference
pub struct Iter<'a, T: 'a> { 
    next: Option<&'a Frame<T>>,
}
impl<'a, T> Iterator for Iter<'a, T> { // Iterate by immutable reference
    type Item = &'a T;
    fn next(&mut self) -> Option<Self::Item> {
        self.next.take().map(|frame| {
            self.next = frame.next.as_ref().map(|frame| &**frame);
            &frame.elem
        })
    }
}
¬†
/// Iterate by mutable reference
pub struct IterMut<'a, T: 'a> {
    next: Option<&'a mut Frame<T>>,
}
impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;
    fn next(&mut self) -> Option<Self::Item> {
        self.next.take().map(|frame| {
            self.next = frame.next.as_mut().map(|frame| &mut **frame);
            &mut frame.elem
        })
    }
}
¬†
¬†
impl<T> Stack<T> {
    /// Return new, empty stack
    pub fn new() -> Self {
        Stack { head: None }
    }
¬†
    /// Add element to top of the stack
    pub fn push(&mut self, elem: T) {
        let new_frame = Box::new(Frame {
            elem: elem,
            next: self.head.take(),
        });
        self.head = Some(new_frame);
    }
¬†
    /// Remove element from top of stack, returning the value
    pub fn pop(&mut self) -> Option<T> {
        self.head.take().map(|frame| { 
            let frame = *frame;
            self.head = frame.next;
            frame.elem
        })
    }
¬†
    /// Get immutable reference to top element of the stack
    pub fn peek(&self) -> Option<&T> {
        self.head.as_ref().map(|frame| &frame.elem)
    }
¬†
    /// Get mutable reference to top element on the stack
    pub fn peek_mut(&mut self) -> Option<&mut T> {
        self.head.as_mut().map(|frame| &mut frame.elem)
    }
¬†
    /// Iterate over stack elements by value
    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }
¬†
    /// Iterate over stack elements by immutable reference
    pub fn iter<'a>(&'a self) -> Iter<'a,T> {
        Iter { next: self.head.as_ref().map(|frame| &**frame) }
    }
¬†
    /// Iterate over stack elements by mutable reference
    pub fn iter_mut(&mut self) -> IterMut<T> {
        IterMut { next: self.head.as_mut().map(|frame| &mut **frame) }
    }
}
¬†
// The Drop trait tells the compiler how to free an object after it goes out of scope. 
// By default, the compiler would do this recursively which *could* blow the stack for
// extraordinarily long lists. This simply tells it to do it iteratively.
impl<T> Drop for Stack<T> {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_frame) = cur_link {
            cur_link = boxed_frame.next.take();
        }
    }
}
```

# Sorting algorithms/Bubble sort<a id="sec-63"></a>

Task

Sort an array of elements using the bubble sort algorithm. ¬† The elements must have a total order and the index of the array can be of any discrete type. ¬† For languages where this is not possible, sort an array of integers.

The bubble sort is generally considered to be the simplest sorting algorithm.

Because of its simplicity and ease of visualization, it is often taught in introductory computer science courses.

Because of its abysmal O(n2) performance, it is not used often for large (or even medium-sized) datasets.

The bubble sort works by passing sequentially over a list, comparing each value to the one immediately after it. ¬† If the first value is greater than the second, their positions are switched. ¬† Over a number of passes, at most equal to the number of elements in the list, all of the values drift into their correct positions (large values "bubble" rapidly toward the end, pushing others down around them). ¬† Because each pass finds the maximum item and puts it at the end, the portion of the list to be sorted can be reduced at each pass. ¬† A boolean variable is used to track whether any changes have been made in the current pass; when a pass completes without changing anything, the algorithm exits.

This can be expressed in pseudo-code as follows (assuming 1-based indexing):

```
repeat
    hasChanged¬†:= false
    decrement itemCount
    repeat with index from 1 to itemCount
        if (item at index) > (item at (index + 1))
            swap (item at index) with (item at (index + 1))
            hasChanged¬†:= true
until hasChanged = false

```

References

The article on Wikipedia. Dance interpretation.

```rust
fn bubble_sort<T: Ord>(values: &mut[T]) {
    let mut n = values.len();
    let mut swapped = true;
¬†
    while swapped {
        swapped = false;
¬†
        for i in 1..n {
            if values[i - 1] > values[i] {
                values.swap(i - 1, i);
                swapped = true;
            }
        }
¬†
        n = n - 1;
    }
}
¬†
fn main() {
    // Sort numbers.
    let mut numbers = [8, 7, 1, 2, 9, 3, 4, 5, 0, 6];
    println!("Before: {:?}", numbers);
¬†
    bubble_sort(&mut numbers);
    println!("After: {:?}", numbers);
¬†
    // Sort strings.
    let mut strings = ["empty", "beach", "art", "car", "deal"];
    println!("Before: {:?}", strings);
¬†
    bubble_sort(&mut strings);
    println!("After: {:?}", strings);
}
```

# Combinations<a id="sec-64"></a>

Task

Given non-negative integers ¬† m ¬† and ¬† n, ¬† generate all size ¬† m ¬† combinations ¬† of the integers from ¬† 0 ¬† (zero) ¬† to ¬† n-1 ¬† in sorted order ¬† (each combination is sorted and the entire table is sorted).

Example

3 ¬† comb ¬† 5 ¬† ¬† is:

```
0 1 2
0 1 3
0 1 4
0 2 3
0 2 4
0 3 4
1 2 3
1 2 4
1 3 4
2 3 4

```

If it is more "natural" in your language to start counting from ¬† 1 ¬† (unity) instead of ¬† 0 ¬† (zero), the combinations can be of the integers from ¬† 1 ¬† to ¬† n.

See also

The number of samples of size k from n objects. With combinations and permutations generation tasks. Order Unimportant Order Important Without replacement {\displaystyle {\binom {n}{k}}=<sup>n</sup>\operatorname {C} \_{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)&hellip; 1}}}

{\displaystyle ^{n}\operatorname {P} \_{k}=n&sdot; (n-1)&sdot; (n-2)&ctdot; (n-k+1)}

Task: Combinations Task: Permutations With replacement {\displaystyle {\binom {n+k-1}{k}}=<sup>n+k-1</sup>\operatorname {C} \_{k}={(n+k-1)! \over (n-1)!k!}}

{\displaystyle n<sup>k</sup>}

Task: Combinations with repetitions Task: Permutations with repetitions

Works with: Rust version 0.9

```rust
¬†
fn comb<T: std::fmt::Default>(arr: &[T], n: uint) {
  let mut incl_arr: ~[bool] = std::vec::from_elem(arr.len(), false);
  comb_intern(arr, n, incl_arr, 0);
}
¬†
fn comb_intern<T: std::fmt::Default>(arr: &[T], n: uint, incl_arr: &mut [bool], index: uint) {
  if (arr.len() < n + index) { return; }
  if (n == 0) {
    let mut it = arr.iter().zip(incl_arr.iter()).filter_map(|(val, incl)|
      if (*incl) { Some(val) } else { None }
    );
    for val in it { print!("{} ", *val); }
    print("\n");
    return;
  }
¬†
  incl_arr[index] = true;
  comb_intern(arr, n-1, incl_arr, index+1);
  incl_arr[index] = false;
¬†
  comb_intern(arr, n, incl_arr, index+1);
}
¬†
fn main() {
  let arr1 = ~[1, 2, 3, 4, 5];
  comb(arr1, 3);
¬†
  let arr2 = ~["A", "B", "C", "D", "E"];
  comb(arr2, 3);
}
¬†
```

# Command-line arguments<a id="sec-65"></a>

Scripted main

See also Program name.

For parsing command line arguments intelligently, see Parsing command-line arguments.

Example command line:

```
myprogram -c "alpha beta" -h "gamma"

```

```rust
use std::env;
¬†
fn main(){
    let args: Vec<_> = env::args().collect();
    println!("{:?}", args);
}
```

Run:

```rust
./program -c "alpha beta" -h "gamma"
["./program", "-c", "alpha beta", "-h", "gamma"]
```

# Rot-13<a id="sec-66"></a>

Task

Implement a ¬† rot-13 ¬† function ¬† (or procedure, class, subroutine, or other "callable" object as appropriate to your programming environment).

Optionally wrap this function in a utility program ¬† (like tr, ¬† which acts like a common UNIX utility, performing a line-by-line rot-13 encoding of every line of input contained in each file listed on its command line, ¬† or (if no filenames are passed thereon) acting as a filter on its ¬† "standard input."

(A number of UNIX scripting languages and utilities, such as ¬† awk ¬† and ¬† sed ¬† either default to processing files in this way or have command line switches or modules to easily implement these wrapper semantics, e.g., ¬† Perl ¬† and ¬† Python).

The ¬† rot-13 ¬† encoding is commonly known from the early days of Usenet "Netnews" as a way of obfuscating text to prevent casual reading of ¬† spoiler ¬† or potentially offensive material.

Many news reader and mail user agent programs have built-in rot-13 encoder/decoders or have the ability to feed a message through any external utility script for performing this (or other) actions.

The definition of the rot-13 function is to simply replace every letter of the ASCII alphabet with the letter which is "rotated" 13 characters "around" the 26 letter alphabet from its normal cardinal position ¬† (wrapping around from ¬† z ¬† to ¬† a ¬† as necessary).

Thus the letters ¬† abc ¬† become ¬† nop ¬† and so on.

Technically rot-13 is a ¬† "mono-alphabetic substitution cipher" ¬† with a trivial ¬† "key".

A proper implementation should work on upper and lower case letters, preserve case, and pass all non-alphabetic characters in the input stream through without alteration.

Related tasks

¬† Caesar cipher ¬† Substitution Cipher ¬† Vigen√®re Cipher/Cryptanalysis

This program works for ascii, but is likely to break for utf8-strings containing non-ascii characters.

```rust
fn rot13 (string: String) -> String {
    let mut bytes: Vec<u8> = string.into();
    for byte in &mut bytes {
        match *byte {
            b'a'...b'm' | b'A'...b'M' => *byte += 13,
            b'n'...b'z' | b'N'...b'Z' => *byte -= 13,
            _ => (), // do nothing
        }
    }
    String::from_utf8(bytes).unwrap()
}
¬†
fn main () {
    let a =  rot13("abc".to_owned());
    assert_eq!(a, "nop");
}
```

A more rustcean way to implement Rot-13 which is UTF-8 safe.

```rust
fn rot13(string: String) -> String {
     let alphabet = [
         'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
         'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
     ];
¬†
     string.chars()
           .map(|c| *alphabet.iter()
                             .chain(alphabet.iter())
                             .skip_while(|&x| *x¬†!= c)
                             .nth(13)
                             .unwrap_or(&c))
           .collect()
}
```

# Balanced brackets<a id="sec-67"></a>

Task:

Generate a string with ¬† N ¬† opening brackets ¬† [ ¬† and with ¬† N ¬† closing brackets ¬† ], ¬† in some arbitrary order. Determine whether the generated string is balanced; that is, whether it consists entirely of pairs of opening/closing brackets (in that order), none of which mis-nest.

Examples

```
(empty)      OK
[]           OK   
[][]         OK   
[[][]]       OK 
][         NOT OK
][][       NOT OK
[]][[]     NOT OK

```

Library: rand

```rust
extern crate rand;
¬†
trait Balanced {
    /// Returns true if the brackets are balanced
    fn is_balanced(&self) -> bool;
}
¬†
impl<'a> Balanced for str {
    fn is_balanced(&self) -> bool {
        let mut count = 0;
¬†
        for bracket in self.chars() {
            let change = match bracket {
                '[' => 1,
                ']' => -1,
                _ => panic!("Strings should only contain brackets")
            };
¬†
            count += change;
            if count < 0 { return false; }
        }
¬†
        count == 0
    }
}
¬†
/// Generates random brackets
fn generate_brackets(num: usize) -> String {
    use rand::random;
¬†
    (0..num).map(|_| if random() { '[' } else { ']' }).collect()
}
¬†
fn main() {
    for i in (0..10) {
        let brackets = generate_brackets(i);
¬†
        println!("{}    {}", brackets, brackets.is_balanced())
    }
}
```

```rust
    true
[    false
]]    false
][]    false
[[[[    false
]][[[    false
[][[]]    true
[]]][[]    false
[[[[[[][    false
][[[[][]]    false

```

# Roman numerals/Decode<a id="sec-68"></a>

Task

Create a function that takes a Roman numeral as its argument and returns its value as a numeric decimal integer.

You don't need to validate the form of the Roman numeral.

Modern Roman numerals are written by expressing each decimal digit of the number to be encoded separately, starting with the leftmost decimal digit and skipping any 0s ¬† (zeroes).

1990 is rendered as ¬† MCMXC ¬† ¬† (1000 = M, ¬† 900 = CM, ¬† 90 = XC) ¬† ¬† and 2008 is rendered as ¬† MMVIII ¬† ¬† ¬† (2000 = MM, ¬† 8 = VIII).

The Roman numeral for 1666, ¬† MDCLXVI, ¬† uses each letter in descending order.

```rust
struct RomanNumeral {
    symbol: &'static str,
    value: u32
}
¬†
const NUMERALS: [RomanNumeral; 13] = [
    RomanNumeral {symbol: "M",  value: 1000},
    RomanNumeral {symbol: "CM", value: 900},
    RomanNumeral {symbol: "D",  value: 500},
    RomanNumeral {symbol: "CD", value: 400},
    RomanNumeral {symbol: "C",  value: 100},
    RomanNumeral {symbol: "XC", value: 90},
    RomanNumeral {symbol: "L",  value: 50},
    RomanNumeral {symbol: "XL", value: 40},
    RomanNumeral {symbol: "X",  value: 10},
    RomanNumeral {symbol: "IX", value: 9},
    RomanNumeral {symbol: "V",  value: 5},
    RomanNumeral {symbol: "IV", value: 4},
    RomanNumeral {symbol: "I",  value: 1}
];
¬†
fn to_hindu(roman: &str) -> u32 {
    match NUMERALS.iter().find(|num| roman.starts_with(num.symbol)) {
        Some(num) => num.value + to_hindu(&roman[num.symbol.len()..]),
        None => 0, // if string empty, add nothing
    }
}
¬†
fn main() {
    let roms = ["MMXIV", "MCMXCIX", "XXV", "MDCLXVI", "MMMDCCCLXXXVIII"];
    for &r in &roms {
        // 15 is minimum formatting width of the first argument, there for alignment
        println!("{:2$} = {}", r, to_hindu(r), 15);
    }
}
```

Output:

```rust
MMXIV           = 2014
MCMXCIX         = 1999
XXV             = 25
MDCLXVI         = 1666
MMMDCCCLXXXVIII = 3888
```

# Ethiopian multiplication<a id="sec-69"></a>

Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.

Method:

Take two numbers to be multiplied and write them down at the top of two columns. In the left-hand column repeatedly halve the last number, discarding any remainders, and write the result below the last in the same column, until you write a value of 1. In the right-hand column repeatedly double the last number and write the result below. stop when you add a result in the same row as where the left hand column shows 1. Examine the table produced and discard any row where the value in the left column is even. Sum the values in the right-hand column that remain to produce the result of multiplying the original two numbers together

For example: ¬† 17 √ó 34

```
17    34

```

Halving the first column:

```
17    34
 8
 4
 2
 1

```

Doubling the second column:

```
17    34
 8    68
 4   136 
 2   272
 1   544

```

Strike-out rows whose first cell is even:

```
17    34
 8    68 
 4   136 
 2   272 
 1   544

```

Sum the remaining numbers in the right-hand column:

```
17    34
 8    -- 
 4   --- 
 2   --- 
 1   544
    ====
     578

```

So 17 multiplied by 34, by the Ethiopian method is 578.

Task

The task is to define three named functions/methods/procedures/subroutines:

one to halve an integer, one to double an integer, and one to state if an integer is even.

Use these functions to create a function that does Ethiopian multiplication.

References

Ethiopian multiplication explained (Video) A Night Of Numbers - Go Forth And Multiply (Video) Ethiopian multiplication Russian Peasant Multiplication Programming Praxis: Russian Peasant Multiplication

```rust
fn double(a: i32) -> i32 {
    2*a
}
¬†
fn halve(a: i32) -> i32 {
    a/2
}
¬†
fn is_even(a: i32) -> bool {
    a¬†% 2 == 0
}
¬†
fn ethiopian_multiplication(mut x: i32, mut y: i32) -> i32 {
    let mut sum = 0;
¬†
    while x >= 1 {
        print!("{} \t {}", x, y);
        match is_even(x) {
            true  => println!("\t Not Kept"),
            false => {
                println!("\t Kept");
                sum += y;
            }
        }
        x = halve(x);
        y = double(y);
    }
    sum
}
¬†
fn main() {
    let output = ethiopian_multiplication(17, 34);
    println!("---------------------------------");
    println!("\t {}", output);
}
```

Output:

```rust
17       34      Kept
8        68      Not Kept
4        136     Not Kept
2        272     Not Kept
1        544     Kept
---------------------------------
         578
```

# Search a list<a id="sec-70"></a>

Task[edit]

Find the index of a string (needle) in an indexable, ordered collection of strings (haystack).

Raise an exception if the needle is missing.

If there is more than one occurrence then return the smallest index to the needle.

Extra credit

Return the largest index to a needle that has multiple occurrences in the haystack.

See also

Search a list of records

Rust encourages to encode possible errors in function's return type. For example, position returns Option<usize>, which can be None or Some(x).

```rust
fn main() {
    let haystack=vec!["Zig", "Zag", "Wally", "Ronald", "Bush", "Krusty", "Charlie", 
                        "Bush", "Boz", "Zag"];
¬†
    println!("First occurence of 'Bush' at {:?}",haystack.iter().position(|s| *s=="Bush"));
    println!("Last occurence of 'Bush' at {:?}",haystack.iter().rposition(|s| *s=="Bush"));
    println!("First occurence of 'Rob' at {:?}",haystack.iter().position(|s| *s=="Rob"));
}
¬†
```

Output:

```rust
First occurence of 'Bush' at Some(4)
Last occurence of 'Bush' at Some(7)
First occurence of 'Rob' at None

```

Version that panics[edit]

```rust
fn main() {
    let haystack=vec!["Zig", "Zag", "Wally", "Ronald", "Bush", "Krusty", "Charlie", 
                        "Bush", "Boz", "Zag"];
¬†
    println!("First occurence of 'Bush' at {:?}",haystack.iter().position(|s| *s=="Bush").unwrap());
    println!("Last occurence of 'Bush' at {:?}",haystack.iter().rposition(|s| *s=="Bush").unwrap());
    println!("First occurence of 'Rob' at {:?}",haystack.iter().position(|s| *s=="Rob").unwrap());
}
¬†
```

Output:

```rust
First occurence of 'Bush' at 4
Last occurence of 'Bush' at 7
thread '<main>' panicked at 'called `Option::unwrap()` on a `None` value', /home/rustbuild/src/rust-buildbot/slave/stable-dist-rustc-linux/build/src/libcore/option.rs:362
playpen: application terminated with error code 101

```

# Flatten a list<a id="sec-71"></a>

Task

Write a function to flatten the nesting in an arbitrary ¬† list of values.

Your program should work on the equivalent of this list:

```
[[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]

```

Where the correct result would be the list:

```
[1, 2, 3, 4, 5, 6, 7, 8]

```

Related task

¬† Tree traversal

First we have to create a type that supports arbitrary nesting:

```rust
use std::{vec, mem, iter};
¬†
enum List<T> {
    Node(Vec<List<T>>),
    Leaf(T),
}
¬†
impl<T> IntoIterator for List<T> {
    type Item = List<T>;
    type IntoIter = ListIter<T>;
    fn into_iter(self) -> Self::IntoIter {
        match self {
            List::Node(vec) => ListIter::NodeIter(vec.into_iter()),
            leaf @ List::Leaf(_) => ListIter::LeafIter(iter::once(leaf)),
        }
    }
}
¬†
enum ListIter<T> {
    NodeIter(vec::IntoIter<List<T>>),
    LeafIter(iter::Once<List<T>>),
}
¬†
impl<T> ListIter<T> {
    fn flatten(self) -> Flatten<T> {
        Flatten {
            stack: Vec::new(),
            curr: self,
        }
    }
}
¬†
impl<T> Iterator for ListIter<T> {
    type Item = List<T>;
    fn next(&mut self) -> Option<Self::Item> {
        match *self {
            ListIter::NodeIter(ref mut v_iter) => v_iter.next(),
            ListIter::LeafIter(ref mut o_iter) => o_iter.next(),
        }
    }
}
¬†
struct Flatten<T> {
    stack: Vec<ListIter<T>>,
    curr: ListIter<T>,
}
¬†
// Flatten code is a little messy since we are shoehorning recursion into an Iterator
impl<T> Iterator for Flatten<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        loop {
            match self.curr.next() {
                Some(list) => {
                    match list {
                        node @ List::Node(_) => {
                            self.stack.push(node.into_iter());
                            let len = self.stack.len();
                            mem::swap(&mut self.stack[len - 1], &mut self.curr);
                        }
                        List::Leaf(item) => return Some(item),
                    }
                }
                None => {
                    if let Some(next) = self.stack.pop() {
                        self.curr = next;
                    } else {
                        return None;
                    }
                }
            }
        }
    }
}
¬†
use List::*;
fn main() {
    let list = Node(vec![Node(vec![Leaf(1)]),
                         Leaf(2),
                         Node(vec![Node(vec![Leaf(3), Leaf(4)]), Leaf(5)]),
                         Node(vec![Node(vec![Node(vec![])])]),
                         Node(vec![Node(vec![Node(vec![Leaf(6)])])]),
                         Leaf(7),
                         Leaf(8),
                         Node(vec![])]);
¬†
    for elem in list.into_iter().flatten() {
        print!("{} ", elem);
    }
    println!();
¬†
}
```

Output:

```rust
1 2 3 4 5 6 7 8

```

# Compound data type<a id="sec-72"></a>

Task

Create a compound data type:

```
Point(x,y) 

```

A compound data type is one that holds multiple independent values.

Related task

¬† Enumeration

See also

Array Associative array: Creation, Iteration Collections Compound data type Doubly-linked list: Definition, Element definition, Element insertion, Traversal Linked list Queue: Definition, Usage Set Singly-linked list: Element definition, Element insertion, Traversal Stack

Structs[edit]

There are three kinds of structs in Rust, two of which would be suitable to represent a point.

C-like struct[edit]

```rust
 // Defines a generic struct where x and y can be of any type T
struct Point<T> {
    x: T,
    y: T,
}
fn main() {
    let p = Point { x: 1.0, y: 2.5 }; // p is of type Point<f64>
    println!("{}, {}", p.x, p.y);
} 
```

Tuple struct[edit]

These are basically just named tuples.

```rust
struct Point<T>(T, T);
fn main() {
    let p = Point(1.0, 2.5);
    println!("{},{}", p.0, p.1);
}
```

Tuples[edit]

```rust
 fn main() {
    let p = (0.0, 2.4);
    println!("{},{}", p.0, p.1);
}
```

# String case<a id="sec-73"></a>

Task

Take the string ¬† ¬† alphaBETA ¬† ¬† and demonstrate how to convert it to:

¬† upper-case ¬† ¬† and ¬† lower-case

Use the default encoding of a string literal or plain ASCII if there is no string literal in your language.

Show any additional case conversion functions ¬† (e.g. swapping case, capitalizing the first letter, etc.) ¬† that may be included in the library of your language.

Metrics: length

Sub-string search: Count occurrences of a substring

Multi-string operations: LCP, LCS, concatenation

Manipulation: reverse, lower- and uppercase

Works with: Rust version 1.3

```rust
fn main() {
    println!("{}", "jalape√±o".to_uppercase()); // JALAPE√ëO
    println!("{}", "JALAPE√ëO".to_lowercase()); // jalape√±o
}
```

# Towers of Hanoi<a id="sec-74"></a>

Task

Solve the ¬† Towers of Hanoi ¬† problem with recursion.

Translation of: C

```rust
fn move_(n: i32, from: i32, to: i32, via: i32) {
    if n > 0 {
        move_(n - 1, from, via, to);
        println!("Move disk from pole {} to pole {}", from, to);
        move_(n - 1, via, to, from);
    }
}
¬†
fn main() {
    move_(4, 1,2,3);
}
```

# Higher-order functions<a id="sec-75"></a>

Task

Pass a function as an argument to another function.

Related task

¬† First-class functions

Functions are first class values and identified in the type system by implementing the FnOnce, FnMut or the Fn trait which happens implicitly for functions and closures.

```rust
fn execute_with_10<F: Fn(u64) -> u64> (f: F) -> u64 {
  f(10)
}
¬†
fn square(n: u64) -> u64 {
  n*n
}
¬†
fn main() {
  println!("{}", execute_with_10(|n| n*n )); // closure
  println!("{}", execute_with_10(square));   // function
}
```

Output:

```rust
100
100
```

# Loops/Do-while<a id="sec-76"></a>

Start with a value at 0. Loop while value mod 6 is not equal to 0. Each time through the loop, add 1 to the value then print it. The loop must execute at least once.

Related tasks

¬† Loop over multiple arrays simultaneously ¬† Loops/Break ¬† Loops/Continue ¬† Loops/Do-while ¬† Loops/Downward for ¬† Loops/For ¬† Loops/For with a specified step ¬† Loops/Foreach ¬† Loops/Increment loop index within loop body ¬† Loops/Infinite ¬† Loops/N plus one half ¬† Loops/Nested ¬† Loops/While ¬† Loops/with multiple ranges ¬† Loops/Wrong ranges

Reference

Do while loop Wikipedia.

Rust does not have a do&#x2026;while loop. Instead, the keyword loop is used with a termination condition.

```rust
let mut x = 0;
¬†
loop {
    x += 1;
    println!("{}", x);
¬†
    if x¬†% 6 == 0 { break; }
}
```

# Integer comparison<a id="sec-77"></a>

Get two integers from the user.

Then, ¬† display a message if the first integer is:

¬† less than, ¬† equal to, ¬† or ¬† greater than

the second integer.

Test the condition ¬† for each case separately, ¬† so that ¬† all three comparison operators are used ¬† in the code.

Related task

¬† String comparison

Reading from stdin into a string is cumbersome at the moment, but convenience functions will be implemented in the future.

```rust
use std::io::{self, BufRead};
¬†
fn main() {
    let mut reader = io::stdin();
    let mut buffer = String::new();
    let mut lines = reader.lock().lines().take(2);
    let nums: Vec<i32>= lines.map(|string|
        string.unwrap().trim().parse().unwrap()
        ).collect();
    let a: i32 = nums[0];
    let b: i32 = nums[1];
    if a < b {
        println!("{} is less than {}" , a , b)
    } else if a == b {
        println!("{} equals {}" , a , b)
    } else if a > b {
        println!("{} is greater than {}" , a , b)
    };
}
```

# Sum of a series<a id="sec-78"></a>

Compute the ¬† nth ¬† term of a series, ¬† i.e. the sum of the ¬† n ¬† first terms of the corresponding sequence.

Informally this value, or its limit when ¬† n ¬† tends to infinity, is also called the sum of the series, thus the title of this task.

For this task, use:

{\displaystyle S<sub>n</sub>=&sum; \_{k=1}<sup>n</sup>{\frac {1}{k<sup>2</sup>}}}

and compute ¬† {\displaystyle S<sub>1000</sub>}

This approximates the ¬† zeta function ¬† for ¬† S=2, ¬† whose exact value

{\displaystyle &zeta; (2)={&pi; ^{2} \over 6}}

is the solution of the Basel problem.

```rust
const LOWER: i32 = 1;
const UPPER: i32 = 1000;
¬†
// Because the rule for our series is simply adding one, the number of terms are the number of
// digits between LOWER and UPPER
const NUMBER_OF_TERMS: i32 = (UPPER + 1) - LOWER;
fn main() {
    // Formulaic method
    println!("{}", (NUMBER_OF_TERMS * (LOWER + UPPER)) / 2);
    // Naive method
    println!("{}", (LOWER..UPPER + 1).fold(0, |sum, x| sum + x));
}
¬†
```

# Bitwise operations<a id="sec-79"></a>

Task

Write a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.

All shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.

If any operation is not available in your language, note it.

```rust
fn main() {
    let a: u8 = 105;
    let b: u8 = 91;
    println!("a      = {:0>8b}", a);
    println!("b      = {:0>8b}", b);
    println!("a | b  = {:0>8b}", a | b);
    println!("a & b  = {:0>8b}", a & b);
    println!("a ^ b  = {:0>8b}", a ^ b);
    println!("!a     = {:0>8b}",¬†!a);
    println!("a << 3 = {:0>8b}", a << 3);
    println!("a >> 3 = {:0>8b}", a >> 3);
}
```

Output:

```rust
a      = 01101001
b      = 01011011
a | b  = 01111011
a & b  = 01001001
a ^ b  = 00110010
!a     = 10010110
a << 3 = 01001000
a >> 3 = 00001101

```

# Knuth shuffle<a id="sec-80"></a>

The ¬† Knuth shuffle ¬† (a.k.a. the Fisher-Yates shuffle) ¬† is an algorithm for randomly shuffling the elements of an array.

Task[edit]

Implement the Knuth shuffle for an integer array (or, if possible, an array of any type).

Specification

Given an array items with indices ranging from 0 to last, the algorithm can be defined as follows (pseudo-code):

```
for i from last downto 1 do:
    let j = random integer in range 0 



    {\displaystyle \leq }


 j 



    {\displaystyle \leq }


 i
    swap items[i] with items[j]

```

Notes:

It modifies the input array in-place. If that is unreasonable in your programming language, you may amend the algorithm to return the shuffled items as a new array instead. The algorithm can also be amended to iterate from left to right, if that is more convenient.

Test cases

Input array Possible output arrays [] [] [10] [10] [10, 20] [10, 20] [20, 10] [10, 20, 30] [10, 20, 30] [10, 30, 20] [20, 10, 30] [20, 30, 10] [30, 10, 20] [30, 20, 10]

(These are listed here just for your convenience; no need to demonstrate them on the page.)

Related tasks

Sattolo cycle

Library: rand

```rust
use rand::Rng;
¬†
extern crate rand;
¬†
fn knuth_shuffle<T>(v: &mut [T]) {
    let mut rng = rand::thread_rng();
    let l = v.len();
¬†
    for n in 0..l {
        let i = rng.gen_range(0, l - n);
        v.swap(i, l - n - 1);
    }
}
¬†
fn main() {
    let mut v: Vec<_> = (0..10).collect();
¬†
    println!("before: {:?}", v);
    knuth_shuffle(&mut v);
    println!("after:  {:?}", v);
}
```

# Dot product<a id="sec-81"></a>

Task

Create a function/use an in-built function, to compute the ¬† dot product, ¬† also known as the ¬† scalar product ¬† of two vectors.

If possible, make the vectors of arbitrary length.

As an example, compute the dot product of the vectors:

¬† [1, ¬†3, -5] ¬† ¬† and ¬† [4, -2, -1]

If implementing the dot product of two vectors directly:

¬† each vector must be the same length ¬† multiply corresponding terms from each vector ¬† sum the products ¬† (to produce the answer)

Related task

¬† Vector products

Implemented as a simple function with check for equal length of vectors.

```rust
// alternatively, fn dot_product(a: &Vec<u32>, b: &Vec<u32>)
// but using slices is more general and rustic
fn dot_product(a: &[i32], b: &[i32]) -> Option<i32> {
    if a.len()¬†!= b.len() { return None }
    Some(
        a.iter()
            .zip( b.iter() )
            .fold(0, |sum, (el_a, el_b)| sum + el_a*el_b)
    )
}
¬†
¬†
fn main() {
    let v1 = vec![1, 3, -5];
    let v2 = vec![4, -2, -1];
¬†
    println!("{}", dot_product(&v1, &v2).unwrap());
}
```

Alternatively as a very generic function which works for any two types that can be multiplied to result in a third type which can be added with itself. Works with any argument convertible to an Iterator of known length (ExactSizeIterator).

Uses an unstable feature.

```rust
#![feature(zero_one)] // <-- unstable feature
use std::ops::{Add, Mul};
use std::num::Zero;
¬†
fn dot_product<T1, T2, U, I1, I2>(lhs: I1, rhs: I2) -> Option<U>
    where T1: Mul<T2, Output = U>,
          U: Add<U, Output = U> + Zero,
          I1: IntoIterator<Item = T1>,
          I2: IntoIterator<Item = T2>,
          I1::IntoIter: ExactSizeIterator,
          I2::IntoIter: ExactSizeIterator,
{
    let (iter_lhs, iter_rhs) = (lhs.into_iter(), rhs.into_iter());
    match (iter_lhs.len(), iter_rhs.len()) {
        (0, _) | (_, 0) => None,
        (a,b) if a¬†!= b => None,
        (_,_) => Some( iter_lhs.zip(iter_rhs)
           .fold(U::zero(), |sum, (a, b)| sum + (a * b)) )
    }
}
¬†
¬†
¬†
fn main() {
    let v1 = vec![1, 3, -5];
    let v2 = vec![4, -2, -1];
¬†
    println!("{}", dot_product(&v1, &v2).unwrap());
}
```

# Return multiple values<a id="sec-82"></a>

Task

Show how to return more than one value from a function.

Rust supports ADT, thus function can return tuple.

```rust
fn multi_hello() -> (&'static str, i32) {
    ("Hello",42)
}
¬†
fn main() {
    let (str,num)=multi_hello();
    println!("{},{}",str,num);
}
¬†
```

Output:

```rust
Hello,42

```

# Find limit of recursion<a id="sec-83"></a>

Task

Find the limit of recursion.

```rust
fn recurse(n: i32) {
    println!("depth: {}", n);
    recurse(n + 1)
}
¬†
fn main() {
    recurse(0);
}
```

Output:

```rust
...
depth: 18433
depth: 18434
depth: 18435

thread '<main>' has overflowed its stack
An unknown error occurred

To learn more, run the command again with --verbose.
```

# Accumulator factory<a id="sec-84"></a>

A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).

Rules

The detailed rules are at <http://paulgraham.com/accgensub.html> and are reproduced here for simplicity (with additions in small italic text).

Before you submit an example, make sure the function

Takes a number n and returns a function (lets call it g), that takes a number i, and returns n incremented by the accumulation of i from every call of function g(i). Although these exact function and parameter names need not be used Works for any numeric type&#x2013; i.e. can take both ints and floats and returns functions that can take both ints and floats. (It is not enough simply to convert all input to floats. An accumulator that has only seen integers must return integers.) (i.e., if the language doesn't allow for numeric polymorphism, you have to use overloading or something like that) Generates functions that return the sum of every number ever passed to them, not just the most recent. (This requires a piece of state to hold the accumulated value, which in turn means that pure functional languages can't be used for this task.) Returns a real function, meaning something that you can use wherever you could use a function you had defined in the ordinary way in the text of your program. (Follow your language's conventions here.) Doesn't store the accumulated value or the returned functions in a way that could cause them to be inadvertently modified by other code. (No global variables or other such things.) E.g. if after the example, you added the following code (in a made-up language) where the factory function is called foo: x = foo(1); x(5); foo(3); print x(2.3); It should print 8.3. (There is no need to print the form of the accumulator function returned by foo(3); it's not part of the task at all.)

Task

Create a function that implements the described rules.

It need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.

Where it is not possible to hold exactly to the constraints above, describe the deviations.

This solution is explicitly rejected by the task description. It must be possible to create the accumulator with one type (e.g. int), then accumulate another type (e.g. float) correctly.

Changing "x = foo(1.)" to "x = foo(1)" in the code below should not change the output (it does).

```rust
// rustc -V
// rustc 1.2.0-nightly (0cc99f9cc 2015-05-17) (built 2015-05-18)
¬†
use std::ops::Add;
¬†
fn foo<Num>(n: Num) -> Box<FnMut(Num) -> Num>
        where Num: Add<Output=Num> + Copy + 'static {
    let mut acc = n;
    Box::new(move |i: Num| {
        acc = acc + i;
        acc
    })
}
¬†
fn main() {
    let mut x = foo(1.);
    x(5.);
    foo(3.);
    println!("{}", x(2.3));
}
```

Output:

```rust
8.3

```

# Sum multiples of 3 and 5<a id="sec-85"></a>

Task

The objective is to write a function that finds the sum of all positive multiples of 3 or 5 below n.

Show output for n = 1000.

Extra credit: do this efficiently for n = 1e20 or higher.

```rust
¬†
extern crate rug;
¬†
use rug::Integer;
use rug::ops::Pow;
¬†
fn main() {
    for i in [3, 20, 100, 1_000].iter() {
        let ten = Integer::from(10);
        let mut limit = Integer::from(Integer::from(&ten.pow(*i as u32)) - 1);
        let mut aux_3_1 = &limit.mod_u(3u32);
        let mut aux_3_2 = Integer::from(&limit - aux_3_1);
        let mut aux_3_3 = Integer::from(&aux_3_2/3);
        let mut aux_3_4 = Integer::from(3 + aux_3_2);
        let mut aux_3_5 = Integer::from(&aux_3_3*&aux_3_4);
        let mut aux_3_6 = Integer::from(&aux_3_5/2);
¬†
        let mut aux_5_1 = &limit.mod_u(5u32);
        let mut aux_5_2 = Integer::from(&limit - aux_5_1); 
        let mut aux_5_3 = Integer::from(&aux_5_2/5);
        let mut aux_5_4 = Integer::from(5 + aux_5_2); 
        let mut aux_5_5 = Integer::from(&aux_5_3*&aux_5_4);
        let mut aux_5_6 = Integer::from(&aux_5_5/2); 
¬†
        let mut aux_15_1 = &limit.mod_u(15u32);
        let mut aux_15_2 = Integer::from(&limit - aux_15_1); 
        let mut aux_15_3 = Integer::from(&aux_15_2/15);
        let mut aux_15_4 = Integer::from(15 + aux_15_2);
        let mut aux_15_5 = Integer::from(&aux_15_3*&aux_15_4);
        let mut aux_15_6 = Integer::from(&aux_15_5/2); 
¬†
        let mut result_aux_1 = Integer::from(&aux_3_6 + &aux_5_6); 
        let mut result = Integer::from(&result_aux_1 - &aux_15_6);
¬†
        println!("Sum for 10^{}¬†: {}",i,result);
    }
}
¬†
```

Output¬†:

```rust
Sum for 10^3¬†: 233168
Sum for 10^20¬†: 2333333333333333333316666666666666666668
Sum for 10^100¬†: 23333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333331666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666668
Sum for 10^1000¬†: 23333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333331666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666668

real	0m0.002s
user	0m0.002s
sys	0m0.000s


```

# Mandelbrot set<a id="sec-86"></a>

This page uses content from Wikipedia. The original article was at Mandelbrot<sub>set</sub>. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Task

Generate and draw the Mandelbrot set.

Note that there are many algorithms to draw Mandelbrot set and there are many functions which generate it .

Dependencies: image, num-complex

```rust
extern crate image;
extern crate num_complex;
¬†
use std::fs::File;
use num_complex::Complex;
¬†
fn main() {
    let max_iterations = 256u16;
    let img_side = 800u32;
    let cxmin = -2f32;
    let cxmax = 1f32;
    let cymin = -1.5f32;
    let cymax = 1.5f32;
    let scalex = (cxmax - cxmin) / img_side as f32;
    let scaley = (cymax - cymin) / img_side as f32;
¬†
    // Create a new ImgBuf
    let mut imgbuf = image::ImageBuffer::new(img_side, img_side);
¬†
    // Calculate for each pixel
    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {
        let cx = cxmin + x as f32 * scalex;
        let cy = cymin + y as f32 * scaley;
¬†
        let c = Complex::new(cx, cy);
        let mut z = Complex::new(0f32, 0f32);
¬†
        let mut i = 0;
        for t in 0..max_iterations {
            if z.norm() > 2.0 {
                break;
            }
            z = z * z + c;
            i = t;
        }
¬†
        *pixel = image::Luma([i as u8]);
    }
¬†
    // Save image
    let fout = &mut File::create("fractal.png").unwrap();
    image::ImageLuma8(imgbuf).save(fout, image::PNG).unwrap();
}
```

# Luhn test of credit card numbers<a id="sec-87"></a>

The Luhn test is used by some credit card companies to distinguish valid credit card numbers from what could be a random selection of digits.

Those companies using credit card numbers that can be validated by the Luhn test have numbers that pass the following test:

Reverse the order of the digits in the number. Take the first, third, &#x2026; and every other odd digit in the reversed digits and sum them to form the partial sum s1 Taking the second, fourth &#x2026; and every other even digit in the reversed digits:

Multiply each digit by two and sum the digits if the answer is greater than nine to form partial sums for the even digits Sum the partial sums of the even digits to form s2

If s1 + s2 ends in zero then the original number is in the form of a valid credit card number as verified by the Luhn test.

For example, if the trial number is 49927398716:

```
Reverse the digits:
  61789372994
Sum the odd digits:
  6 + 7 + 9 + 7 + 9 + 4 = 42 = s1
The even digits:
    1,  8,  3,  2,  9
  Two times each even digit:
    2, 16,  6,  4, 18
  Sum the digits of each multiplication:
    2,  7,  6,  4,  9
  Sum the last:
    2 + 7 + 6 + 4 + 9 = 28 = s2

s1 + s2 = 70 which ends in zero which means that 49927398716 passes the Luhn test
```

Task

Write a function/method/procedure/subroutine that will validate a number with the Luhn test, and use it to validate the following numbers:

```
49927398716
49927398717
1234567812345678
1234567812345670

```

Related tasks

¬† SEDOL ¬† ISIN

```rust
struct Digits(u64);
impl Iterator for Digits {
    type Item = u64;
    fn next(&mut self) -> Option<u64> {
        let next = if self.0 == 0 { None } else { Some(self.0¬†% 10) };
        self.0 /= 10;
        next
    }
}
¬†
fn luhn_test(num: u64) -> bool {
    Digits(num).enumerate()
        .map(|(i, digit)| if (i¬†% 2) == 0 { digit } else { Digits(digit*2).sum() })
        .sum::<u64>()¬†% 10 == 0
}
¬†
fn main() {
    let nums = [49927398716, 49927398717, 1234567812345678, 1234567812345670];
    for &n in &nums {
        println!("{}: {:?}", n, luhn_test(n));
    }
}
```

Output:

```rust
49927398716: true
49927398717: false
1234567812345678: false
1234567812345670: true
```

# Copy a string<a id="sec-88"></a>

This task is about copying a string.

Task

Where it is relevant, distinguish between copying the contents of a string versus making an additional reference to an existing string.

```rust
fn main() {
    let s1 = "A String";
    let mut s2 = s1;
¬†
    s2 = "Another String";
¬†
    println!("s1 = {}, s2 = {}", s1, s2);
}
```

```rust
s1 = A String, s2 = Another String
```

# Function composition<a id="sec-89"></a>

Task

Create a function, compose, ¬† whose two arguments ¬† f ¬† and ¬† g, ¬† are both functions with one argument.

The result of compose is to be a function of one argument, (lets call the argument ¬† x), ¬† which works like applying function ¬† f ¬† to the result of applying function ¬† g ¬† to ¬† x.

Example

```
compose(f, g) (x) = f(g(x))

```

Reference: Function composition

Hint: In some languages, implementing compose correctly requires creating a closure.

In order to return a closure (anonymous function) in Stable Rust, it must be wrapped in a layer of indirection via a heap allocation. However, there is a feature coming down the pipeline (currently available in Nightly) which makes this possible. Both of the versions below are in the most general form i.e. their arguments may be functions or closures with the only restriction being that the output of g is the same type as the input of f.

Stable[edit]

Function is allocated on the heap and is called via dynamic dispatch

```rust
fn compose<'a,F,G,T,U,V>(f: F, g: G) -> Box<Fn(T) -> V + 'a>
    where F: Fn(U) -> V + 'a,
          G: Fn(T) -> U + 'a,
{
   Box::new(move |x| f(g(x)))
}
```

Nightly[edit]

Function is returned on the stack and is called via static dispatch (monomorphized)

```rust
#![feature(conservative_impl_trait)]
fn compose<'a,F,G,T,U,V>(f: F, g: G) -> impl Fn(T) -> V + 'a
    where F: Fn(U) -> V + 'a,
          G: Fn(T) -> U + 'a,
{
   move |x| f(g(x))
}
```

# Primality by trial division<a id="sec-90"></a>

Task

Write a boolean function that tells whether a given integer is prime.

Remember that ¬† 1 ¬† and all non-positive numbers are not prime.

Use trial division.

Even numbers over two may be eliminated right away.

A loop from ¬† 3 ¬† to ¬† ‚àö¬†n¬† ¬† will suffice, ¬† but other loops are allowed.

Related tasks

¬† count in factors ¬† prime decomposition ¬† AKS test for primes ¬† factors of an integer ¬† Sieve of Eratosthenes ¬† factors of a Mersenne number ¬† trial factoring of a Mersenne number ¬† partition an integer X into N primes ¬† sequence of primes by Trial Division

```rust
fn is_prime(n: u64) -> bool {
    match n {
        0 | 1 => false,
        2 => true,
        _even if n¬†% 2 == 0 => false,
        _ => {
            let sqrt_limit = (n as f64).sqrt() as u64;
            (3..=sqrt_limit).step_by(2).find(|i| n¬†% i == 0).is_none()
        }
    }
}
¬†
fn main() {
    for i in 1..30 {
        if is_prime(i) {
            println!("{} is prime!", i);
        }
    }
}
```

Output:

```rust
2 is prime!
3 is prime!
5 is prime!
7 is prime!
11 is prime!
13 is prime!
17 is prime!
19 is prime!
23 is prime!
29 is prime!
```

# Include a file<a id="sec-91"></a>

Task

Demonstrate the language's ability to include source code from other files.

The compiler will include either a 'test.rs' or a 'test/mod.rs' (if the first one doesn't exist) file.

```rust
mod test
¬†
fn main() {
    test::some_function();
}
```

Additionally, third-party libraries (called crates in rust) can be declared thusly:

```rust
extern crate foo;
fn main() {
    foo::some_function();
}
```

# Loops/N plus one half<a id="sec-92"></a>

Quite often one needs loops which, in the last iteration, execute only part of the loop body.

Goal

Demonstrate the best way to do this.

Task

Write a loop which writes the comma-separated list

```
1, 2, 3, 4, 5, 6, 7, 8, 9, 10

```

using separate output statements for the number and the comma from within the body of the loop.

Related tasks

¬† Loop over multiple arrays simultaneously ¬† Loops/Break ¬† Loops/Continue ¬† Loops/Do-while ¬† Loops/Downward for ¬† Loops/For ¬† Loops/For with a specified step ¬† Loops/Foreach ¬† Loops/Increment loop index within loop body ¬† Loops/Infinite ¬† Loops/N plus one half ¬† Loops/Nested ¬† Loops/While ¬† Loops/with multiple ranges ¬† Loops/Wrong ranges ¬† Loops/Wrong ranges

```rust
fn main() {
    for i in 1..11 {
        print!("{}{}", i, if i == 10 {"\n"} else {", "});
    }
}
```

# Determine if a string is numeric<a id="sec-93"></a>

Task

Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.

```rust
// This function is not limited to just numeric types but rather anything that implements the FromStr trait.
fn parsable<T: FromStr>(s: &str) -> bool {
    s.parse::<T>().is_ok()
}
```

# Range extraction<a id="sec-94"></a>

A format for expressing an ordered list of integers is to use a comma separated list of either

individual integers Or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. (The range includes all integers in the interval including both endpoints)

The range syntax is to be used only for, and for every range that expands to more than two values.

Example The list of integers:

-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20

Is accurately expressed by the range expression:

-6,-3-1,3-5,7-11,14,15,17-20

(And vice-versa).

Task

Create a function that takes a list of integers in increasing order and returns a correctly formatted string in the range format. Use the function to compute and print the range formatted version of the following ordered list of integers. (The correct answer is: 0-2,4,6-8,11,12,14-25,27-33,35-39.)

```
 0,  1,  2,  4,  6,  7,  8, 11, 12, 14,
15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
25, 27, 28, 29, 30, 31, 32, 33, 35, 36,
37, 38, 39

```

Show the output of your program.

Related task

¬† Range expansion

Iterators are very Rustic. This solution is generic for all numeric types.

```rust
use std::ops::Add;
¬†
struct RangeFinder<'a, T: 'a> {
    index: usize,
    length: usize,
    arr: &'a [T],
}
¬†
impl<'a, T> Iterator for RangeFinder<'a, T> where T: PartialEq + Add<i8, Output=T> + Copy {
    type Item = (T,  Option<T>);
    fn next(&mut self) -> Option<Self::Item> {
        if self.index == self.length {
            return None;
        }
        let lo = self.index;
        while self.index < self.length - 1 && self.arr[self.index + 1] == self.arr[self.index] + 1 {
            self.index += 1
        }
        let hi = self.index;
        self.index += 1;
        if hi - lo > 1 {
            Some((self.arr[lo], Some(self.arr[hi])))
        } else {
            if hi - lo == 1 {
                self.index -= 1
            }
            Some((self.arr[lo], None))
        }
    }
}
¬†
impl<'a, T> RangeFinder<'a, T> {
    fn new(a: &'a [T]) -> Self {
        RangeFinder {
            index: 0,
            arr: a,
            length: a.len(),
        }
    }
}
¬†
fn main() {
    let input_numbers¬†: &[i8] = &[0,  1,  2,  4,  6,  7,  8, 11, 12, 14,
                                  15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
                                  25, 27, 28, 29, 30, 31, 32, 33, 35, 36,
                                  37, 38, 39];
    for (i, (lo, hi)) in RangeFinder::new(&input_numbers).enumerate() {
        if i > 0 {print!(",")}
        print!("{}", lo);
        if hi.is_some() {print!("-{}", hi.unwrap())}
    }
    println!("");
}
```

Output:

```rust
0-2,4,6-8,11,12,14-25,27-33,35-39
```

Note: You could make the above solution even a little more generic in Nightly Rust (which is version 1.6 at the time of writing) by making the following additions:

Add this to the top of the file:

```rust
#![feature(zero_one)]
use std::num::One;
```

Changing this line:

```rust
impl<'a, T> Iterator for RangeFinder<'a, T> where T: PartialEq + Add<i8, Output=T> + Copy {
```

to this:

```rust
impl<'a, T> Iterator for RangeFinder<'a, T> where T: PartialEq + Add<T, Output=T> + Copy + One {
```

And this line:

```rust
while self.index < self.length - 1 && self.arr[self.index + 1] == self.arr[self.index] + 1 {
```

to this:

```rust
while self.index < self.length - 1 && self.arr[self.index + 1] == self.arr[self.index] + T::one() {
```

# Leap year<a id="sec-95"></a>

See Also

Leap year (wiki)

```rust
fn is_leap(year: i32) -> bool {
    let factor = |x| year¬†% x == 0;
    factor(4) && (!factor(100) || factor(400))
}
```

# Classes<a id="sec-96"></a>

In object-oriented programming class is a set (a transitive closure) of types bound by the relation of inheritance. It is said that all types derived from some base type T and the type T itself form a class T.

The first type T from the class T sometimes is called the root type of the class.

A class of types itself, as a type, has the values and operations of its own. The operations of are usually called methods of the root type. Both operations and values are called polymorphic.

A polymorphic operation (method) selects an implementation depending on the actual specific type of the polymorphic argument.

The action of choice the type-specific implementation of a polymorphic operation is called dispatch. Correspondingly, polymorphic operations are often called dispatching or virtual. Operations with multiple arguments and/or the results of the class are called multi-methods. A further generalization of is the operation with arguments and/or results from different classes.

single-dispatch languages are those that allow only one argument or result to control the dispatch. Usually it is the first parameter, often hidden, so that a prefix notation x.f() is used instead of mathematical f(x). multiple-dispatch languages allow many arguments and/or results to control the dispatch.

A polymorphic value has a type tag indicating its specific type from the class and the corresponding specific value of that type. This type is sometimes called the most specific type of a [polymorphic] value. The type tag of the value is used in order to resolve the dispatch. The set of polymorphic values of a class is a transitive closure of the sets of values of all types from that class.

In many OO languages the type of the class of T and T itself are considered equivalent. In some languages they are distinct (like in Ada). When class T and T are equivalent, there is no way to distinguish polymorphic and specific values.

Task

Create a basic class with a method, a constructor, an instance variable and how to instantiate it.

```rust
¬†
struct MyClass {
    variable: i32, // member variable = instance variable
}
¬†
impl MyClass {
    // member function = method, with its implementation
    fn some_method(&mut self) {
        self.variable = 1;
    }
¬†
    // constructor, with its implementation
    fn new() -> MyClass {
        // Here could be more code.
        MyClass { variable: 0 }
    }
}
¬†
fn main () {
    // Create an instance in the stack.
    let mut instance = MyClass::new();
¬†
    // Create an instance in the heap.
    let mut p_instance = Box::<_>::new(MyClass::new());
¬†
    // Invoke method on both istances,
    instance.some_method();
    p_instance.some_method();
¬†
    // Both instances are automatically deleted when their scope ends.
}
¬†
```

# Associative array/Iteration<a id="sec-97"></a>

Show how to iterate over the key-value pairs of an associative array, and print each pair out.

Also show how to iterate just over the keys, or the values, if there is a separate way to do that in your language.

See also

Array Associative array: Creation, Iteration Collections Compound data type Doubly-linked list: Definition, Element definition, Element insertion, Traversal Linked list Queue: Definition, Usage Set Singly-linked list: Element definition, Element insertion, Traversal Stack

```rust
use std::collections::HashMap;
fn main() {
    let mut olympic_medals = HashMap::new();
    olympic_medals.insert("United States", (1072, 859, 749));
    olympic_medals.insert("Soviet Union", (473, 376, 355));
    olympic_medals.insert("Great Britain", (246, 276, 284));
    olympic_medals.insert("Germany", (252, 260, 270));
    for (country, medals) in olympic_medals {
        println!("{} has had {} gold medals, {} silver medals, and {} bronze medals", 
               country, medals.0, medals.1, medals.2);
¬†
    }
}
```

Output:

Note that HashMap does not preserve order (if this is important, std::collections::BTreeMap is what you want.)

```rust
Germany has had 252 gold medals, 260 silver medals, and 270 bronze medals
United States has had 1072 gold medals, 859 silver medals, and 749 bronze medals
Soviet Union has had 473 gold medals, 376 silver medals, and 355 bronze medals
Great Britain has had 246 gold medals, 276 silver medals, and 284 bronze medals

```

# Identity matrix<a id="sec-98"></a>

Task

Build an ¬† identity matrix ¬† of a size known at run-time.

An identity matrix is a square matrix of size n √ó n, where the diagonal elements are all 1s (ones), and all the other elements are all 0s (zeroes).

{\displaystyle I<sub>n</sub>={\begin{bmatrix}1&0&0&&ctdot; &0\\\\0&1&0&&ctdot; &0\\\\0&0&1&&ctdot; &0\\\\\vdots &\vdots &\vdots &\ddots &\vdots \\\\0&0&0&&ctdot; &1\\\\\end{bmatrix}}}

Related tasks

¬† Spiral matrix ¬† Zig-zag matrix ¬† Ulam<sub>spiral</sub><sub>(for<sub>primes</sub>)</sub>

Run with command-line containing the matrix size.

```rust
¬†
extern crate num;
struct Matrix<T> {
    data: Vec<T>,
    size: usize,
}
¬†
impl<T> Matrix<T>
where
    T: num::Num + Clone + Copy,
{
    fn new(size: usize) -> Self {
        Self {
            data: vec![T::zero(); size * size],
            size: size,
        }
    }
    fn get(&mut self, x: usize, y: usize) -> T {
        self.data[x + self.size * y]
    }
    fn identity(&mut self) {
        for (i, item) in self.data.iter_mut().enumerate() {
            *item = if i¬†% (self.size + 1) == 0 {
                T::one()
            } else {
                T::zero()
            }
        }
    }
}
¬†
fn main() {
    let size = std::env::args().nth(1).unwrap().parse().unwrap();
    let mut matrix = Matrix::<i32>::new(size);
    matrix.identity();
    for y in 0..size {
        for x in 0..size {
            print!("{} ", matrix.get(x, y));
        }
        println!();
    }
}
¬†
```

# Loops/Downward for<a id="sec-99"></a>

Task

Write a ¬† for ¬† loop which writes a countdown from ¬† 10 ¬† to ¬† 0.

Related tasks

¬† Loop over multiple arrays simultaneously ¬† Loops/Break ¬† Loops/Continue ¬† Loops/Do-while ¬† Loops/Downward for ¬† Loops/For ¬† Loops/For with a specified step ¬† Loops/Foreach ¬† Loops/Increment loop index within loop body ¬† Loops/Infinite ¬† Loops/N plus one half ¬† Loops/Nested ¬† Loops/While ¬† Loops/with multiple ranges ¬† Loops/Wrong ranges

```rust
fn main() {
    for i in (1..10+1).rev() {
        println!("{}", i);
    }
}
```

# Perfect numbers<a id="sec-100"></a>

Write a function which says whether a number is perfect.

A perfect number is a positive integer that is the sum of its proper positive divisors excluding the number itself.

Equivalently, a perfect number is a number that is half the sum of all of its positive divisors (including itself).

Note: ¬† The faster ¬† Lucas-Lehmer test ¬† is used to find primes of the form ¬† 2n-1, ¬† all known perfect numbers can be derived from these primes using the formula ¬† (2n - 1) √ó 2n - 1.

It is not known if there are any odd perfect numbers (any that exist are larger than 102000).

The number of ¬† known ¬† perfect numbers is ¬† 50 ¬† (as of September, 2018), ¬† and the largest known perfect number contains over 46 million decimal digits.

See also ¬† Rational Arithmetic ¬† Perfect numbers on OEIS ¬† Odd Perfect showing the current status of bounds on odd perfect numbers.

```rust
¬†
fn main ( ) {
  fn factor_sum(n: i32) -> i32 {
      let mut v = Vec::new(); //create new empty array
      for  x in 1..n-1 {      //test vaules 1 to n-1
        if n%x == 0 {   //if current x is a factor of n
          v.push(x);      //add x to the array
        }
      }
    let mut sum = v.iter().sum(); //iterate over array and sum it up 
    return sum;
    }
¬†
    fn perfect_nums(n: i32) {
      for x in 2..n {       //test numbers from 1-n
        if factor_sum(x) == x {//call factor_sum on each value of x, if return value is = x
          println!("{} is a perfect number.", x); //print value of x 
        }
      }
    }
    perfect_nums(10000);
}
¬†
```

# Y combinator<a id="sec-101"></a>

In strict functional programming and the lambda calculus, functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions. This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.

The Y combinator is itself a stateless function that, when applied to another stateless function, returns a recursive version of the function. The Y combinator is the simplest of the class of such functions, called fixed-point combinators.

Task

Define the stateless Y combinator and use it to compute factorials and Fibonacci numbers from other stateless functions or lambda expressions.

Cf

Jim Weirich: Adventures in Functional Programming

Works with: Rust version 1.26.0 stable

```rust
¬†
//! A simple implementation of the Y Combinator
// Œªf.(Œªx.xx)(Œªx.f(xx))
// <=> Œªf.(Œªx.f(xx))(Œªx.f(xx))
¬†
// CREDITS: A better version of the previous code that was posted here, with detailed explanation.
// See <y> and also <y_apply>.
¬†
// A function type that takes its own type as an input is an infinite recursive type.
// We introduce a trait that will allow us to have an input with the same type as self, and break the recursion.
// The input is going to be a trait object that implements the desired function in the interface.
// NOTE: We will be coercing a reference to a closure into this trait object.
trait Apply<T, R> {
    fn apply( &self, &Apply<T, R >, T ) -> R;
}
¬†
// In Rust, closures fall into three kinds: FnOnce, FnMut and Fn.
// FnOnce assumed to be able to be called just once if it is not Clone. It is impossible to
// write recursive FnOnce that is not Clone.
// All FnMut are also FnOnce, although you can call them multiple times, they are not allow to
// have a reference to themselves. So it is also not possible to write recursive FnMut closures
// that is not Clone.
// All Fn are also FnMut, and all closures of Fn are also Clone. However, programmers can create
// Fn objects that are not Clone
// The following address all closures that is Clone, and those are Fn.
impl<T, R, F> Apply<T, R> for F where F: FnOnce( &Apply<T, R>, T ) -> R + Clone {
    fn apply( &self, f: &Apply<T, R>, t: T ) -> R {
        (self.clone())( f, t )
¬†
        // If we were to pass in self as f, we get -
        // NOTE: Each letter is an individual symbol.
        // Œªf.Œªt.sft
        // => Œªs.Œªt.sst [s/f]
        // => Œªs.ss
    }
}
//This will work for all Fn objects, not just closures
//And it is a little bit more efficient for Fn closures as it do not clone itself.
//However under 1.26 it is not possible to define both. We will
//need to wait for specialization.
//impl<T, R, F> Apply<T, R> for F where F: Fn( &Apply<T, R>, T ) -> R {
//    fn apply( &self, f: &Apply<T, R>, t: T ) -> R {
//        self( f, t )
//}
//Before 1.26 we have some limitations and so we need some workarounds. But now impl Trait is stable and we can
// write the following:
fn y<T,R>(f:impl FnOnce(&Fn(T) -> R, T) -> R + Clone) -> impl FnOnce(T) -> R {
   |t| (|x: &Apply<T,R>,y| x.apply(x,y))
       (&move |x:&Apply<T,R>,y| f(&|z| x.apply(x,z), y), t)
¬†
    // NOTE: Each letter is an individual symbol.
    // (Œªx.(Œªy.xxy))(Œªx.(Œªy.f(Œªz.xxz)y))t
    // => (Œªx.xx)(Œªx.f(xx))t
    // => (Yf)t
}
¬†
//Previous version removed as they are just hacks when impl Trait is not available.
¬†
fn fac( n: usize ) -> usize {
    let almost_fac = |f: &Fn( usize ) -> usize, x| if x == 0 { 1 } else { x * f( x - 1 ) };
    let fac = y( almost_fac );
    fac( n )
}
¬†
fn fib( n: usize ) -> usize {
    let almost_fib = |f: &Fn( usize ) -> usize, x| if x < 2 { 1 } else { f( x - 2 ) + f( x - 1 ) };
    let fib = y( almost_fib );
    fib( n )
}
¬†
fn optimal_fib( n: usize ) -> usize {
    let almost_fib = |f: &Fn( (usize,usize,usize) ) -> usize, (i0,i1,x)| 
    {
        match x {
            0 => i0,
            1 => i1,
            x => f((i1,i0+i1, x-1))
        }        
    };
    let fib = |x|y( almost_fib )((1,1,x));
    fib( n )
}
¬†
fn main() {
    println!( "{}", fac( 10 ) );
    println!( "{}", fib( 10 ) );
    println!( "{}", optimal_fib( 10 ) );
}
¬†
```

Output:

```rust
3628800
89
89
```

# Matrix multiplication<a id="sec-102"></a>

Task

Multiply two matrices together.

They can be of any dimensions, so long as the number of columns of the first matrix is equal to the number of rows of the second matrix.

```rust
¬†
struct Matrix {
    dat: [[f32; 3]; 3]
}
¬†
impl Matrix {
    pub fn mult_m(a: Matrix, b: Matrix) -> Matrix
    {
        let mut out = Matrix {
            dat: [[0., 0., 0.],
                  [0., 0., 0.],
                  [0., 0., 0.]
                  ]
        };
¬†
        for i in 0..3{
            for j in 0..3 {
                for k in 0..3 {
                    out.dat[i][j] += a.dat[i][k] * b.dat[k][j];
                }
            }
        }
¬†
        out
    }
¬†
    pub fn print(self)
    {
        for i in 0..3 {
            for j in 0..3 {
                print!("{} ", self.dat[i][j]);
            }
            print!("\n");
        }
    }
}
¬†
fn main()
{
    let  a = Matrix {
        dat: [[1., 2., 3.],
              [4., 5., 6.],
              [7., 8., 9.]
              ]
    };
¬†
    let  b = Matrix {
        dat: [[1., 0., 0.],
              [0., 1., 0.],
              [0., 0., 1.]]
    };
¬†
¬†
¬†
        let c = Matrix::mult_m(a, b);
¬†
¬†
    c.print();
}
¬†
¬†
```

# Null object<a id="sec-103"></a>

Null (or nil) is the computer science concept of an undefined or unbound object. Some languages have an explicit way to access the null object, and some don't. Some languages distinguish the null object from undefined values, and some don't.

Task

Show how to access null in your language by checking to see if an object is equivalent to the null object.

This task is not about whether a variable is defined. The task is about "null"-like values in various languages, which may or may not be related to the defined-ness of variables in your language.

```rust
// If an option may return null - or nothing - in Rust, it's wrapped
// in an Optional which may return either the type of object specified
// in <> or None. We can check this using .is_some() and .is_none() on
// the Option.
¬†
fn check_number(num: &Option<u8>) {
    if num.is_none() {
        println!("Number is: None");
    } else {
        println!("Number is: {}", num.unwrap());
    }
}
¬†
fn main() {
    let mut possible_number: Option<u8> = None;
    check_number(&possible_number);
¬†
    possible_number = Some(31);
    check_number(&possible_number);
}
```

# Sort an integer array<a id="sec-104"></a>

Sort an array (or list) of integers in ascending numerical order.

Task

Use a sorting facility provided by the language/library if possible.

Uses merge sort in place (undocumented), allocating ~2\*n memory where n is a length of an array.

```rust
fn main() {
    let mut a = vec!(9, 8, 7, 6, 5, 4, 3, 2, 1, 0);
¬†
    a.sort();
    println!("{:?}", a);
}
```

# Execute a system command<a id="sec-105"></a>

Task

Run either the ¬† ls ¬† system command ¬† (dir ¬† on Windows), ¬† or the ¬† pause ¬† system command.

Related task

Get system command output

```rust
use std::process::Command;
fn main() {
    let output = Command::new("ls").output().unwrap_or_else(|e| {
        panic!("failed to execute process: {}", e)
    });
    println!("{}", String::from_utf8_lossy(&output.stdout));
}
¬†
```

# Read entire file<a id="sec-106"></a>

Task

Load the entire contents of some text file as a single string variable.

If applicable, discuss: encoding selection, the possibility of memory-mapping.

Of course, in practice one should avoid reading an entire file at once if the file is large and the task can be accomplished incrementally instead (in which case check File IO); this is for those cases where having the entire file is actually what is wanted.

```rust
use std::fs::File;
use std::io::Read;
¬†
fn main() {
    let mut file = File::open("somefile.txt").unwrap();
¬†
    let mut contents: Vec<u8> = Vec::new();
    // Returns amount of bytes read and append the result to the buffer
    let result = file.read_to_end(&mut contents).unwrap();
    println!("Read {} bytes", result);
¬†
    // To print the contents of the file
    let filestr = String::from_utf8(contents).unwrap();
    println!("{}", filestr);
}
```

# Program termination<a id="sec-107"></a>

Task

Show the syntax for a complete stoppage of a program inside a ¬† conditional.

This includes all threads/processes which are part of your program.

Explain the cleanup (or lack thereof) caused by the termination (allocated memory, database connections, open files, object finalizers/destructors, run-on-exit hooks, etc.).

Unless otherwise described, no special cleanup outside that provided by the operating system is provided.

Return statement[edit]

A return statement executed in the main() function will exit the program.

```rust
fn main() {
    println!("The program is running");
    return;
    println!("This line won't be printed");
}
```

Exit function[edit]

You can run std::process::exit from anywhere in the program in order to exit. This will work from the main function as well as any other function or file.

```rust
fn main() {
    if problem {
        std::process::exit(1); // 1 is the exit code
    }
}
```

Panics[edit]

A panic in Rust will terminate the current thread. If the panic is in the main thread, the program will exit. If the panic is from another thread; that thread will terminate and the program, along with the other threads, will keep running.

```rust
fn main() {
    println!("The program is running");
    panic!("A runtime panic occured");
    println!("This line won't be printed");
}
```

Because of the panic, the last line will not run. If the panic happened in another thread, the program could keep running.

Panic Inside a Thread

```rust
use std::thread;
¬†
fn main() {
    println!("The program is running");
¬†
    thread::spawn(move|| {
        println!("This is the second thread");
        panic!("A runtime panic occured");
    }).join();
¬†
    println!("This line should be printed");
}
```

Now the panic will be contained inside the background thread and will not affect the rest of the program.

# Matrix transposition<a id="sec-108"></a>

Transpose an arbitrarily sized rectangular Matrix.

```rust
¬†
struct Matrix {
    dat: [[i32; 3]; 3]
}
¬†
¬†
¬†
impl Matrix {
    pub fn transpose_m(a: Matrix) -> Matrix
    {
        let mut out = Matrix {
            dat: [[0, 0, 0],
                  [0, 0, 0],
                  [0, 0, 0]
                  ]
        };
¬†
        for i in 0..3{
            for j in 0..3{
¬†
                    out.dat[i][j] = a.dat[j][i];
            }
        }
¬†
        out
    }
¬†
    pub fn print(self)
    {
        for i in 0..3 {
            for j in 0..3 {
                print!("{} ", self.dat[i][j]);
            }
            print!("\n");
        }
    }
}
¬†
fn main()
{
    let  a = Matrix {
        dat: [[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9] ]
    };
¬†
let c = Matrix::transpose_m(a);
    c.print();
}
¬†
```

# Sum of squares<a id="sec-109"></a>

Task

Write a program to find the sum of squares of a numeric vector.

The program should work on a zero-length vector (with an answer of ¬† 0).

Related task

¬† Mean

```rust
fn sq_sum(v: &[f64]) -> f64 {
    v.iter().fold(0., |sum, &num| sum + num*num)
}
¬†
fn main() {
    let v = vec![3.0, 1.0, 4.0, 1.0, 5.5, 9.7];
    println!("{}", sq_sum(&v));
¬†
    let u¬†: Vec<f64> = vec![];
    println!("{}", sq_sum(&u));
}
```

# Literals/Integer<a id="sec-110"></a>

Some programming languages have ways of expressing integer literals in bases other than the normal base ten.

Task

Show how integer literals can be expressed in as many bases as your language allows.

Note: ¬† this should not involve the calling of any functions/methods, but should be interpreted by the compiler or interpreter as an integer written to a given base.

Also show any other ways of expressing literals, e.g. for different types of integers.

Related task

¬† Literals/Floating point

```rust
10     // Decimal
0b10   // Binary
0x10   // Hexadecimal
0o10   // Octal
1_000  // Underscores may appear anywhere in the numeric literal for clarity
10_i32 // The type (in this case i32, a 32-bit signed integer) may also be appended.
10i32  // With or without underscores
```

# Logical operations<a id="sec-111"></a>

Task

Write a function that takes two logical (boolean) values, and outputs the result of "and" and "or" on both arguments as well as "not" on the first arguments.

If the programming language doesn't provide a separate type for logical values, use the type most commonly used for that purpose.

If the language supports additional logical operations on booleans such as XOR, list them as well.

Works with: Rust version 1.1

```rust
¬†
fn boolean_ops(a: bool, b: bool) {
    println!("{} and {} -> {}", a, b, a && b);
    println!("{} or {} -> {}", a, b, a || b);
    println!("{} xor {} -> {}", a, b, a ^ b);
    println!("not {} -> {}\n", a,¬†!a);
}
¬†
fn main() {
    boolean_ops(true, true);
    boolean_ops(true, false);
    boolean_ops(false, true);
    boolean_ops(false, false)
}
¬†
```

The Boolean operators || and && are more efficient versions of | and & in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression.

# Catalan numbers<a id="sec-112"></a>

This page uses content from Wikipedia. The original article was at Catalan numbers. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Catalan numbers are a sequence of numbers which can be defined directly:

{\displaystyle C<sub>n</sub>={\frac {1}{n+1}}{2n \choose n}={\frac {(2n)!}{(n+1)!\\,n!}}\qquad {\mbox{ for }}n&ge; 0.}

Or recursively:

{\displaystyle C<sub>0</sub>=1\quad {\mbox{and}}\quad C<sub>n+1</sub>=&sum; \_{i=0}<sup>n</sup>C<sub>i</sub>\\,C<sub>n-i</sub>\quad {\text{for }}n&ge; 0;}

Or alternatively (also recursive):

{\displaystyle C<sub>0</sub>=1\quad {\mbox{and}}\quad C<sub>n</sub>={\frac {2(2n-1)}{n+1}}C<sub>n-1</sub>,}

Task

Implement at least one of these algorithms and print out the first 15 Catalan numbers with each.

Memoization ¬† is not required, but may be worth the effort when using the second method above.

Related tasks

Catalan numbers/Pascal's triangle Evaluate binomial coefficients

```rust
fn c_n(n: u64) -> u64 {
    match n {
        0 => 1,
        _ => c_n(n - 1) * 2 * (2 * n - 1) / (n + 1)
    }
}
¬†
fn main() {
    for i in 1..16 {
        println!("c_n({}) = {}", i, c_n(i));
    }
}
```

Output:

```rust
c(1) = 1
c(2) = 2
c(3) = 5
c(4) = 14
c(5) = 42
c(6) = 132
c(7) = 429
c(8) = 1430
c(9) = 4862
c(10) = 16796
c(11) = 58786
c(12) = 208012
c(13) = 742900
c(14) = 2674440
c(15) = 9694845
```

# Integer sequence<a id="sec-113"></a>

Task

Create a program that, when run, would display all integers from ¬† 1 ¬† to ¬† ‚àû ¬† (or any relevant implementation limit), ¬† in sequence ¬† (i.e. ¬† 1, 2, 3, 4, etc) ¬† if given enough time.

An example may not be able to reach arbitrarily-large numbers based on implementations limits. ¬† For example, if integers are represented as a 32-bit unsigned value with 0 as the smallest representable value, the largest representable value would be 4,294,967,295. ¬† Some languages support arbitrarily-large numbers as a built-in feature, while others make use of a module or library.

If appropriate, provide an example which reflect the language implementation's common built-in limits as well as an example which supports arbitrarily large numbers, and describe the nature of such limitations‚Äîor lack thereof.

Works with: Rust 1.2

```rust
fn main() {
    for i in 0.. {
        println!("{}", i);
    }
}
```

Looping endlessly:

```rust
extern crate num;
¬†
use num::bigint::BigUint;
use num::traits::{One,Zero};
¬†
fn main() {
    let mut i: BigUint = BigUint::one();
    loop {
        println!("{}", i);
        i = i + BigUint::one();
    }
}
```

# Levenshtein distance<a id="sec-114"></a>

This page uses content from Wikipedia. The original article was at Levenshtein distance. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

In information theory and computer science, the Levenshtein distance is a metric for measuring the amount of difference between two sequences (i.e. an edit distance). The Levenshtein distance between two strings is defined as the minimum number of edits needed to transform one string into the other, with the allowable edit operations being insertion, deletion, or substitution of a single character.

Example

The Levenshtein distance between "kitten" and "sitting" is 3, since the following three edits change one into the other, and there isn't a way to do it with fewer than three edits:

¬† kitten ¬† sitten ¬† (substitution of 'k' with 's') ¬† sitten ¬† sittin ¬† (substitution of 'e' with 'i') ¬† sittin ¬† sitting ¬† (insert 'g' at the end).

The Levenshtein distance between ¬† "rosettacode", ¬† "raisethysword" ¬† is ¬† 8.

The distance between two strings is same as that when both strings are reversed.

Task;

Implements a Levenshtein distance function, or uses a library function, to show the Levenshtein distance between ¬† "kitten" ¬† and ¬† "sitting".

Related task

¬† Longest common subsequence

Implementation of the wikipedia algorithm.

Works with: Rust version 1.1

```rust
fn main() {
    println!("{}", levenshtein_distance("kitten", "sitting"));
    println!("{}", levenshtein_distance("saturday", "sunday"));
    println!("{}", levenshtein_distance("rosettacode", "raisethysword"));
}
¬†
fn levenshtein_distance(word1: &str, word2: &str) -> usize {
    let w1 = word1.chars().collect::<Vec<_>>();
    let w2 = word2.chars().collect::<Vec<_>>();
¬†
    let word1_length = w1.len() + 1;
    let word2_length = w2.len() + 1;
¬†
    let mut matrix = vec![vec![0]];
¬†
    for i in 1..word1_length { matrix[0].push(i); }
    for j in 1..word2_length { matrix.push(vec![j]); }
¬†
    for j in 1..word2_length {
        for i in 1..word1_length {
            let x: usize = if w1[i-1] == w2[j-1] {
                matrix[j-1][i-1]
            } else {
                1 + std::cmp::min(
                        std::cmp::min(matrix[j][i-1], matrix[j-1][i])
                        , matrix[j-1][i-1])
            };
            matrix[j].push(x);
        }
    }
    matrix[word2_length-1][word1_length-1]
}
```

Output:

```rust
3
3
8
```

# Cumulative standard deviation<a id="sec-115"></a>

Task[edit]

Write a stateful function, class, generator or co-routine that takes a series of floating point numbers, one at a time, and returns the running standard deviation of the series.

The task implementation should use the most natural programming style of those listed for the function in the implementation language; the task must state which is being used.

Do not apply Bessel's correction; the returned standard deviation should always be computed as if the sample seen so far is the entire population.

Test case

Use this to compute the standard deviation of this demonstration set, {\displaystyle \\{2,4,4,4,5,5,7,9\\}} , which is {\displaystyle 2} .

Related tasks

Random numbers

Tasks for calculating statistical measures

in one go moving (sliding window) moving (cumulative) Mean Arithmetic Statistics/Basic Averages/Arithmetic mean Averages/Pythagorean means

Averages/Simple moving average

Geometric Averages/Pythagorean means

Harmonic Averages/Pythagorean means

Quadratic Averages/Root mean square

Circular Averages/Mean angle Averages/Mean time of day

Median Averages/Median

Mode Averages/Mode

Standard deviation Statistics/Basic

Cumulative standard deviation

Translation of: Java

```rust
pub struct CumulativeStandardDeviation {
    n: f64,
    sum: f64,
    sum_sq: f64
}
¬†
impl CumulativeStandardDeviation {
    pub fn new() -> Self {
        CumulativeStandardDeviation {
            n: 0.,
            sum: 0.,
            sum_sq: 0.
        }
    }
¬†
    fn push(&mut self, x: f64) -> f64 {
        self.n += 1.;
        self.sum += x;
        self.sum_sq += x * x;
¬†
        (self.sum_sq / self.n - self.sum * self.sum / self.n / self.n).sqrt()
    }
}
¬†
fn main() {
    let nums = [2, 4, 4, 4, 5, 5, 7, 9];
¬†
    let mut cum_stdev = CumulativeStandardDeviation::new();
    for num in nums.iter() {
        println!("{}", cum_stdev.push(*num as f64));
    }
}
```

Output:

```rust
0
1
0.9428090415820626
0.8660254037844386
0.9797958971132708
1
1.399708424447531
2

```

# Evaluate binomial coefficients<a id="sec-116"></a>

This programming task, is to calculate ANY binomial coefficient.

However, it has to be able to output ¬† {\displaystyle {\binom {5}{3}}} , ¬† which is ¬† 10.

This formula is recommended:

{\displaystyle {\binom {n}{k}}={\frac {n!}{(n-k)!k!}}={\frac {n(n-1)(n-2)\ldots (n-k+1)}{k(k-1)(k-2)\ldots 1}}}

See Also:

Combinations and permutations Pascal's triangle

The number of samples of size k from n objects. With combinations and permutations generation tasks. Order Unimportant Order Important Without replacement {\displaystyle {\binom {n}{k}}=<sup>n</sup>\operatorname {C} \_{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)&hellip; 1}}}

{\displaystyle ^{n}\operatorname {P} \_{k}=n&sdot; (n-1)&sdot; (n-2)&ctdot; (n-k+1)}

Task: Combinations Task: Permutations With replacement {\displaystyle {\binom {n+k-1}{k}}=<sup>n+k-1</sup>\operatorname {C} \_{k}={(n+k-1)! \over (n-1)!k!}}

{\displaystyle n<sup>k</sup>}

Task: Combinations with repetitions Task: Permutations with repetitions

```rust
fn fact(n:u32) -> u64 {
  let mut f:u64 = n as u64;
  for i in 2..n {
    f *= i as u64;
  }
  return f;
}
¬†
fn choose(n: u32, k: u32)  -> u64 {
   let mut num:u64 = n as u64;
   for i in 1..k {
     num *= (n-i) as u64;
   }
   return num / fact(k);
}
¬†
fn main() {
  println!("{}", choose(5,3));
}
```

Output:

```rust
10
```

# Multiplication tables<a id="sec-117"></a>

Task

Produce a formatted ¬† 12√ó12 ¬† multiplication table of the kind memorized by rote when in primary (or elementary) school.

Only print the top half triangle of products.

```rust
const LIMIT: i32 = 12;
¬†
fn main() {
    for i in 1..LIMIT+1 {
        print!("{:3}{}", i, if LIMIT - i == 0 {'\n'} else {' '})
    }
    for i in 0..LIMIT+1 {
        print!("{}", if LIMIT - i == 0 {"+\n"} else {"----"});
    }
¬†
    for i in 1..LIMIT+1 {
        for j in 1..LIMIT+1 {
            if j < i {
                print!("    ")
            } else { 
                print!("{:3} ", j * i)
            }
        }
        println!("| {}", i);
    }
¬†
¬†
}
```

# Mutual recursion<a id="sec-118"></a>

Two functions are said to be mutually recursive if the first calls the second, and in turn the second calls the first.

Write two mutually recursive functions that compute members of the Hofstadter Female and Male sequences defined as:

{\displaystyle {\begin{aligned}F(0)&=1\\ ;\\ M(0)=0\\\F(n)&=n-M(F(n-1)),\quad n>0\\\M(n)&=n-F(M(n-1)),\quad n>0.\end{aligned}}}

(If a language does not allow for a solution using mutually recursive functions then state this rather than give a solution by other means).

```rust
fn f(n: u32) -> u32 {
    match n {
        0 => 1,
        _ => n - m(f(n - 1))
    }
}
¬†
fn m(n: u32) -> u32 {
    match n {
        0 => 0,
        _ => n - f(m(n - 1))
    }
}
¬†
fn main() {
    for i in (0..20).map(f) {
        print!("{} ", i);
    }
    println!("");
¬†
    for i in (0..20).map(m) {
        print!("{} ", i);
    }
    println!("")
}
```

Output:

```rust
1 1 2 2 3 3 4 5 5 6 6 7 8 8 9 9 10 11 11 12
0 0 1 2 2 3 4 4 5 6 6 7 7 8 9 9 10 11 11 12
```

# Babbage problem<a id="sec-119"></a>

Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:

What is the smallest positive integer whose square ends in the digits 269,696?

‚Äî Babbage, letter to Lord Bowden, 1837; see Hollingdale and Tootill, Electronic Computers, second edition, 1970, p. 125.

He thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.

Task[edit]

The task is to find out if Babbage had the right answer ‚Äî and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.

For these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer, who has never programmed‚Äîin fact, who has never so much as seen a single line of code.

Motivation

The aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.

```rust
fn main() {
    let mut current = 0;
    while (current * current)¬†% 1_000_000¬†!= 269_696 {
        current += 1;
    }
    println!(
        "The smallest number whose square ends in 269696 is {}",
        current
    );
}
```

Output:

```rust
The smallest number whose square ends in 269696 is 25264

```

# Loops/Break<a id="sec-120"></a>

Task

Show a loop which prints random numbers (each number newly generated each loop) from 0 to 19 (inclusive).

If a number is 10, stop the loop after printing it, and do not generate any further numbers.

Otherwise, generate and print a second random number before restarting the loop.

If the number 10 is never generated as the first number in a loop, loop forever.

Related tasks

¬† Loop over multiple arrays simultaneously ¬† Loops/Break ¬† Loops/Continue ¬† Loops/Do-while ¬† Loops/Downward for ¬† Loops/For ¬† Loops/For with a specified step ¬† Loops/Foreach ¬† Loops/Increment loop index within loop body ¬† Loops/Infinite ¬† Loops/N plus one half ¬† Loops/Nested ¬† Loops/While ¬† Loops/with multiple ranges

Library: rand

```rust
// cargo-deps: rand
¬†
extern crate rand;
use rand::distributions::{Range, IndependentSample};
¬†
fn main() {
    loop {
        let num = Range::new(0, 19 + 1).ind_sample(&mut rand::thread_rng());
        if num == 10 {
            println!("{}", num);
            break;
        }
    }
}
¬†
```

# Count occurrences of a substring<a id="sec-121"></a>

Task

Create a function, ¬† or show a built-in function, ¬† to count the number of non-overlapping occurrences of a substring inside a string.

The function should take two arguments:

¬† the first argument being the string to search, ¬† and ¬† the second a substring to be searched for.

It should return an integer count.

```
print countSubstring("the three truths","th")
3
¬†
// do not count substrings that overlap with previously-counted substrings:
print countSubstring("ababababab","abab")
2
```

The matching should yield the highest number of non-overlapping matches.

In general, this essentially means matching from left-to-right or right-to-left ¬† (see proof on talk page).

Metrics: length

Sub-string search: Count occurrences of a substring

Multi-string operations: LCP, LCS, concatenation

Manipulation: reverse, lower- and uppercase

```rust
¬†
fn main() {
    println!("{}","the three truths".matches("th").count());
    println!("{}","ababababab".matches("abab").count());
}
¬†
```

Output:

```rust
3
2

```

# Averages/Root mean square<a id="sec-122"></a>

Task[edit]

Compute the ¬† Root mean square ¬† of the numbers 1..10.

The ¬† root mean square ¬† is also known by its initials RMS (or rms), and as the quadratic mean.

The RMS is calculated as the mean of the squares of the numbers, square-rooted:

{\displaystyle x<sub>\mathrm {rms} </sub>={\sqrt {{{x<sub>1</sub>}<sup>2</sup>+{x<sub>2</sub>}<sup>2</sup>+&ctdot; +{x<sub>n</sub>}<sup>2</sup>} \over n}}.}

See also

Tasks for calculating statistical measures

in one go moving (sliding window) moving (cumulative) Mean Arithmetic Statistics/Basic Averages/Arithmetic mean Averages/Pythagorean means

Averages/Simple moving average

Geometric Averages/Pythagorean means

Harmonic Averages/Pythagorean means

Quadratic Averages/Root mean square

Circular Averages/Mean angle Averages/Mean time of day

Median Averages/Median

Mode Averages/Mode

Standard deviation Statistics/Basic

Cumulative standard deviation

```rust
fn root_mean_square(vec: Vec<i32>) -> f32 {
    let sum_squares = vec.iter().fold(0, |acc, &x| acc + x.pow(2));
    return ((sum_squares as f32)/(vec.len() as f32)).sqrt();
}
¬†
fn main() {
    let vec = (1..11).collect();
    println!("The root mean square is: {}", root_mean_square(vec));
}
```

Output:

The root mean square is: 6.204837

# Short-circuit evaluation<a id="sec-123"></a>

Assume functions ¬† a ¬† and ¬† b ¬† return boolean values, ¬† and further, the execution of function ¬† b ¬† takes considerable resources without side effects, and is to be minimized.

If we needed to compute the conjunction ¬† (and):

x = a() and b()

Then it would be best to not compute the value of ¬† b() ¬† if the value of ¬† a() ¬† is computed as ¬† false, ¬† as the value of ¬† x ¬† can then only ever be ¬† false.

Similarly, if we needed to compute the disjunction (or):

y = a() or b()

Then it would be best to not compute the value of ¬† b() ¬† if the value of ¬† a() ¬† is computed as ¬† true, ¬† as the value of ¬† y ¬† can then only ever be ¬† true.

Some languages will stop further computation of boolean equations as soon as the result is known, so-called ¬† short-circuit evaluation ¬† of boolean expressions

Task

Create two functions named ¬† a ¬† and ¬† b, ¬† that take and return the same boolean value.

The functions should also print their name whenever they are called.

Calculate and assign the values of the following equations to a variable in such a way that function ¬† b ¬† is only called when necessary:

x = a(i) and b(j) y = a(i) or b(j)

If the language does not have short-circuit evaluation, this might be achieved with nested ¬† ¬† if ¬† ¬† statements.

```rust
fn a(foo: bool) -> bool {
    println!("a");
    foo
}
¬†
fn b(foo: bool) -> bool {
    println!("b");
    foo
}
¬†
fn main() {
    for i in vec![true, false] {
        for j in vec![true, false] {
            println!("{} and {} == {}", i, j, a(i) && b(j));
            println!("{} or {} == {}", i, j, a(i) || b(j));
            println!();
        }
    }
}
```

Output:

```rust
a
b
true and true == true
a
true or true == true

a
b
true and false == false
a
true or false == true

a
false and true == false
a
b
false or true == true

a
false and false == false
a
b
false or false == false

```

# Look-and-say sequence<a id="sec-124"></a>

The ¬† Look and say sequence ¬† is a recursively defined sequence of numbers studied most notably by ¬† John Conway.

Sequence Definition

Take a decimal number Look at the number, visually grouping consecutive runs of the same digit. Say the number, from left to right, group by group; as how many of that digit there are - followed by the digit grouped.

This becomes the next number of the sequence.

An example:

Starting with the number 1, ¬† you have one 1 which produces 11 Starting with 11, ¬† you have two 1's. ¬† I.E.: ¬† 21 Starting with 21, ¬† you have one 2, then one 1. ¬† I.E.: ¬† (12)(11) which becomes 1211 Starting with 1211, ¬† you have one 1, one 2, then two 1's. ¬† I.E.: ¬† (11)(12)(21) which becomes 111221

Task

Write a program to generate successive members of the look-and-say sequence.

Related tasks

¬† Fours is the number of letters in the &#x2026; ¬† Number names ¬† Self-describing numbers ¬† Self-referential sequence ¬† Spelling of ordinal numbers

See also

¬† Look-and-Say Numbers (feat John Conway), A Numberphile Video. ¬† This task is related to, and an application of, the Run-length encoding task. ¬† Sequence A005150 on The On-Line Encyclopedia of Integer Sequences.

```rust
fn next_sequence(in_seq: &[i8]) -> Vec<i8> {
    assert!(!in_seq.is_empty());
¬†
    let mut result = Vec::new();
    let mut current_number = in_seq[0];
    let mut current_runlength = 1;
¬†
    for i in &in_seq[1..] {
        if current_number == *i {
            current_runlength += 1;
        } else {
            result.push(current_runlength);
            result.push(current_number);
            current_runlength = 1;
            current_number = *i;
        }
    }
    result.push(current_runlength);
    result.push(current_number);
    result
}
¬†
fn main() {
    let mut seq = vec![1];
¬†
    for i in 0..10 {
        println!("Sequence {}: {:?}", i, seq);
        seq = next_sequence(&seq);
    }
}
```

Output:

```rust
Sequence 0: [1]
Sequence 1: [1, 1]
Sequence 2: [2, 1]
Sequence 3: [1, 2, 1, 1]
Sequence 4: [1, 1, 1, 2, 2, 1]
Sequence 5: [3, 1, 2, 2, 1, 1]
Sequence 6: [1, 3, 1, 1, 2, 2, 2, 1]
Sequence 7: [1, 1, 1, 3, 2, 1, 3, 2, 1, 1]
Sequence 8: [3, 1, 1, 3, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1]
Sequence 9: [1, 3, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 1, 1]
```

# JSON<a id="sec-125"></a>

Load a JSON string into a data structure. Also, create a new data structure and serialize it into JSON.

Use objects and arrays (as appropriate for your language) and make sure your JSON is valid (<https://jsonformatter.org>, <https://codebeautify.org/jsonvalidator>, <https://jsonlint.com/> or <https://extendsclass.com/json-validator.html>).

```rust
extern crate rustc_serialize;
¬†
use rustc_serialize::json;
¬†
#[derive(RustcDecodable, RustcEncodable)]
struct Penguin {
    name¬†: String,
    born¬†: i16
}
fn main() {
    let pengu = Penguin { name¬†: "pengu".to_string(), born¬†: 1999 };
    println!("{}", json::encode(&pengu).unwrap());
    let pingu¬†: Penguin = json::decode(r##"{"name":"pingu","born":2001}"##).unwrap();
    assert_eq!(&pingu.name, "pingu");
    assert_eq!(pingu.born, 2001);
}
```

Output:

```rust
{"name":"pengu","born":1999}
```

# String concatenation<a id="sec-126"></a>

Create a string variable equal to any text value. Create another string variable whose value is the original variable concatenated with another string literal.

To illustrate the operation, show the content of the variables.

Tasks featuring Strings

Metrics: length

Sub-string search: Count occurrences of a substring

Multi-string operations: LCP, LCS, concatenation

Manipulation: reverse, lower- and uppercase

```rust
fn main() {
    let s = "hello".to_owned();
    println!("{}", s);
¬†
    let s1 = s + " world";
    println!("{}", s1);
}
```

# Arithmetic-geometric mean<a id="sec-127"></a>

This page uses content from Wikipedia. The original article was at Arithmetic-geometric mean. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

task

Write a function to compute the arithmetic-geometric mean of two numbers. [1] The arithmetic-geometric mean of two numbers can be (usefully) denoted as {\displaystyle \mathrm {agm} (a,g)} , and is equal to the limit of the sequence:

{\displaystyle a<sub>0</sub>=a;\qquad g<sub>0</sub>=g} {\displaystyle a<sub>n+1</sub>={\tfrac {1}{2}}(a<sub>n</sub>+g<sub>n</sub>);\quad g<sub>n+1</sub>={\sqrt {a<sub>n</sub>g<sub>n</sub>}}.}

Since the limit of {\displaystyle a<sub>n</sub>-g<sub>n</sub>} tends (rapidly) to zero with iterations, this is an efficient method.

Demonstrate the function by calculating:

{\displaystyle \mathrm {agm} (1,1/{\sqrt {2}})}

Also see

¬† mathworld.wolfram.com/Arithmetic-Geometric Mean

```rust
// Accepts two command line arguments
// cargo run --name agm arg1 arg2
¬†
fn main () {
    let mut args = std::env::args();
¬†
    let x = args.nth(1).expect("First argument not specified.").parse::<f32>().unwrap();
    let y = args.next().expect("Second argument not specified.").parse::<f32>().unwrap();
¬†
    let result = agm(x,y);
    println!("The arithmetic-geometric mean is {}", result);
}
¬†
fn agm (x: f32, y: f32) -> f32 {
    let e: f32 = 0.000001;
    let mut a = x;
    let mut g = y;
    let mut a1: f32;
    let mut g1: f32;
¬†
    if a * g < 0f32 { panic!("The arithmetric-geometric mean is undefined for numbers less than zero!"); }
    else {
        loop {
            a1 = (a + g) / 2.;
            g1 = (a * g).sqrt();
            a = a1;
            g = g1;
            if (a - g).abs() < e {  return a; }
        }
    }
}
```

Output:

Output of running with arguments 1, 0.70710678:

```rust
The arithmetic-geometric mean is 1.456791

```

# Array length<a id="sec-128"></a>

Task

Determine the amount of elements in an array.

As an example use an array holding the strings 'apple' and 'orange'.

Related task

¬† String length

By default arrays are immutable in rust.

```rust
¬†
fn main() {
    let array = ["foo", "bar", "baz", "biff"];
    println!("the array has {} elements", array.len());
}
¬†
```

# Averages/Median<a id="sec-129"></a>

Task[edit]

Write a program to find the ¬† median ¬† value of a vector of floating-point numbers.

The program need not handle the case where the vector is empty, but must handle the case where there are an even number of elements. ¬† In that case, return the average of the two middle values.

There are several approaches to this. ¬† One is to sort the elements, and then pick the element(s) in the middle.

Sorting would take at least ¬† O(n‚Äälogn). ¬† Another approach would be to build a priority queue from the elements, and then extract half of the elements to get to the middle element(s). ¬† This would also take ¬† O(n‚Äälogn). ¬† The best solution is to use the ¬† selection algorithm ¬† to find the median in ¬† O(n) ¬† time.

See also

Quickselect<sub>algorithm</sub>

Tasks for calculating statistical measures

in one go moving (sliding window) moving (cumulative) Mean Arithmetic Statistics/Basic Averages/Arithmetic mean Averages/Pythagorean means

Averages/Simple moving average

Geometric Averages/Pythagorean means

Harmonic Averages/Pythagorean means

Quadratic Averages/Root mean square

Circular Averages/Mean angle Averages/Mean time of day

Median Averages/Median

Mode Averages/Mode

Standard deviation Statistics/Basic

Cumulative standard deviation

Sorting, then obtaining the median element:

```rust
fn median(mut xs: Vec<f64>) -> f64 {
    // sort in ascending order, panic on f64::NaN
    xs.sort_by(|x,y| x.partial_cmp(y).unwrap() );
    let n = xs.len();
    if n¬†% 2 == 0 {
        (xs[n/2] + xs[n/2 - 1]) / 2.0
    } else {
        xs[n/2]
    }
}
¬†
fn main() {
    let nums = vec![2.,3.,5.,0.,9.,82.,353.,32.,12.];
    println!("{:?}", median(nums))
}
```

Output:

```rust
9
```

# Loops/Nested<a id="sec-130"></a>

Show a nested loop which searches a two-dimensional array filled with random numbers uniformly distributed over {\displaystyle [1,\ldots ,20]} .

The loops iterate rows and columns of the array printing the elements until the value {\displaystyle 20} is met.

Specifically, this task also shows how to break out of nested loops.

Related tasks

¬† Loop over multiple arrays simultaneously ¬† Loops/Break ¬† Loops/Continue ¬† Loops/Do-while ¬† Loops/Downward for ¬† Loops/For ¬† Loops/For with a specified step ¬† Loops/Foreach ¬† Loops/Increment loop index within loop body ¬† Loops/Infinite ¬† Loops/N plus one half ¬† Loops/Nested ¬† Loops/While ¬† Loops/with multiple ranges ¬† Loops/Wrong ranges

Library: rand

```rust
use rand::Rng;
¬†
extern crate rand;
¬†
fn main() {
    let mut matrix = [[0u8; 10]; 10];
    let mut rng = rand::thread_rng();
¬†
    for row in matrix.iter_mut() {
        for item in row.iter_mut() {
            *item = rng.gen_range(0, 21);
        }
    }
¬†
    'outer: for row in matrix.iter() {
        for &item in row.iter() {
            print!("{:2} ", item);
            if item == 20 { break 'outer }
        }
        println!("");
    }
}
```

Output:

```rust
5  3  8 18 13  2  5 13  6 17
5 14 20
```

# Generate lower case ASCII alphabet<a id="sec-131"></a>

Task

Generate an array, list, lazy sequence, or even an indexable string of all the lower case ASCII characters, from a to z. If the standard library contains such a sequence, show how to access it, but don't fail to show how to generate a similar sequence.

For this basic task use a reliable style of coding, a style fit for a very large program, and use strong typing if available. It's bug prone to enumerate all the lowercase characters manually in the code. During code review it's not immediate obvious to spot the bug in a Tcl line like this contained in a page of code:

```
set alpha {a b c d e f g h i j k m n o p q r s t u v w x y z}
```

```rust
¬†
fn main() {
    // An iterator over the lowercase alpha's
    let ascii_iter = (0..26).map(|x| (x + 'a' as u8) as char);
¬†
    println!("{:?}", ascii_iter.collect::<Vec<_>>());
}
¬†
```

Output:

```rust
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

```

# Abstract type<a id="sec-132"></a>

Abstract type is a type without instances or without definition.

For example in object-oriented programming using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called interfaces. In the languages that do not support multiple inheritance (Ada, Java), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like C++) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete, OO languages normally prevent instantiation from them (instantiation must derived from one of their descendant classes).

The term abstract datatype also may denote a type, with an implementation provided by the programmer rather than directly by the language (a built-in or an inferred type). Here the word abstract means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the information hiding principle.

It is important not to confuse this abstractness (of implementation) with one of the abstract type. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.

In some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have abstract types that are not OO related and are not an abstractness too. These are pure abstract types without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter.

Task: show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.

Rust doesn't have traditional object oriented concepts such as classes, instead it uses a concept called traits. Traits are similar to abstract classes in the sense that they define an interface a struct must conform to. A trait can be defined as such:

```rust
trait Shape {
    fn area(self) -> i32;
}
```

The trait can then be implemented on a struct.

```rust
struct Square {
    side_length: i32
}
¬†
impl Shape for Square {
    fn area(self) -> i32 {
        self.side_length * self.side_length
    }
}
```

Note, traits can also have a default implementation:

```rust
trait Shape {
    fn area(self) -> i32;
¬†
    fn is_shape(self) -> bool {
        true
    }
}
```

# Arbitrary-precision integers (included)<a id="sec-133"></a>

Using the in-built capabilities of your language, calculate the integer value of:

```




{\displaystyle 5^{4^{3^{2}}}}




```

Confirm that the first and last twenty digits of the answer are:

```
62060698786608744707...92256259918212890625

```

Find and show the number of decimal digits in the answer.

Note: Do not submit an implementation of arbitrary precision arithmetic. The intention is to show the capabilities of the language as supplied. If a language has a single, overwhelming, library of varied modules that is endorsed by its home site ‚Äì such as CPAN for Perl or Boost for C++ ‚Äì then that may be used instead. Strictly speaking, this should not be solved by fixed-precision numeric libraries where the precision has to be manually set to a large value; although if this is the only recourse then it may be used with a note explaining that the precision must be set manually to a large enough value.

Related tasks

¬† Long multiplication ¬† Exponentiation order

This is accomplished via the \`num\` crate. This used to be part of the standard library, but was relegated to an external crate when Rust hit 1.0. It is still owned and maintained by members of the Rust core team and is the de-facto library for numerical generics and arbitrary precision arithmetic.

```rust
extern crate num;
use num::bigint::BigUint;
use num::FromPrimitive;
use num::pow::pow;
¬†
fn main() {
    let big = BigUint::from_u8(5).unwrap();
    let answer_as_string = format!("{}", pow(big,pow(4,pow(3,2))));
¬†
      // The rest is output formatting.
    let first_twenty: String = answer_as_string.chars().take(20).collect();
    let last_twenty_reversed: Vec<char> = answer_as_string.chars().rev().take(20).collect();
    let last_twenty: String = last_twenty_reversed.into_iter().rev().collect();
    println!("Number of digits: {}", answer_as_string.len());
    println!("First and last digits: {:?}..{:?}", first_twenty, last_twenty);
}
```

Output:

```rust
Number of digits: 183231
First and last digits: "62060698786608744707".."92256259918212890625"

```

# Closures/Value capture<a id="sec-134"></a>

Task

Create a list of ten functions, in the simplest manner possible ¬† (anonymous functions are encouraged), ¬† such that the function at index¬†¬† i ¬† (you may choose to start ¬† i ¬† from either ¬† 0 ¬† or ¬† 1), ¬† when run, should return the square of the index, ¬† that is, ¬† i 2.

Display the result of running any but the last function, to demonstrate that the function indeed remembers its value.

Goal

Demonstrate how to create a series of independent closures based on the same template but maintain separate copies of the variable closed over.

In imperative languages, one would generally use a loop with a mutable counter variable.

For each function to maintain the correct number, it has to capture the value of the variable at the time it was created, rather than just a reference to the variable, which would have a different value by the time the function was run.

See also: Multiple distinct objects

One note here about referencing values and capturing values: Rust employs strong ownership rules that do not allow mutating a value that is referenced (pointed to without allowing mutation) from elsewhere. It also doesn't allow referencing a value that may be dropped before the reference is released. The proof that we really did capture the value is therefore unnecessary. Either we did or it wouldn't have compiled.

```rust
fn main() {
    let fs: Vec<_> = (0..10).map(|i| {move || i*i} ).collect();
    println!("7th val: {}", fs[7]());
}
```

Output:

```rust
7th val: 49
```

# Comma quibbling<a id="sec-135"></a>

Comma quibbling is a task originally set by Eric Lippert in his blog.

Task

Write a function to generate a string output which is the concatenation of input words from a list/sequence where:

An input of no words produces the output string of just the two brace characters "{}". An input of just one word, e.g. ["ABC"], produces the output string of the word inside the two braces, e.g. "{ABC}". An input of two words, e.g. ["ABC", "DEF"], produces the output string of the two words inside the two braces with the words separated by the string " and ", e.g. "{ABC and DEF}". An input of three or more words, e.g. ["ABC", "DEF", "G", "H"], produces the output string of all but the last word separated by ", " with the last word separated by " and " and all within braces; e.g. "{ABC, DEF, G and H}".

Test your function with the following series of inputs showing your output here on this page:

[] # (No input words). ["ABC"] ["ABC", "DEF"] ["ABC", "DEF", "G", "H"]

Note: Assume words are non-empty strings of uppercase characters for this task.

```rust
¬†
fn quibble(seq: &[&str]) -> String {
    match seq.len() {
        0 => "{}".to_string(),
        1 => format!("{{{}}}", seq[0]),
        _ => {
            format!("{{{} and {}}}",
                    seq[..seq.len() - 1].join(", "),
                    seq.last().unwrap())
        }
    }
}
¬†
fn main() {
    println!("{}", quibble(&[]));
    println!("{}", quibble(&["ABC"]));
    println!("{}", quibble(&["ABC", "DEF"]));
    println!("{}", quibble(&["ABC", "DEF", "G", "H"]));
}
¬†
```

Output:

```rust
{}
{ABC}
{ABC and DEF}
{ABC, DEF, G and H}

```

# Strip a set of characters from a string<a id="sec-136"></a>

Task

Create a function that strips a set of characters from a string.

The function should take two arguments:

¬† a string to be stripped ¬† a string containing the set of characters to be stripped

The returned string should contain the first string, stripped of any characters in the second argument:

```
 print stripchars("She was a soul stripper. She took my heart!","aei")
Sh ws  soul strppr. Sh took my hrt!
```

Naive Implementation:

```rust
¬†
fn strip_characters(original¬†: &str, to_strip¬†: &str) -> String {
    let mut result = String::new();
    for c in original.chars() {
        if¬†!to_strip.contains(c) {
           result.push(c);
       }
    }
    result
}
¬†
```

Functional Implementation:

```rust
¬†
fn strip_characters(original¬†: &str, to_strip¬†: &str) -> String {
    original.chars().filter(|&c|¬†!to_strip.contains(c)).collect()
}
¬†
```

Either can be executed thusly:

```rust
¬†
fn main() {
    println!("{}", strip_characters("She was a soul stripper. She took my heart!", "aei"));
}
¬†
```

# Least common multiple<a id="sec-137"></a>

Task

Compute the least common multiple of two integers.

Given ¬† m ¬† and ¬† n, ¬† the least common multiple is the smallest positive integer that has both ¬† m ¬† and ¬† n ¬† as factors.

Example

The least common multiple of 12 and 18 is 36, because 12 is a factor (12 √ó 3 = 36), and 18 is a factor (18 √ó 2 = 36), and there is no positive integer less than 36 that has both factors. ¬† As a special case, if either ¬† m ¬† or ¬† n ¬† is zero, then the least common multiple is zero.

One way to calculate the least common multiple is to iterate all the multiples of ¬† m, ¬† until you find one that is also a multiple of ¬† n.

If you already have ¬† gcd ¬† for greatest common divisor, ¬† then this formula calculates ¬† lcm.

{\displaystyle \operatorname {lcm} (m,n)={\frac {|m&times; n|}{\operatorname {gcd} (m,n)}}}

One can also find ¬† lcm ¬† by merging the prime decompositions of both ¬† m ¬† and ¬† n.

See also

¬† MathWorld entry: ¬† Least Common Multiple. ¬† Wikipedia entry: ¬† Least common multiple.

This implementation uses a recursive implementation of Stein's algorithm to calculate the gcd.

```rust
use std::cmp::{max, min};
¬†
fn gcd(a: usize, b: usize) -> usize {
    match ((a, b), (a & 1, b & 1)) {
        ((x, y), _) if x == y => y,
        ((0, x), _) | ((x, 0), _) => x,
        ((x, y), (0, 1)) | ((y, x), (1, 0)) => gcd(x >> 1, y),
        ((x, y), (0, 0)) => gcd(x >> 1, y >> 1) << 1,
        ((x, y), (1, 1)) => {
            let (x, y) = (min(x, y), max(x, y));
            gcd((y - x) >> 1, x)
        }
        _ => unreachable!(),
    }
}
¬†
fn lcm(a: usize, b: usize) -> usize {
    a * b / gcd(a, b)
}
¬†
fn main() {
    println!("{}", lcm(6324, 234))
}
```

# Longest common subsequence<a id="sec-138"></a>

The longest common subsequence (or LCS) of groups A and B is the longest group of elements from A and B that are common between the two groups and in the same order in each group. For example, the sequences "1234" and "1224533324" have an LCS of "1234":

```
1234
1224533324

```

For a string example, consider the sequences "thisisatest" and "testing123testing". An LCS would be "tsitest":

```
thisisatest
testing123testing

```

In this puzzle, your code only needs to deal with strings. Write a function which returns an LCS of two strings (case-sensitive). You don't need to show multiple LCS's.

For more information on this problem please see Wikipedia.

Dynamic programming version:

```rust
¬†
use std::cmp;
¬†
fn lcs(string1: String, string2: String) -> (usize, String){
    let total_rows = string1.len() + 1;
    let total_columns = string2.len() + 1;
    // rust doesn't allow accessing string by index
    let string1_chars = string1.as_bytes();
    let string2_chars = string2.as_bytes();
¬†
    let mut table = vec![vec![0; total_columns]; total_rows];
¬†
    for row in 1..total_rows{
        for col in 1..total_columns {
            if string1_chars[row - 1] == string2_chars[col - 1]{
                table[row][col] = table[row - 1][col - 1] + 1;
            } else {
                table[row][col] = cmp::max(table[row][col-1], table[row-1][col]);
            }
        }
    }
¬†
    let mut common_seq = Vec::new();
    let mut x = total_rows - 1;
    let mut y = total_columns - 1;
¬†
    while x¬†!= 0 && y¬†!= 0 {
        // Check element above is equal
        if table[x][y] == table[x - 1][y] {
            x = x - 1;
        }
        // check element to the left is equal
        else if table[x][y] == table[x][y - 1] {
            y = y - 1;
        }
        else {
            // check the two element at the respective x,y position is same
            assert_eq!(string1_chars[x-1], string2_chars[y-1]);
            let char = string1_chars[x - 1];
            common_seq.push(char);
            x = x - 1;
            y = y - 1;
        }
    }
    common_seq.reverse();
    (table[total_rows - 1][total_columns - 1], String::from_utf8(common_seq).unwrap())
}
¬†
fn main() {
    let res = lcs("abcdaf".to_string(), "acbcf".to_string());
    assert_eq!((4 as usize, "abcf".to_string()), res);
    let res = lcs("thisisatest".to_string(), "testing123testing".to_string());
    assert_eq!((7 as usize, "tsitest".to_string()), res);
    // LCS for input Sequences ‚ÄúAGGTAB‚Äù and ‚ÄúGXTXAYB‚Äù is ‚ÄúGTAB‚Äù of length 4.
    let res = lcs("AGGTAB".to_string(), "GXTXAYB".to_string());
    assert_eq!((4 as usize, "GTAB".to_string()), res);
}
```

# Detect division by zero<a id="sec-139"></a>

Task

Write a function to detect a ¬† divide by zero error ¬† without checking if the denominator is zero.

```rust
fn test_division(numerator: u32, denominator: u32) {
    match numerator.checked_div(denominator) {
        Some(result) => println!("{} / {} = {}", numerator, denominator, result),
        None => println!("{} / {} results in a division by zero", numerator, denominator)
    }
}
¬†
fn main() {
    test_division(5, 4);
    test_division(4, 0);
}
```

# Exponentiation operator<a id="sec-140"></a>

Most programming languages have a built-in implementation of exponentiation.

Task

Re-implement integer exponentiation for both ¬† intint ¬† and ¬† floatint ¬† as both a procedure, ¬† and an operator (if your language supports operator definition).

If the language supports operator (or procedure) overloading, then an overloaded form should be provided for both ¬† intint ¬† and ¬† floatint ¬† variants.

The num crate is the de-facto Rust library for numerical generics and it provides the One trait which allows for an exponentiation function that is generic over both integral and floating point types. The library provides this generic exponentiation function, the implementation of which is the pow function below.

```rust
extern crate num;
use num::traits::One;
use std::ops::Mul;
¬†
fn pow<T>(mut base: T, mut exp: usize) -> T 
    where T: Clone + One + Mul<T, Output=T>
{
    if exp == 0 { return T::one() }
    while exp & 1 == 0 {
        base = base.clone() * base;
        exp >>= 1;
    }
    if exp == 1 { return base }
    let mut acc = base.clone();
¬†
    while exp > 1 {
        exp >>= 1;
        base = base.clone() * base;
        if exp & 1 == 1 {
            acc = acc * base.clone();
        }
    }
    acc
}
```

# Arithmetic/Complex<a id="sec-141"></a>

A ¬† complex number ¬† is a number which can be written as: {\displaystyle a+b&times; i} (sometimes shown as: {\displaystyle b+a&times; i} where ¬† {\displaystyle a} ¬† and ¬† {\displaystyle b} ¬† are real numbers, ¬† and ¬† {\displaystyle i} ¬† is ¬† ‚àö¬†-1¬†

Typically, complex numbers are represented as a pair of real numbers called the "imaginary part" and "real part", ¬† where the imaginary part is the number to be multiplied by {\displaystyle i} .

Task

Show addition, multiplication, negation, and inversion of complex numbers in separate functions. (Subtraction and division operations can be made with pairs of these operations.) Print the results for each operation tested. Optional: Show complex conjugation.

By definition, the ¬† complex conjugate ¬† of {\displaystyle a+bi} is {\displaystyle a-bi}

Some languages have complex number libraries available. ¬† If your language does, show the operations. ¬† If your language does not, also show the definition of this type.

```rust
extern crate num;
use num::complex::Complex;
¬†
fn main() {
    // two valid forms of definition
    let a = Complex {re:-4.0, im: 5.0};
    let b = Complex::new(1.0, 1.0);
¬†
    println!("   a    = {}", a);
    println!("   b    = {}", b);
    println!(" a + b  = {}", a + b);
    println!(" a * b  = {}", a * b);
    println!(" 1 / a  = {}", a.inv());
    println!("  -a    = {}", -a);
    println!("conj(a) = {}", a.conj());
}
```

# Count the coins<a id="sec-142"></a>

There are four types of common coins in ¬† US ¬† currency:

¬† quarters ¬† (25 cents) ¬† dimes ¬† (10 cents) ¬† nickels ¬† (5 cents), ¬† and ¬† pennies ¬† (1 cent)

There are six ways to make change for 15 cents:

¬† A dime and a nickel ¬† A dime and 5 pennies ¬† 3 nickels ¬† 2 nickels and 5 pennies ¬† A nickel and 10 pennies ¬† 15 pennies

Task

How many ways are there to make change for a dollar using these common coins? ¬† ¬† (1 dollar = 100 cents).

Optional

Less common are dollar coins (100 cents); ¬† and very rare are half dollars (50 cents). ¬† With the addition of these two coins, how many ways are there to make change for $1000?

(Note: ¬† the answer is larger than ¬† 232).

Reference

¬† an algorithm from MIT Press.

```rust
fn make_change(coins: &[usize], cents: usize) -> usize {
    let size = cents + 1;
    let mut ways = vec![0; size];
    ways[0] = 1;
    for &coin in coins {
        for amount in coin..size {
            ways[amount] += ways[amount - coin];
        }
    }
    ways[cents]
}
¬†
fn main() {
    println!("{}", make_change(&[1,5,10,25], 100));
    println!("{}", make_change(&[1,5,10,25,50,100], 100_000));
}
```

Output:

```rust
242
13398445413854501
```

# Haversine formula<a id="sec-143"></a>

This page uses content from Wikipedia. The original article was at Haversine formula. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

The haversine formula is an equation important in navigation, giving great-circle distances between two points on a sphere from their longitudes and latitudes.

It is a special case of a more general formula in spherical trigonometry, the law of haversines, relating the sides and angles of spherical "triangles".

Task

Implement a great-circle distance function, or use a library function, to show the great-circle distance between:

Nashville International Airport (BNA) ¬† in Nashville, TN, USA, ¬† which is:

```
N 36¬∞7.2',   W 86¬∞40.2'     (36.12,   -86.67)           -and-

```

Los Angeles International Airport (LAX) ¬†in Los Angeles, CA, USA, ¬† which is:

```
N 33¬∞56.4',  W 118¬∞24.0'    (33.94,  -118.40)   

```

```
User Kaimbridge clarified on the Talk page:

 -- 6371.0 km is the authalic radius based on/extracted from surface area;
 -- 6372.8 km is an approximation of the radius of the average circumference
    (i.e., the average great-elliptic or great-circle radius), where the
     boundaries are the meridian (6367.45 km) and the equator (6378.14 km).

Using either of these values results, of course, in differing distances:

 6371.0 km -> 2886.44444283798329974715782394574671655 km;
 6372.8 km -> 2887.25995060711033944886005029688505340 km;
 (results extended for accuracy check:  Given that the radii are only
  approximations anyways, .01' ‚âà 1.0621333 km and .001" ‚âà .00177 km,
  practical precision required is certainly no greater than about
  .0000001‚Äî‚Äîi.e., .1 mm!)

As distances are segments of great circles/circumferences, it is
recommended that the latter value (r = 6372.8 km) be used (which
most of the given solutions have already adopted, anyways). 

```

Most of the examples below adopted Kaimbridge's recommended value of 6372.8 km for the earth radius. However, the derivation of this ellipsoidal quadratic mean radius is wrong (the averaging over azimuth is biased). When applying these examples in real applications, it is better to use the mean earth radius, 6371 km. This value is recommended by the International Union of Geodesy and Geophysics and it minimizes the RMS relative error between the great circle and geodesic distance.

```rust
¬†
use std::f64;
¬†
static R: f64 = 6372.8;
¬†
fn haversine_dist(mut th1: f64, mut ph1: f64, mut th2: f64, ph2: f64) -> f64 {
    ph1 -= ph2;
    ph1 = ph1.to_radians();
    th1 = th1.to_radians();
    th2 = th2.to_radians();
    let dz: f64 = th1.sin() - th2.sin();
    let dx: f64 = ph1.cos() * th1.cos() - th2.cos();
    let dy: f64 = ph1.sin() * th1.cos();
    ((dx * dx + dy * dy + dz * dz).sqrt() / 2.0).asin() * 2.0 * R
}
¬†
fn main() {
    let d: f64 = haversine_dist(36.12, -86.67, 33.94, -118.4);
    println!("Distance: {} km ({} mi)", d, d / 1.609344);
}
¬†
¬†
```

```rust
Distance: 2887.2599506071106 km (1794.060157807846 mi)
```

# First-class functions<a id="sec-144"></a>

A language has first-class functions if it can do each of the following without recursively invoking a compiler or interpreter or otherwise metaprogramming:

Create new functions from preexisting functions at run-time Store functions in collections Use functions as arguments to other functions Use functions as return values of other functions

Task

Write a program to create an ordered collection A of functions of a real number. At least one function should be built-in and at least one should be user-defined; try using the sine, cosine, and cubing functions. Fill another collection B with the inverse of each function in A. Implement function composition as in Functional Composition. Finally, demonstrate that the result of applying the composition of each function in A and its inverse in B to a value, is the original value. (Within the limits of computational accuracy).

(A solution need not actually call the collections "A" and "B". These names are only used in the preceding paragraph for clarity.)

Related task

First-class Numbers

This solution uses a feature of Nightly Rust that allows us to return a closure from a function without using the extra indirection of a pointer. Stable Rust can also accomplish this challenge &#x2013; the only difference being that compose would return a Box<Fn(T) -> V> which would result in an extra heap allocation.

```rust
#![feature(conservative_impl_trait)]
fn main() {
    let cube      = |x: f64| x.powi(3);
    let cube_root = |x: f64| x.powf(1.0 / 3.0);
¬†
    let flist ¬†: [&Fn(f64) -> f64; 3] = [&cube     , &f64::sin , &f64::cos ];
    let invlist: [&Fn(f64) -> f64; 3] = [&cube_root, &f64::asin, &f64::acos];
¬†
    let result = flist.iter()
                      .zip(&invlist)
                      .map(|(f,i)| compose(f,i)(0.5))
                      .collect::<Vec<_>>();
¬†
    println!("{:?}", result);
¬†
}
¬†
fn compose<'a, F, G, T, U, V>(f: F, g: G) -> impl 'a + Fn(T) -> V
    where F: 'a + Fn(T) -> U,
          G: 'a + Fn(U) -> V,
{
    move |x| g(f(x))
¬†
}
```

# Queue/Definition<a id="sec-145"></a>

Illustration of FIFO behavior

Task

Implement a FIFO queue.

Elements are added at one side and popped from the other in the order of insertion.

Operations:

¬† push ¬† (aka enqueue) ¬† - add element ¬† pop ¬† ¬† (aka dequeue) ¬† - pop first element ¬† empty ¬† - return truth value when empty

Errors:

¬† handle the error of trying to pop from an empty queue (behavior depends on the language and platform)

See

¬† Queue/Usage ¬† for the built-in FIFO or queue of your language or standard library.

See also

Array Associative array: Creation, Iteration Collections Compound data type Doubly-linked list: Definition, Element definition, Element insertion, Traversal Linked list Queue: Definition, Usage Set Singly-linked list: Element definition, Element insertion, Traversal Stack

Using the standard library[edit]

The standard library has a double-ended queue implementation (VecDeque<T>) which will work here.

```rust
use std::collections::VecDeque;
fn main() {
    let mut stack = VecDeque::new();
    stack.push_back("Element1");
    stack.push_back("Element2");
    stack.push_back("Element3");
¬†
    assert_eq!(Some(&"Element1"), stack.front());
    assert_eq!(Some("Element1"), stack.pop_front());
    assert_eq!(Some("Element2"), stack.pop_front());
    assert_eq!(Some("Element3"), stack.pop_front());
    assert_eq!(None, stack.pop_front());
}
```

A simple implementation[edit]

This shows the implementation of a singly-linked queue with dequeue and enqueue. There are two peek implementations, one returns an immutable reference, the other returns a mutable one. This implementation also shows iteration over the Queue by value (consumes queue), immutable reference, and mutable reference.

```rust
use std::ptr;
¬†
pub struct Queue<T> {
    head: Link<T>,
    tail: *mut Item<T>, // Raw, C-like pointer. Cannot be guaranteed safe
}
¬†
type Link<T> = Option<Box<Item<T>>>;
¬†
struct Item<T> {
    elem: T,
    next: Link<T>,
}
¬†
pub struct IntoIter<T>(Queue<T>);
¬†
pub struct Iter<'a, T:'a> {
    next: Option<&'a Item<T>>,
}
¬†
pub struct IterMut<'a, T: 'a> {
    next: Option<&'a mut Item<T>>,
}
¬†
¬†
impl<T> Queue<T> {
    pub fn new() -> Self {
        Queue { head: None, tail: ptr::null_mut() }
    }
¬†
    pub fn enqueue(&mut self, elem: T) {
        let mut new_tail = Box::new(Item {
            elem: elem,
            next: None,
        });
¬†
        let raw_tail: *mut _ = &mut *new_tail;
¬†
        if¬†!self.tail.is_null() {
            unsafe {
                (*self.tail).next = Some(new_tail);
            }
        } else {
            self.head = Some(new_tail);
        }
¬†
        self.tail = raw_tail;
    }
¬†
    pub fn dequeue(&mut self) -> Option<T> {
        self.head.take().map(|head| {
            let head = *head;
            self.head = head.next;
¬†
            if self.head.is_none() {
                self.tail = ptr::null_mut();
            }
¬†
            head.elem
        })
    }
¬†
    pub fn peek(&self) -> Option<&T> {
        self.head.as_ref().map(|item| {
            &item.elem
        })
    }
¬†
    pub fn peek_mut(&mut self) -> Option<&mut T> {
        self.head.as_mut().map(|item| {
            &mut item.elem
        })
    }
¬†
    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }
¬†
    pub fn iter(&self) -> Iter<T> {
        Iter { next: self.head.as_ref().map(|item| &**item) }
    }
¬†
    pub fn iter_mut(&mut self) -> IterMut<T> {
        IterMut { next: self.head.as_mut().map(|item| &mut **item) }
    }
}
¬†
impl<T> Drop for Queue<T> {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_item) = cur_link {
            cur_link = boxed_item.next.take();
        }
    }
}
¬†
impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        self.0.dequeue()
    }
}
¬†
impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
¬†
    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|item| {
            self.next = item.next.as_ref().map(|item| &**item);
            &item.elem
        })
    }
}
¬†
impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;
¬†
    fn next(&mut self) -> Option<Self::Item> {
        self.next.take().map(|item| {
            self.next = item.next.as_mut().map(|item| &mut **item);
            &mut item.elem
        })
    }
}
```

# Create an HTML table<a id="sec-146"></a>

Create an HTML table.

The table body should have at least three rows of three columns. Each of these three columns should be labelled "X", "Y", and "Z". An extra column should be added at either the extreme left or the extreme right of the table that has no heading, but is filled with sequential row numbers. The rows of the "X", "Y", and "Z" columns should be filled with random or sequential integers having 4 digits or less. The numbers should be aligned in the same fashion for all columns.

Library: rand¬†version 0.3

```rust
extern crate rand;
¬†
use rand::Rng;
¬†
fn random_cell<R: Rng>(rng: &mut R) -> u32 {
    // Anything between 0 and 10_000 (exclusive) has 4 digits or fewer. Using `gen_range::<u32>`
    // is faster for smaller RNGs.  Because the parameters are constant, the compiler can do all
    // the range construction at compile time, removing the need for
    // `rand::distributions::range::Range`
    rng.gen_range(0, 10_000)
}
¬†
fn main() {
    let mut rng = rand::thread_rng(); // Cache the RNG for reuse
¬†
    println!("<table><thead><tr><th></th><td>X</td><td>Y</td><td>Z</td></tr></thead>");
¬†
    for row in 0..3 {
        let x = random_cell(&mut rng);
        let y = random_cell(&mut rng);
        let z = random_cell(&mut rng);
        println!("<tr><th>{}</th><td>{}</td><td>{}</td><td>{}</td></tr>", row, x, y, z);
    }
¬†
    println!("</table>");
}
```

Output:

```rust
<table><thead><tr><th></th><td>X</td><td>Y</td><td>Z</td></tr></thead>
<tr><th>0</th><td>7101</td><td>9111</td><td>3446</td></tr>
<tr><th>1</th><td>426</td><td>9518</td><td>611</td></tr>
<tr><th>2</th><td>9693</td><td>419</td><td>4878</td></tr>
</table>
```

# Program name<a id="sec-147"></a>

The task is to programmatically obtain the name used to invoke the program. (For example determine whether the user ran "python hello.py", or "python hellocaller.py", a program importing the code from "hello.py".)

Sometimes a multiline shebang is necessary in order to provide the script name to a language's internal ARGV.

See also Command-line arguments

Examples from GitHub.

scriptname.rs:

```rust
fn main() {
    println!("Program: {}", std::env::args().next().unwrap());
}
```

Example:

```rust
$ rustc scriptname.rs
$ ./scriptname
Program: ./scriptname
```

# Sorting algorithms/Insertion sort<a id="sec-148"></a>

This page uses content from Wikipedia. The original article was at Insertion sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

An O(n2) sorting algorithm which moves elements one at a time into the correct position. The algorithm consists of inserting one element at a time into the previously sorted part of the array, moving higher ranked elements up as necessary. To start off, the first (or smallest, or any arbitrary) element of the unsorted array is considered to be the sorted part.

Although insertion sort is an O(n2) algorithm, its simplicity, low overhead, good locality of reference and efficiency make it a good choice in two cases: (i) small n, (ii) as the final finishing-off algorithm for O(n logn) algorithms such as mergesort and quicksort.

The algorithm is as follows (from wikipedia):

```
function insertionSort(array A)
    for i from 1 to length[A]-1 do
        value¬†:= A[i] 
        j¬†:= i-1
        while j >= 0 and A[j] > value do
            A[j+1]¬†:= A[j]
            j¬†:= j-1
        done
        A[j+1] = value
    done

```

Writing the algorithm for integers will suffice.

```rust
fn insertion_sort<T: std::cmp::Ord>(arr: &mut [T]) {
    for i in 1..arr.len() {
        let mut j = i;
        while j > 0 && arr[j] < arr[j-1] {
            arr.swap(j, j-1);
            j = j-1;
        }
    }
}
```

# Middle three digits<a id="sec-149"></a>

Task

Write a function/procedure/subroutine that is called with an integer value and returns the middle three digits of the integer if possible or a clear indication of an error if this is not possible.

Note: The order of the middle digits should be preserved.

Your function should be tested with the following values; the first line should return valid answers, those of the second line should return clear indications of an error:

```
123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345
1, 2, -1, -10, 2002, -2002, 0

```

Show your output on this page.

```rust
fn middle_three_digits(x: i32) -> Result<String, String> {
    let s: String = x.abs().to_string();
    let len = s.len();
    if len < 3 {
        Err("Too short".into())
    } else if len¬†% 2 == 0 {
        Err("Even number of digits".into())
    } else {
        Ok(s[len/2 - 1 .. len/2 + 2].to_owned())
    }
}
¬†
fn print_result(x: i32) {
    print!("middle_three_digits({}) returned: ", x);
    match middle_three_digits(x) {
        Ok(s) => println!("Success, {}", s),
        Err(s) => println!("Failure, {}", s)
    }
}
¬†
fn main() {
    let passing = [123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345];
    let failing = [1, 2, -1, -10, 2002, -2002, 0];
    for i in passing.iter() {
        print_result(*i);
    }
    for i in failing.iter() {
        print_result(*i);
    }
}
```

Output:

```rust
middle_three_digits(123) returned: Success, 123
middle_three_digits(12345) returned: Success, 234
middle_three_digits(1234567) returned: Success, 345
middle_three_digits(987654321) returned: Success, 654
middle_three_digits(10001) returned: Success, 000
middle_three_digits(-10001) returned: Success, 000
middle_three_digits(-123) returned: Success, 123
middle_three_digits(-100) returned: Success, 100
middle_three_digits(100) returned: Success, 100
middle_three_digits(-12345) returned: Success, 234
middle_three_digits(1) returned: Failure, Too short
middle_three_digits(2) returned: Failure, Too short
middle_three_digits(-1) returned: Failure, Too short
middle_three_digits(-10) returned: Failure, Too short
middle_three_digits(2002) returned: Failure, Even number of digits
middle_three_digits(-2002) returned: Failure, Even number of digits
middle_three_digits(0) returned: Failure, Too short
```

# Real constants and functions<a id="sec-150"></a>

Task

Show how to use the following math constants and functions in your language ¬† (if not available, note it):

¬† e ¬† (base of the natural logarithm) ¬† {\displaystyle &pi; } ¬† square root ¬† logarithm ¬† (any base allowed) ¬† exponential ¬† (ex ) ¬† absolute value ¬† (a.k.a. "magnitude") ¬† floor ¬† (largest integer less than or equal to this number&#x2013;not the same as truncate or int) ¬† ceiling ¬† (smallest integer not less than this number&#x2013;not the same as round up) ¬† power ¬† (xy )

Related task

¬† Trigonometric Functions

```rust
use std::f64::consts::*;
¬†
fn main() {
    // e (base of the natural logarithm)
    let mut x = E;
    // œÄ
    x += PI;
    // square root
    x = x.sqrt();
    // logarithm (any base allowed)
    x = x.ln();
    // ceiling (smallest integer not less than this number--not the same as round up)
    x = x.ceil();
    // exponential (ex)
    x = x.exp();
    // absolute value (a.k.a. "magnitude")
    x = x.abs();
    // floor (largest integer less than or equal to this number--not the same as truncate or int)
    x = x.floor();
    // power (xy) 
    x = x.powf(x);
¬†
    assert_eq!(x, 4.0);
}
```

# Loops/Continue<a id="sec-151"></a>

Task

Show the following output using one loop.

```
1, 2, 3, 4, 5
6, 7, 8, 9, 10

```

Try to achieve the result by forcing the next iteration within the loop upon a specific condition, if your language allows it.

Related tasks

¬† Loop over multiple arrays simultaneously ¬† Loops/Break ¬† Loops/Continue ¬† Loops/Do-while ¬† Loops/Downward for ¬† Loops/For ¬† Loops/For with a specified step ¬† Loops/Foreach ¬† Loops/Increment loop index within loop body ¬† Loops/Infinite ¬† Loops/N plus one half ¬† Loops/Nested ¬† Loops/While ¬† Loops/with multiple ranges ¬† Loops/Wrong ranges

```rust
fn main() {
    for i in 1..10+1 {
        print!("{}", i);
        if i¬†% 5 == 0 {
            print!("\n");
            continue;
        }
        print!(", ");
    }
}
```

# Read a file line by line<a id="sec-152"></a>

Read a file one line at a time, as opposed to reading the entire file at once.

Related tasks

Read a file character by character Input loop.

```rust
use std::io::{BufReader,BufRead};
use std::fs::File;
¬†
fn main() {
    let file = File::open("file.txt").unwrap();
    for line in BufReader::new(file).lines() {
        println!("{}", line.unwrap());
    }
}
```

Output:

```rust
First line of the file!
Second line of the file!
```

# Assertions<a id="sec-153"></a>

Assertions are a way of breaking out of code when there is an error or an unexpected input.

Some languages throw exceptions and some treat it as a break point.

Task

Show an assertion in your language by asserting that an integer variable is equal to 42.

```rust
¬†
let x = 42;
assert!(x == 42);
assert_eq!(x, 42);
¬†
```

# Averages/Simple moving average<a id="sec-154"></a>

Computing the simple moving average of a series of numbers.

Task[edit]

Create a stateful function/class/instance that takes a period and returns a routine that takes a number as argument and returns a simple moving average of its arguments so far.

Description

A simple moving average is a method for computing an average of a stream of numbers by only averaging the last ¬† P ¬† numbers from the stream, ¬† where ¬† P ¬† is known as the period.

It can be implemented by calling an initialing routine with ¬† P ¬† as its argument, ¬† I(P), ¬† which should then return a routine that when called with individual, successive members of a stream of numbers, computes the mean of (up to), the last ¬† P ¬† of them, lets call this ¬† SMA().

The word ¬† stateful ¬† in the task description refers to the need for ¬† SMA() ¬† to remember certain information between calls to it:

¬† The period, ¬† P ¬† An ordered container of at least the last ¬† P ¬† numbers from each of its individual calls.

Stateful ¬† also means that successive calls to ¬† I(), ¬† the initializer, ¬† should return separate routines that do ¬† not ¬† share saved state so they could be used on two independent streams of data.

Pseudo-code for an implementation of ¬† SMA ¬† is:

```
function SMA(number: N):
    stateful integer: P
    stateful list:    stream
    number:           average

    stream.append_last(N)
    if stream.length() > P:
        # Only average the last P elements of the stream
        stream.delete_first()
    if stream.length() == 0:
        average = 0
    else:    
        average = sum( stream.values() ) / stream.length()
    return average

```

See also

Tasks for calculating statistical measures

in one go moving (sliding window) moving (cumulative) Mean Arithmetic Statistics/Basic Averages/Arithmetic mean Averages/Pythagorean means

Averages/Simple moving average

Geometric Averages/Pythagorean means

Harmonic Averages/Pythagorean means

Quadratic Averages/Root mean square

Circular Averages/Mean angle Averages/Mean time of day

Median Averages/Median

Mode Averages/Mode

Standard deviation Statistics/Basic

Cumulative standard deviation

Vector Based[edit]

```rust
struct SimpleMovingAverage {
    period: usize,
    numbers: Vec<usize>
}
¬†
impl SimpleMovingAverage {
    fn new(p: usize) -> SimpleMovingAverage {
        SimpleMovingAverage {
            period: p,
            numbers: Vec::new()
        }
    }
¬†
    fn add_number(&mut self, number: usize) -> f64 {
        self.numbers.push(number);
¬†
        if self.numbers.len() > self.period {
            self.numbers.remove(0);
        }
¬†
        if self.numbers.is_empty() {
            return 0f64;
        }else {
            let sum = self.numbers.iter().fold(0, |acc, x| acc+x);
            return sum as f64 / self.numbers.len() as f64;
        }
    }
}
¬†
fn main() {
    for period in [3, 5].iter() {
        println!("Moving average with period {}", period);
¬†
        let mut sma = SimpleMovingAverage::new(*period);
        for i in [1, 2, 3, 4, 5, 5, 4, 3, 2, 1].iter() {
            println!("Number: {} | Average: {}", i, sma.add_number(*i));
        }
    }
}
```

Double-ended Queue Based[edit]

```rust
use std::collections::VecDeque;
¬†
struct SimpleMovingAverage {
    period: usize,
    numbers: VecDeque<usize>
}
¬†
impl SimpleMovingAverage {
    fn new(p: usize) -> SimpleMovingAverage {
        SimpleMovingAverage {
            period: p,
            numbers: VecDeque::new()
        }
    }
¬†
    fn add_number(&mut self, number: usize) -> f64 {
        self.numbers.push_back(number);
¬†
        if self.numbers.len() > self.period {
            self.numbers.pop_front();
        }
¬†
        if self.numbers.is_empty() {
            return 0f64;
        }else {
            let sum = self.numbers.iter().fold(0, |acc, x| acc+x);
            return sum as f64 / self.numbers.len() as f64;
        }
    }
}
¬†
fn main() {
    for period in [3, 5].iter() {
        println!("Moving average with period {}", period);
¬†
        let mut sma = SimpleMovingAverage::new(*period);
        for i in [1, 2, 3, 4, 5, 5, 4, 3, 2, 1].iter() {
            println!("Number: {} | Average: {}", i, sma.add_number(*i));
        }
    }
}
```

```rust
Moving average with period 3
Number: 1 | Average: 1
Number: 2 | Average: 1.5
Number: 3 | Average: 2
Number: 4 | Average: 3
Number: 5 | Average: 4
Number: 5 | Average: 4.666666666666667
Number: 4 | Average: 4.666666666666667
Number: 3 | Average: 4
Number: 2 | Average: 3
Number: 1 | Average: 2
Moving average with period 5
Number: 1 | Average: 1
Number: 2 | Average: 1.5
Number: 3 | Average: 2
Number: 4 | Average: 2.5
Number: 5 | Average: 3
Number: 5 | Average: 3.8
Number: 4 | Average: 4.2
Number: 3 | Average: 4.2
Number: 2 | Average: 3.8
Number: 1 | Average: 3

```

# Knapsack problem/0-1<a id="sec-155"></a>

A tourist wants to make a good trip at the weekend with his friends.

They will go to the mountains to see the wonders of nature, so he needs to pack well for the trip.

He has a good knapsack for carrying things, but knows that he can carry a maximum of only 4kg in it, ¬† and it will have to last the whole day.

He creates a list of what he wants to bring for the trip but the total weight of all items is too much.

He then decides to add columns to his initial list detailing their weights and a numerical value representing how important the item is for the trip.

Here is the list:

Table of potential knapsack items item weight (dag) value map 9 150 compass 13 35 water 153 200 sandwich 50 160 glucose 15 60 tin 68 45 banana 27 60 apple 39 40 cheese 23 30 beer 52 10 suntan cream 11 70 camera 32 30 T-shirt 24 15 trousers 48 10 umbrella 73 40 waterproof trousers 42 70 waterproof overclothes 43 75 note-case 22 80 sunglasses 7 20 towel 18 12 socks 4 50 book 30 10 knapsack ‚â§400 dag ¬†?

The tourist can choose to take any combination of items from the list, but only one of each item is available.

He may not cut or diminish the items, so he can only take whole units of any item.

Task

Show which items the tourist can carry in his knapsack so that their total weight does not exceed 400 dag [4 kg], ¬† and their total value is maximized.

[dag = decagram = 10 grams]

Related tasks

¬† Knapsack problem/Bounded ¬† Knapsack problem/Unbounded ¬† Knapsack problem/Continuous ¬† A\* search algorithm

Dynamic Programming solution.

```rust
use std::cmp;
¬†
struct Item {
    name: &'static str,
    weight: usize,
    value: usize
}
¬†
fn knapsack01_dyn(items: &[Item], max_weight: usize) -> Vec<&Item> {
    let mut best_value = vec![vec![0; max_weight + 1]; items.len() + 1];
    for (i, it) in items.iter().enumerate() {
        for w in 1 .. max_weight + 1 {
            best_value[i + 1][w] =
                if it.weight > w {
                    best_value[i][w]
                } else {
                    cmp::max(best_value[i][w], best_value[i][w - it.weight] + it.value)
                }
        }
    }
¬†
    let mut result = Vec::with_capacity(items.len());
    let mut left_weight = max_weight;
¬†
    for (i, it) in items.iter().enumerate().rev() {
        if best_value[i + 1][left_weight]¬†!= best_value[i][left_weight] {
            result.push(it);
            left_weight -= it.weight;
        }
    }
¬†
    result
}
¬†
¬†
fn main () {
    const MAX_WEIGHT: usize = 400;
¬†
    const ITEMS: &[Item] = &[
        Item { name: "map",                    weight: 9,   value: 150 },
        Item { name: "compass",                weight: 13,  value: 35 },
        Item { name: "water",                  weight: 153, value: 200 },
        Item { name: "sandwich",               weight: 50,  value: 160 },
        Item { name: "glucose",                weight: 15,  value: 60 },
        Item { name: "tin",                    weight: 68,  value: 45 },
        Item { name: "banana",                 weight: 27,  value: 60 },
        Item { name: "apple",                  weight: 39,  value: 40 },
        Item { name: "cheese",                 weight: 23,  value: 30 },
        Item { name: "beer",                   weight: 52,  value: 10 },
        Item { name: "suntancream",            weight: 11,  value: 70 },
        Item { name: "camera",                 weight: 32,  value: 30 },
        Item { name: "T-shirt",                weight: 24,  value: 15 },
        Item { name: "trousers",               weight: 48,  value: 10 },
        Item { name: "umbrella",               weight: 73,  value: 40 },
        Item { name: "waterproof trousers",    weight: 42,  value: 70 },
        Item { name: "waterproof overclothes", weight: 43,  value: 75 },
        Item { name: "note-case",              weight: 22,  value: 80 },
        Item { name: "sunglasses",             weight: 7,   value: 20 },
        Item { name: "towel",                  weight: 18,  value: 12 },
        Item { name: "socks",                  weight: 4,   value: 50 },
        Item { name: "book",                   weight: 30,  value: 10 }
    ];
¬†
    let items = knapsack01_dyn(ITEMS, MAX_WEIGHT);
¬†
    // We reverse the order because we solved the problem backward.
    for it in items.iter().rev() {
        println!("{}", it.name);
    }
¬†
    println!("Total weight: {}", items.iter().map(|w| w.weight).sum::<usize>());
    println!("Total value: {}", items.iter().map(|w| w.value).sum::<usize>());
}
```

Output:

```rust
map
compass
water
sandwich
glucose
banana
suntancream
waterproof trousers
waterproof overclothes
note-case
sunglasses
socks
Total weight: 396
Total value: 1030
```

# Date format<a id="sec-156"></a>

Task

Display the ¬† current date ¬† in the formats of:

¬† 2007-11-23 ¬† ¬† and ¬† Sunday, November 23, 2007

```rust
extern crate chrono;
use chrono::*;
fn main(){
    let now¬†: DateTime<UTC> = UTC::now();
    println!("{}", now.format("%Y-%m-%d").to_string());
    println!("{}", now.format("%A,¬†%B¬†%d,¬†%Y").to_string());
}
```

# Hello world/Newline omission<a id="sec-157"></a>

Some languages automatically insert a newline after outputting a string, unless measures are taken to prevent its output.

Task

Display the string ¬† Goodbye, World! ¬† without a trailing newline.

Related tasks

¬† Hello world/Graphical ¬† Hello world/Line Printer ¬† Hello world/Standard error ¬† Hello world/Text

```rust
fn main () {
    print!("Goodbye, World!");
}
```

# Monty Hall problem<a id="sec-158"></a>

Run random simulations of the Monty Hall game. Show the effects of a strategy of the contestant always keeping his first guess so it can be contrasted with the strategy of the contestant always switching his guess.

Suppose you're on a game show and you're given the choice of three doors. Behind one door is a car; behind the others, goats. The car and the goats were placed randomly behind the doors before the show. The rules of the game show are as follows: After you have chosen a door, the door remains closed for the time being. The game show host, Monty Hall, who knows what is behind the doors, now has to open one of the two remaining doors, and the door he opens must have a goat behind it. If both remaining doors have goats behind them, he chooses one randomly. After Monty Hall opens a door with a goat, he will ask you to decide whether you want to stay with your first choice or to switch to the last remaining door. Imagine that you chose Door 1 and the host opens Door 3, which has a goat. He then asks you "Do you want to switch to Door Number 2?" Is it to your advantage to change your choice? (Krauss and Wang 2003:10)

Note that the player may initially choose any of the three doors (not just Door 1), that the host opens a different door revealing a goat (not necessarily Door 3), and that he gives the player a second choice between the two remaining unopened doors.

Task

Simulate at least a thousand games using three doors for each strategy and show the results in such a way as to make it easy to compare the effects of each strategy.

Reference

Monty Hall Problem - Numberphile. (Video).

Library: rand

```rust
extern crate rand;
use rand::Rng;
¬†
#[derive(Clone, Copy, PartialEq)]
enum Prize {Goat , Car}
¬†
const GAMES: usize = 3_000_000;
fn main() {
    let mut switch_wins = 0;
    let mut rng = rand::thread_rng();
¬†
    for _ in 0..GAMES {
        let mut doors = [Prize::Goat; 3];
        *rng.choose_mut(&mut doors).unwrap() = Prize::Car;
¬†
        // You only lose by switching if you pick the car the first time
        if rng.choose(&doors).unwrap()¬†!= &Prize::Car {
            switch_wins += 1;
        }
    }
    println!("I played the game {total} times and won {wins} times ({percent}%).", 
             total   = GAMES, 
             wins    = switch_wins, 
             percent = switch_wins as f64 / GAMES as f64 * 100.0
    );
}
```

# Case-sensitivity of identifiers<a id="sec-159"></a>

Three dogs (Are there three dogs or one dog?) is a code snippet used to illustrate the lettercase sensitivity of the programming language. For a case-sensitive language, the identifiers dog, Dog and DOG are all different and we should get the output:

```
The three dogs are named Benjamin, Samba and Bernie.

```

For a language that is lettercase insensitive, we get the following output:

```
There is just one dog named Bernie.

```

Related task

Unicode variable names

Rust style dictates that identifiers should be written in snake case, e.g. big<sub>dog</sub>, small<sub>dog</sub>; whereas types (structs and enums) should be written in camel case, e.g. BigDog, SmallDog. Failing to comply with this standard does not cause a compiler error, but it will trigger a compiler warning, and the culture is very strongly towards compliance with this standard.

```rust
fn main() {
    let dog = "Benjamin";
    let Dog = "Samba";
    let DOG = "Bernie";
    println!("The three dogs are named {}, {} and {}.", dog, Dog, DOG);
}
```

This triggers two warnings at compilation:

```rust
<anon>:3:9: 3:12 warning: variable `Dog` should have a snake case name such as `dog`, #[warn(non_snake_case)] on by default
<anon>:3     let Dog = "Samba";
                 ^~~
<anon>:4:9: 4:12 warning: variable `DOG` should have a snake case name such as `dog`, #[warn(non_snake_case)] on by default
<anon>:4     let DOG = "Bernie";
                 ^~~
```

The resulting program will compile and run just fine, producing the output:

```rust
The three dogs are named Benjamin, Samba and Bernie.
```

# Infinity<a id="sec-160"></a>

Task

Write a function which tests if infinity is supported for floating point numbers (this step should be omitted for languages where the language specification already demands the existence of infinity, e.g. by demanding IEEE numbers), and if so, returns positive infinity. ¬† Otherwise, return the largest possible positive floating point number.

For languages with several floating point types, use the type of the literal constant ¬† 1.5 ¬† as floating point type.

Related task

¬† Extreme floating point values

Rust has builtin function for floating types which returns infinity. This program outputs 'inf'.

```rust
fn main() {
    let inf = std::f32::INFINITY;
    println!("{}", inf);
}
```

# Formatted numeric output<a id="sec-161"></a>

Task

Express a number in decimal as a fixed-length string with leading zeros.

For example, the number ¬† 7.125 ¬† could be expressed as ¬† 00007.125.

```rust
¬†
fn main() {
    let x = 7.125;
¬†
    println!("{:9}", x);
    println!("{:09}", x);
    println!("{:9}", -x);
    println!("{:09}", -x);
}
¬†
```

Output:

```rust
    7.125
00007.125
   -7.125
-0007.125

```

# Averages/Pythagorean means<a id="sec-162"></a>

Task[edit]

Compute all three of the Pythagorean means of the set of integers 1 through 10 (inclusive).

Show that {\displaystyle A(x<sub>1</sub>,\ldots ,x<sub>n</sub>)&ge; G(x<sub>1</sub>,\ldots ,x<sub>n</sub>)&ge; H(x<sub>1</sub>,\ldots ,x<sub>n</sub>)} for this set of positive integers.

The most common of the three means, the arithmetic mean, is the sum of the list divided by its length:

{\displaystyle A(x<sub>1</sub>,\ldots ,x<sub>n</sub>)={\frac {x<sub>1</sub>+&ctdot; +x<sub>n</sub>}{n}}}

The geometric mean is the {\displaystyle n} th root of the product of the list:

{\displaystyle G(x<sub>1</sub>,\ldots ,x<sub>n</sub>)={\sqrt[{n}]{x<sub>1</sub>&ctdot; x<sub>n</sub>}}}

The harmonic mean is {\displaystyle n} divided by the sum of the reciprocal of each item in the list:

{\displaystyle H(x<sub>1</sub>,\ldots ,x<sub>n</sub>)={\frac {n}{{\frac {1}{x<sub>1</sub>}}+&ctdot; +{\frac {1}{x<sub>n</sub>}}}}}

See also

Tasks for calculating statistical measures

in one go moving (sliding window) moving (cumulative) Mean Arithmetic Statistics/Basic Averages/Arithmetic mean Averages/Pythagorean means

Averages/Simple moving average

Geometric Averages/Pythagorean means

Harmonic Averages/Pythagorean means

Quadratic Averages/Root mean square

Circular Averages/Mean angle Averages/Mean time of day

Median Averages/Median

Mode Averages/Mode

Standard deviation Statistics/Basic

Cumulative standard deviation

```rust
fn main() {
    let mut sum = 0.0;
    let mut prod = 1;
    let mut recsum = 0.0;
    for i in 1..11{
        sum += i as f32;
        prod *= i;
        recsum += 1.0/(i as f32);
    } 
    let avg = sum/10.0;
    let gmean = (prod as f32).powf(0.1);
    let hmean = 10.0/recsum;
    println!("Average: {}, Geometric mean: {}, Harmonic mean: {}", avg, gmean, hmean);
    assert!( ( (avg >= gmean) && (gmean >= hmean) ), "Incorrect calculation");
¬†
}
¬†
```

Output:

```rust
Average: 5.5, Geometric mean:4.528729, Harmonic mean: 3.4141712

```

# Range expansion<a id="sec-163"></a>

A format for expressing an ordered list of integers is to use a comma separated list of either

individual integers Or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. (The range includes all integers in the interval including both endpoints)

The range syntax is to be used only for, and for every range that expands to more than two values.

Example The list of integers:

-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20

Is accurately expressed by the range expression:

-6,-3-1,3-5,7-11,14,15,17-20

(And vice-versa).

Task

Expand the range description:

```
-6,-3--1,3-5,7-11,14,15,17-20 

```

Note that the second element above, is the range from minus 3 to minus 1.

Related task

¬† Range extraction

Rust doesn't have regex in standard library yet.

```rust
use std::str::FromStr;
¬†
// Precondition: range doesn't contain multibyte UTF-8 characters
fn range_expand(range¬†: &str) -> Vec<i32> {
   range.split(',').flat_map(|item| {
        match i32::from_str(item) {
            Ok(n) => n..n+1,
            _ => {
                let dashpos=
                    match item.rfind("--") {
                        Some(p) => p,
                        None => item.rfind('-').unwrap(),
                    };
                let rstart=i32::from_str(
                    unsafe{ item.slice_unchecked(0,dashpos)} ).unwrap();
                let rend=i32::from_str(
                    unsafe{ item.slice_unchecked(dashpos+1,item.len()) } ).unwrap();
                rstart..rend+1
            },
        }
    }).collect()
}
¬†
fn main() {
    println!("{:?}", range_expand("-6,-3--1,3-5,7-11,14,15,17-20"));
}
¬†
```

Output:

```rust
[-6, -3, -2, -1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20]

```

# Create a two-dimensional array at runtime<a id="sec-164"></a>

Get two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.

```rust
use std::env;
¬†
fn main() {
    let mut args = env::args().skip(1).flat_map(|num| num.parse());
    let rows = args.next().expect("Expected number of rows as first argument");
    let cols = args.next().expect("Expected number of columns as second argument");
¬†
    assert_ne!(rows, 0, "rows were zero");
    assert_ne!(cols, 0, "cols were zero");
¬†
    // Creates a vector of vectors with all elements initialized to 0.
    let mut v = vec![vec![0; cols]; rows];
    v[0][0] = 1;
    println!("{}", v[0][0]);
}
```

# Hello world/Standard error<a id="sec-165"></a>

A common practice in computing is to send error messages to a different output stream than normal text console messages.

The normal messages print to what is called "standard output" or "standard out".

The error messages print to "standard error".

This separation can be used to redirect error messages to a different place than normal messages.

Task

Show how to print a message to standard error by printing ¬† ¬† Goodbye, World! ¬† ¬† on that stream.

‚ñ∫ Run this code

```rust
fn main() {
    use¬†::std::io::Write;
    let (stderr, errmsg) = (&mut¬†::std::io::stderr(), "Error writing to stderr");
    writeln!(stderr, "Bye, world!").expect(errmsg);
¬†
    let (goodbye, world) = ("Goodbye", "world");
    writeln!(stderr, "{}, {}!", goodbye, world).expect(errmsg);
}
```

or

```rust
 use std::io::{self, Write};
fn main() {
    io::stderr().write(b"Goodbye, world!").expect("Could not write to stderr");
    // With some finagling, you can do a formatted string here as well
    let goodbye = "Goodbye";
    let world = "world";
    io::stderr().write(&*format!("{}, {}!", goodbye, world).as_bytes()).expect("Could not write to stderr");
    // Clearly, if you want formatted strings there's no reason not to just use writeln!
}
```

# HTTP<a id="sec-166"></a>

Task

Access and print a URL's content (the located resource) to the console.

There is a separate task for HTTPS Requests.

Cargo.toml

```rust
¬†
[dependencies]
hyper = "0.6"
¬†
```

src/main.rs

```rust
¬†
//cargo-deps: hyper="0.6"
// The above line can be used with cargo-script which makes cargo's dependency handling more convenient for small programs
extern crate hyper;
¬†
use std::io::Read;
use hyper::client::Client;
¬†
fn main() {
    let client = Client::new();
    let mut resp = client.get("http://rosettacode.org").send().unwrap();
    let mut body = String::new();
    resp.read_to_string(&mut body).unwrap();
    println!("{}", body);
}
¬†
```

# Zero to the zero power<a id="sec-167"></a>

Some programming languages are not exactly consistent ¬† (with other programming languages) ¬† when ¬† raising zero to the zeroth power: ¬† ¬† 00

Task

Show the results of raising ¬† zero ¬† to the ¬† zeroth ¬† power.

If your computer language objects to ¬† ¬† 0\*\*0 ¬† ¬† or ¬† ¬† 0<sup>0</sup> ¬† ¬† at compile time, ¬† you may also try something like:

```
x = 0
y = 0
z = x**y
say  'z='  z

```

Show the result here. And of course use any symbols or notation that is supported in your computer language for exponentiation.

See also

The Wiki entry: Zero to the power of zero. The Wiki entry: History of differing points of view. The MathWorld‚Ñ¢ entry: exponent laws. Also, in the above MathWorld‚Ñ¢ entry, see formula (9): {\displaystyle x<sup>0</sup>=1} . The OEIS entry: The special case of zero to the zeroth power

```rust
fn main() {
    println!("{}",0u32.pow(0));
}
```

Output:

```rust
1
```

# Greatest subsequential sum<a id="sec-168"></a>

Task

Given a sequence of integers, find a continuous subsequence which maximizes the sum of its elements, that is, the elements of no other single subsequence add up to a value larger than this one.

An empty subsequence is considered to have the sum of ¬† 0; ¬† thus if all elements are negative, the result must be the empty sequence.

Naive brute force

```rust
fn main() {
    let nums = [1,2,39,34,20, -20, -16, 35, 0];
¬†
    let mut max = 0;
    let mut boundaries = 0..0;
¬†
    for length in 0..nums.len() {
        for start in 0..nums.len()-length {
            let sum = (&nums[start..start+length]).iter()
                .fold(0, |sum, elem| sum+elem);
            if sum > max {
                max = sum;
                boundaries = start..start+length;
            }
        }
    }
¬†
    println!("Max subsequence sum: {} for {:?}", max, &nums[boundaries]);;
}
```

Output:

```rust
Max subsequence sum: 96 for [1, 2, 39, 34, 20]
```

# Pythagorean triples<a id="sec-169"></a>

A Pythagorean triple is defined as three positive integers {\displaystyle (a,b,c)} where {\displaystyle a<b<c} , and {\displaystyle a<sup>2</sup>+b<sup>2</sup>=c<sup>2</sup>.}

They are called primitive triples if {\displaystyle a,b,c} are co-prime, that is, if their pairwise greatest common divisors {\displaystyle {\rm {gcd}}(a,b)={\rm {gcd}}(a,c)={\rm {gcd}}(b,c)=1} .

Because of their relationship through the Pythagorean theorem, a, b, and c are co-prime if a and b are co-prime ( {\displaystyle {\rm {gcd}}(a,b)=1} ). ¬†

Each triple forms the length of the sides of a right triangle, whose perimeter is {\displaystyle P=a+b+c} .

Task

The task is to determine how many Pythagorean triples there are with a perimeter no larger than 100 and the number of these that are primitive.

Extra credit

Deal with large values. ¬† Can your program handle a maximum perimeter of 1,000,000? ¬† What about 10,000,000? ¬† 100,000,000?

Note: the extra credit is not for you to demonstrate how fast your language is compared to others; ¬† you need a proper algorithm to solve them in a timely manner.

Related tasks

¬† Euler's sum of powers conjecture ¬† List comprehensions ¬† Pythagorean quadruples

```rust
use std::thread;
¬†
fn f1 (a¬†: u64, b¬†: u64, c¬†: u64, d¬†: u64) -> u64 {
    let mut primitive_count = 0;
    for triangle in [[a - 2*b + 2*c, 2*a - b + 2*c, 2*a - 2*b + 3*c], 
                     [a + 2*b + 2*c, 2*a + b + 2*c, 2*a + 2*b + 3*c],
                     [2*b + 2*c - a, b + 2*c - 2*a, 2*b + 3*c - 2*a]] .iter() {
        let l  = triangle[0] + triangle[1] + triangle[2];
        if l > d { continue; }
        primitive_count +=  1 + f1(triangle[0], triangle[1], triangle[2], d);
    }
    primitive_count
}
¬†
fn f2 (a¬†: u64, b¬†: u64, c¬†: u64, d¬†: u64) -> u64 {
    let mut triplet_count = 0;
    for triangle in [[a - 2*b + 2*c, 2*a - b + 2*c, 2*a - 2*b + 3*c], 
                     [a + 2*b + 2*c, 2*a + b + 2*c, 2*a + 2*b + 3*c],
                     [2*b + 2*c - a, b + 2*c - 2*a, 2*b + 3*c - 2*a]] .iter() {
        let l  = triangle[0] + triangle[1] + triangle[2];
        if l > d { continue; }
        triplet_count +=  (d/l) + f2(triangle[0], triangle[1], triangle[2], d);
    }
    triplet_count
}
¬†
fn main () {
    let new_th_1 = thread::Builder::new().stack_size(32 * 1024 * 1024).spawn (move || {
        let mut i = 100;
        while i <= 100_000_000_000 {
            println!(" Primitive triples below {}¬†: {}", i, f1(3, 4, 5, i) + 1);
            i *= 10;
        }
    }).unwrap();
¬†
    let new_th_2 =thread::Builder::new().stack_size(32 * 1024 * 1024).spawn (move || {
        let mut i = 100;
        while i <= 100_000_000_000 {
            println!(" Triples below {}¬†: {}", i, f2(3, 4, 5, i) + i/12);
            i *= 10;
        }
    }).unwrap();
¬†
    new_th_1.join().unwrap();
    new_th_2.join().unwrap();
}
```

Output:

```rust
 Primitive triples below 100¬†: 7
 Triples below 100¬†: 17
 Primitive triples below 1000¬†: 70
 Triples below 1000¬†: 325
 Primitive triples below 10000¬†: 703
 Triples below 10000¬†: 4858
 Primitive triples below 100000¬†: 7026
 Triples below 100000¬†: 64741
 Primitive triples below 1000000¬†: 70229
 Triples below 1000000¬†: 808950
 Primitive triples below 10000000¬†: 702309
 Triples below 10000000¬†: 9706567
 Primitive triples below 100000000¬†: 7023027
 Triples below 100000000¬†: 113236940
 Primitive triples below 1000000000¬†: 70230484
 Triples below 1000000000¬†: 1294080089
 Primitive triples below 10000000000¬†: 702304875
 Triples below 10000000000¬†: 14557915466
 Primitive triples below 100000000000¬†: 7023049293
 Triples below 100000000000¬†: 161750315680

real	2m22.676s
user	3m39.239s
sys	0m0.024s
```

# User input/Text<a id="sec-170"></a>

In this task, the goal is to input a string and the integer 75000, from the text console.

See also: User input/Graphical

This program shows all the proper error handling.

```rust
use std::io::{self, Write};
use std::fmt::Display;
use std::process;
¬†
fn main() {
    let s = grab_input("Give me a string")
        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));
¬†
    println!("You entered: {}", s.trim());
¬†
    let n: i32 = grab_input("Give me an integer")
        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)))
        .trim()
        .parse()
        .unwrap_or_else(|e| exit_err(&e, 2));
¬†
    println!("You entered: {}", n);
}
¬†
fn grab_input(msg: &str) -> io::Result<String> {
    let mut buf = String::new();
    print!("{}: ", msg);
    try!(io::stdout().flush());
¬†
    try!(io::stdin().read_line(&mut buf));
    Ok(buf)
}
¬†
fn exit_err<T: Display>(msg: T, code: i32) ->¬†! {
    let _ = writeln!(&mut io::stderr(), "Error: {}", msg);
    process::exit(code)
}
```

# Ordered words<a id="sec-171"></a>

An ¬† ordered word ¬† is a word in which the letters appear in alphabetic order.

Examples include ¬† abbey ¬† and ¬† dirt.

Task[edit]

Find and display all the ordered words in the dictionary ¬† unixdict.txt ¬† that have the longest word length.

(Examples that access the dictionary file locally assume that you have downloaded this file yourself.)

The display needs to be shown on this page.

Related tasks

Word plays

Ordered words Palindrome detection Semordnilap Anagrams Anagrams/Deranged anagrams

```rust
const FILE: &'static str = include_str!("./unixdict.txt");
¬†
fn is_ordered(s: &str) -> bool {
    let mut prev = '\x00';
    for c in s.to_lowercase().chars() {
        if c < prev {
            return false;
        }
        prev = c;
    }
¬†
    return true;
}
¬†
fn find_longest_ordered_words(dict: Vec<&str>) -> Vec<&str> {
    let mut result = Vec::new();
    let mut longest_length = 0;
¬†
    for s in dict.into_iter() {
        if is_ordered(&s) {
            let n = s.len();
            if n > longest_length {
                longest_length = n;
                result.truncate(0);
            }
            if n == longest_length {
                result.push(s);
            }
        }
    }
¬†
    return result;
}
¬†
fn main() {
    let lines = FILE.lines().collect();
¬†
    let longest_ordered = find_longest_ordered_words(lines);
¬†
    for s in longest_ordered.iter() {
        println!("{}", s.to_string());
    }
}
```

# Sleep<a id="sec-172"></a>

Task

Write a program that does the following in this order:

Input an amount of time to sleep in whatever units are most natural for your language (milliseconds, seconds, ticks, etc.). This unit should be noted in comments or in a description. Print "Sleeping&#x2026;" Sleep the main thread for the given amount of time. Print "Awake!" End.

Related task

¬† Nautical bell

```rust
use std::{io, time, thread};
¬†
fn main() {
    println!("How long should we sleep in milliseconds?");
¬†
    let mut sleep_string = String::new();
¬†
    io::stdin().read_line(&mut sleep_string)
               .expect("Failed to read line");
¬†
    let sleep_timer: u64 = sleep_string.trim()
                                       .parse()
                                       .expect("Not an integer");
    let sleep_duration = time::Duration::from_millis(sleep_timer);
¬†
    println!("Sleeping...");
    thread::sleep(sleep_duration);
    println!("Awake!");
}
```

# Align columns<a id="sec-173"></a>

Given a text file of many lines, where fields within a line are delineated by a single 'dollar' character, write a program that aligns each column of fields by ensuring that words in each column are separated by at least one space. Further, allow for each word in a column to be either left justified, right justified, or center justified within its column.

Use the following text to test your programs:

```
Given$a$text$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.
```

Note that:

The example input texts lines may, or may not, have trailing dollar characters. All columns should share the same alignment. Consecutive space characters produced adjacent to the end of lines are insignificant for the purposes of the task. Output text will be viewed in a mono-spaced font on a plain text editor or basic terminal. The minimum space between columns should be computed from the text and not hard-coded. It is not a requirement to add separating characters between or around columns.

```rust
use std::iter::{Extend, repeat};
¬†
enum AlignmentType { Left, Center, Right }
¬†
fn get_column_widths(text: &str) -> Vec<usize> {
    let mut widths = Vec::new();
    for line in text.lines().map(|s| s.trim_matches(' ').trim_right_matches('$')) {
        let lens = line.split('$').map(|s| s.chars().count());
        for    (idx, len) in lens.enumerate() {
            if idx < widths.len() {
                widths[idx] = std::cmp::max(widths[idx], len);
            }
            else {
                widths.push(len);
            }
        }
    }
    widths
}
¬†
fn align_columns(text: &str, alignment: AlignmentType) -> String {
    let widths = get_column_widths(text);
    let mut result = String::new();
    for line in text.lines().map(|s| s.trim_matches(' ').trim_right_matches('$')) {
        for (s, w) in line.split('$').zip(widths.iter()) {
            let blank_count = w - s.chars().count();
            let (pre, post) = match alignment {
                AlignmentType::Left => (0, blank_count),
                AlignmentType::Center => (blank_count / 2, (blank_count + 1) / 2),
                AlignmentType::Right => (blank_count, 0),
            };
            result.extend(repeat(' ').take(pre));
            result.push_str(s);
            result.extend(repeat(' ').take(post));
            result.push(' ');
        }
        result.push_str("\n");
    }
    result
}
¬†
fn main() {
    let text = r#"Given$a$text$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column."#;
¬†
    println!("{}", align_columns(text, AlignmentType::Left));
    println!("{}", repeat('-').take(110).collect::<String>());
    println!("{}", align_columns(text, AlignmentType::Center));
    println!("{}", repeat('-').take(110).collect::<String>());
    println!("{}", align_columns(text, AlignmentType::Right));
}
```

Output:

```rust
Given      a          text       file   of     many      lines,     where    fields  within  a      line
are        delineated by         a      single 'dollar'  character, write    a       program
that       aligns     each       column of     fields    by         ensuring that    words   in     each
column     are        separated  by     at     least     one        space.
Further,   allow      for        each   word   in        a          column   to      be      either left
justified, right      justified, or     center justified within     its      column.

---------------------------------------------------------------------------------------------------------
  Given        a         text     file    of     many      lines,    where   fields  within    a    line
   are     delineated     by       a    single 'dollar'  character,  write      a    program
   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each
  column      are     separated    by     at     least      one      space.
 Further,    allow       for      each   word     in         a       column    to      be    either left
justified,   right    justified,   or   center justified   within     its    column.

---------------------------------------------------------------------------------------------------------
     Given          a       text   file     of      many     lines,    where  fields  within      a line
       are delineated         by      a single  'dollar' character,    write       a program
      that     aligns       each column     of    fields         by ensuring    that   words     in each
    column        are  separated     by     at     least        one   space.
  Further,      allow        for   each   word        in          a   column      to      be either left
justified,      right justified,     or center justified     within      its column.

```

# String matching<a id="sec-174"></a>

Task

Given two strings, demonstrate the following three types of string matching:

¬† Determining if the first string starts with second string ¬† Determining if the first string contains the second string at any location ¬† Determining if the first string ends with the second string

Optional requirements:

¬† Print the location of the match for part 2 ¬† Handle multiple occurrences of a string for part 2.

```rust
fn print_match(possible_match: Option<usize>) {
    match possible_match {
        Some(match_pos) => println!("Found match at pos {}", match_pos),
        None => println!("Did not find any matches")
    }
}
¬†
fn main() {
    let s1 = "abcd";
    let s2 = "abab";
    let s3 = "ab";
¬†
    // Determining if the first string starts with second string
    assert!(s1.starts_with(s3));
    // Determining if the first string contains the second string at any location
    assert!(s1.contains(s3));
    // Print the location of the match 
    print_match(s1.find(s3)); // Found match at pos 0
    print_match(s1.find(s2)); // Did not find any matches
    // Determining if the first string ends with the second string
    assert!(s2.ends_with(s3));
}
```

```rust
¬†
fn main(){
    let hello = String::from("Hello world");
    println!(" Start with \"he\" {} \n Ends with \"rd\" {}\n Contains \"wi\" {}", 
                                                        hello.starts_with("He"),
                                                        hello.ends_with("ld"),
                                                        hello.contains("wi"));
}
```

Output:

```rust
Start with "he" true 
Ends with "ld" true
Contains "wi" false

```

# Enumerations<a id="sec-175"></a>

Task

Create an enumeration of constants with and without explicit values.

```rust
enum Fruits {
    Apple,
    Banana,
    Cherry
}
¬†
enum FruitsWithNumbers {
    Strawberry = 0,
    Pear = 27,
}
¬†
fn main() {
    // Access to numerical value by conversion
    println!("{}", FruitsWithNumbers::Pear as u8);
}
```

# Sum digits of an integer<a id="sec-176"></a>

Task

Take a ¬† Natural Number ¬† in a given base and return the sum of its digits:

¬† 110 ¬† ¬† ¬† ¬† sums to ¬† 1 ¬† 123410 ¬† sums to ¬† 10 ¬† fe16 ¬† ¬† ¬† sums to ¬† 29 ¬† f0e16 ¬† ¬† sums to ¬† 29

Using an Iterator[edit]

This solution creates an iterator which yields the digits of a given number using a given base and then utilizes the \`sum\` method which is implemented automatically on iterators.

```rust
struct DigitIter(usize, usize);
¬†
impl Iterator for DigitIter {
    type Item = usize;
    fn next(&mut self) -> Option<Self::Item> {
        if self.0 == 0 {
            None
        } else {
            let ret = self.0¬†% self.1;
            self.0 /= self.1;
            Some(ret)
        }
    }
}
¬†
fn main() {
    println!("{}", DigitIter(1234,10).sum::<usize>());
}
```

# Tree traversal<a id="sec-177"></a>

Task

Implement a binary tree where each node carries an integer, ¬† and implement:

¬† pre-order, ¬† in-order, ¬† post-order, ¬† ¬† and ¬† level-order ¬† traversal.

Use those traversals to output the following tree:

```
        1
       / \
      /   \
     /     \
    2       3
   / \     /
  4   5   6
 /       / \
7       8   9

```

The correct output should look like this:

```
preorder:    1 2 4 7 5 3 6 8 9
inorder:     7 4 2 5 1 8 6 9 3
postorder:   7 4 5 2 8 9 6 3 1
level-order: 1 2 3 4 5 6 7 8 9

```

See also

¬† Wikipedia article: ¬† Tree traversal.

This solution uses iteration (rather than recursion) for all traversal types.

```rust
¬†
#![feature(box_syntax, box_patterns)]
¬†
use std::collections::VecDeque;
¬†
#[derive(Debug)]
struct TreeNode<T> {
    value: T,
    left: Option<Box<TreeNode<T>>>,
    right: Option<Box<TreeNode<T>>>,
}
¬†
enum TraversalMethod {
    PreOrder,
    InOrder,
    PostOrder,
    LevelOrder,
}
¬†
impl<T> TreeNode<T> {
    pub fn new(arr: &[[i8; 3]]) -> TreeNode<i8> {
¬†
        let l = match arr[0][1] {
            -1 => None,
            i @ _ => Some(Box::new(TreeNode::<i8>::new(&arr[(i - arr[0][0]) as usize..]))),
        };
        let r = match arr[0][2] {
            -1 => None,
            i @ _ => Some(Box::new(TreeNode::<i8>::new(&arr[(i - arr[0][0]) as usize..]))),
        };
¬†
        TreeNode {
            value: arr[0][0],
            left: l,
            right: r,
        }
    }
¬†
    pub fn traverse(&self, tr: &TraversalMethod) -> Vec<&TreeNode<T>> {
        match tr {
            &TraversalMethod::PreOrder => self.iterative_preorder(),
            &TraversalMethod::InOrder => self.iterative_inorder(),
            &TraversalMethod::PostOrder => self.iterative_postorder(),
            &TraversalMethod::LevelOrder => self.iterative_levelorder(),
        }
    }
¬†
    fn iterative_preorder(&self) -> Vec<&TreeNode<T>> {
        let mut stack: Vec<&TreeNode<T>> = Vec::new();
        let mut res: Vec<&TreeNode<T>> = Vec::new();
¬†
        stack.push(self);
        while¬†!stack.is_empty() {
            let node = stack.pop().unwrap();
            res.push(node);
            match node.right {
                None => {}
                Some(box ref n) => stack.push(n),
            }
            match node.left {
                None => {}
                Some(box ref n) => stack.push(n),
            }
        }
        res
    }
¬†
    // Leftmost to rightmost
    fn iterative_inorder(&self) -> Vec<&TreeNode<T>> {
        let mut stack: Vec<&TreeNode<T>> = Vec::new();
        let mut res: Vec<&TreeNode<T>> = Vec::new();
        let mut p = self;
¬†
        loop {
            // Stack parents and right children while left-descending
            loop {
                match p.right {
                    None => {}
                    Some(box ref n) => stack.push(n),
                }
                stack.push(p);
                match p.left {
                    None => break,
                    Some(box ref n) => p = n,
                }
            }
            // Visit the nodes with no right child
            p = stack.pop().unwrap();
            while¬†!stack.is_empty() && p.right.is_none() {
                res.push(p);
                p = stack.pop().unwrap();
            }
            // First node that can potentially have a right child:
            res.push(p);
            if stack.is_empty() {
                break;
            } else {
                p = stack.pop().unwrap();
            }
        }
        res
    }
¬†
    // Left-to-right postorder is same sequence as right-to-left preorder, reversed
    fn iterative_postorder(&self) -> Vec<&TreeNode<T>> {
        let mut stack: Vec<&TreeNode<T>> = Vec::new();
        let mut res: Vec<&TreeNode<T>> = Vec::new();
¬†
        stack.push(self);
        while¬†!stack.is_empty() {
            let node = stack.pop().unwrap();
            res.push(node);
            match node.left {
                None => {}
                Some(box ref n) => stack.push(n),
            }
            match node.right {
                None => {}
                Some(box ref n) => stack.push(n),
            }
        }
        let rev_iter = res.iter().rev();
        let mut rev: Vec<&TreeNode<T>> = Vec::new();
        for elem in rev_iter {
            rev.push(elem);
        }
        rev
    }
¬†
    fn iterative_levelorder(&self) -> Vec<&TreeNode<T>> {
        let mut queue: VecDeque<&TreeNode<T>> = VecDeque::new();
        let mut res: Vec<&TreeNode<T>> = Vec::new();
¬†
        queue.push_back(self);
        while¬†!queue.is_empty() {
            let node = queue.pop_front().unwrap();
            res.push(node);
            match node.left {
                None => {}
                Some(box ref n) => queue.push_back(n),
            }
            match node.right {
                None => {}
                Some(box ref n) => queue.push_back(n),
            }
        }
        res
    }
}
¬†
fn main() {
    // Array representation of task tree
    let arr_tree = [[1, 2, 3],
                    [2, 4, 5],
                    [3, 6, -1],
                    [4, 7, -1],
                    [5, -1, -1],
                    [6, 8, 9],
                    [7, -1, -1],
                    [8, -1, -1],
                    [9, -1, -1]];
¬†
    let root = TreeNode::<i8>::new(&arr_tree);
¬†
    for method_label in [(TraversalMethod::PreOrder, "pre-order:"),
                         (TraversalMethod::InOrder, "in-order:"),
                         (TraversalMethod::PostOrder, "post-order:"),
                         (TraversalMethod::LevelOrder, "level-order:")]
                            .iter() {
        print!("{}\t", method_label.1);
        for n in root.traverse(&method_label.0) {
            print!(" {}", n.value);
        }
        print!("\n");
    }
}
¬†
```

Output is same as Ruby et al.

# Priority queue<a id="sec-178"></a>

A priority queue is somewhat similar to a queue, with an important distinction: each item is added to a priority queue with a priority level, and will be later removed from the queue with the highest priority element first. That is, the items are (conceptually) stored in the queue in priority order instead of in insertion order.

Task: Create a priority queue. The queue must support at least two operations:

Insertion. An element is added to the queue with a priority (a numeric value). Top item removal. Deletes the element or one of the elements with the current top priority and return it.

Optionally, other operations may be defined, such as peeking (find what current top priority/top element is), merging (combining two priority queues into one), etc.

To test your implementation, insert a number of elements into the queue, each with some random priority. Then dequeue them sequentially; now the elements should be sorted by priority. You can use the following task/priority items as input data:

```
Priority    Task
  3        Clear drains
  4        Feed cat
  5        Make tea
  1        Solve RC tasks
  2        Tax return

```

The implementation should try to be efficient. A typical implementation has O(log n) insertion and extraction time, where n is the number of items in the queue. You may choose to impose certain limits such as small range of allowed priority levels, limited capacity, etc. If so, discuss the reasons behind it.

```rust
use std::collections::BinaryHeap;
use std::cmp::Ordering;
use std::borrow::Cow;
¬†
#[derive(Eq, PartialEq)]
struct Item<'a> {
    priority: usize,
    task: Cow<'a, str>, // Takes either borrowed or owned string
}
¬†
impl<'a> Item<'a> {
    fn new<T>(p: usize, t: T) -> Self
        where T: Into<Cow<'a, str>>
    {
        Item {
            priority: p,
            task: t.into(),
        }
    }
}
¬†
// Manually implpement Ord so we have a min heap
impl<'a> Ord for Item<'a> {
    fn cmp(&self, other: &Self) -> Ordering {
        other.priority.cmp(&self.priority)
    }
}
¬†
// PartialOrd is required by Ord
impl<'a> PartialOrd for Item<'a> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}
¬†
¬†
fn main() {
    let mut queue = BinaryHeap::with_capacity(5);
    queue.push(Item::new(3, "Clear drains"));
    queue.push(Item::new(4, "Feed cat"));
    queue.push(Item::new(5, "Make tea"));
    queue.push(Item::new(1, "Solve RC tasks"));
    queue.push(Item::new(2, "Tax return"));
¬†
    for item in queue {
        println!("{}", item.task);
    }
}
```

Output:

```rust
Solve RC tasks
Tax return
Make tea
Feed cat
Clear drains
```

# Pangram checker<a id="sec-179"></a>

A pangram is a sentence that contains all the letters of the English alphabet at least once.

For example: ¬† The quick brown fox jumps over the lazy dog.

Task

Write a function or method to check a sentence to see if it is a ¬† pangram ¬† (or not) ¬† and show its use.

```rust
#![feature(test)]
¬†
extern crate test;
¬†
use std::collections::HashSet;
¬†
pub fn is_pangram_via_bitmask(s: &str) -> bool {
¬†
    // Create a mask of set bits and convert to false as we find characters.
    let mut mask = (1 << 26) - 1;
¬†
    for chr in s.chars() {
        let val = chr as u32 &¬†!0x20; /* 0x20 converts lowercase to upper */
        if val <= 'Z' as u32 && val >= 'A' as u32 {
            mask = mask &¬†!(1 << (val - 'A' as u32));
        }
    }
¬†
    mask == 0
}
¬†
pub fn is_pangram_via_hashset(s: &str) -> bool {
¬†
    // Insert lowercase letters into a HashSet, then check if we have at least 26.
    let letters = s.chars()
        .flat_map(|chr| chr.to_lowercase())
        .filter(|&chr| chr >= 'a' && chr <= 'z')
        .fold(HashSet::new(), |mut letters, chr| {
            letters.insert(chr);
            letters
        });
¬†
    letters.len() == 26
}
¬†
pub fn is_pangram_via_sort(s: &str) -> bool {
¬†
    // Copy chars into a vector, convert to lowercase, sort, and remove duplicates.
    let mut chars: Vec<char> = s.chars()
        .flat_map(|chr| chr.to_lowercase())
        .filter(|&chr| chr >= 'a' && chr <= 'z')
        .collect();
¬†
    chars.sort();
    chars.dedup();
¬†
    chars.len() == 26
}
¬†
fn main() {
¬†
    let examples = ["The quick brown fox jumps over the lazy dog",
                    "The quick white cat jumps over the lazy dog"];
¬†
    for &text in examples.iter() {
        let is_pangram_sort = is_pangram_via_sort(text);
        println!("Is \"{}\" a pangram via sort? - {}", text, is_pangram_sort);
¬†
        let is_pangram_bitmask = is_pangram_via_bitmask(text);
        println!("Is \"{}\" a pangram via bitmask? - {}",
                 text,
                 is_pangram_bitmask);
¬†
        let is_pangram_hashset = is_pangram_via_hashset(text);
        println!("Is \"{}\" a pangram via bitmask? - {}",
                 text,
                 is_pangram_hashset);
    }
}
```

# Create a file<a id="sec-180"></a>

In this task, the job is to create a new empty file called "output.txt" of size 0 bytes and an empty directory called "docs". This should be done twice: once "here", i.e. in the current working directory and once in the filesystem root.

```rust
use std::io::{self, Write};
use std::fs::{DirBuilder, File};
use std::path::Path;
use std::{process,fmt};
¬†
const FILE_NAME: &'static str = "output.txt";
const DIR_NAME¬†: &'static str = "docs";
¬†
fn main() {
    create(".").and(create("/"))
               .unwrap_or_else(|e| error_handler(e,1));
}
¬†
¬†
fn create<P>(root: P) -> io::Result<File>
    where P: AsRef<Path>
{
    let f_path = root.as_ref().join(FILE_NAME);
    let d_path = root.as_ref().join(DIR_NAME);
    DirBuilder::new().create(d_path).and(File::create(f_path))
}
¬†
fn error_handler<E: fmt::Display>(error: E, code: i32) ->¬†! {
    let _ = writeln!(&mut io::stderr(), "Error: {}", error);
    process::exit(code)
}
```

# Amicable pairs<a id="sec-181"></a>

Two integers {\displaystyle N} and {\displaystyle M} are said to be amicable pairs if {\displaystyle N&ne; M} and the sum of the proper divisors of {\displaystyle N} ( {\displaystyle \mathrm {sum} (\mathrm {propDivs} (N))} ) {\displaystyle =M} as well as {\displaystyle \mathrm {sum} (\mathrm {propDivs} (M))=N} .

Example

1184 and 1210 are an amicable pair, with proper divisors:

¬† 1, 2, 4, 8, 16, 32, 37, 74, 148, 296, 592 ¬† and ¬† 1, 2, 5, 10, 11, 22, 55, 110, 121, 242, 605 ¬† respectively.

Task

Calculate and show here the Amicable pairs below 20,000; (there are eight).

Related tasks

Proper divisors Abundant, deficient and perfect number classifications Aliquot sequence classifications and its amicable classification.

```rust
fn sum_of_divisors(val: u32) -> u32 {
    (1..val/2+1).filter(|n| val¬†% n == 0)
                .fold(0, |sum, n| sum + n)
}
¬†
fn main() {
    let iter = (1..20_000).map(|i| (i, sum_of_divisors(i)))
                          .filter(|&(i, div_sum)| i > div_sum);
¬†
    for (i, sum1) in iter {
        if sum_of_divisors(sum1) == i {
           println!("{} {}", i, sum1);
        }
    }
}
```

Output:

```rust
284 220
1210 1184
2924 2620
5564 5020
6368 6232
10856 10744
14595 12285
18416 17296

```

# Empty string<a id="sec-182"></a>

Languages may have features for dealing specifically with empty strings (those containing no characters).

Task ¬† Demonstrate how to assign an empty string to a variable. ¬† Demonstrate how to check that a string is empty. ¬† Demonstrate how to check that a string is not empty.

```rust
let s = "";
println!("is empty: {}", s.is_empty());
let t = "x";
println!("is empty: {}", t.is_empty());
let a = String::new();
println!("is empty: {}", a.is_empty());
let b = "x".to_string();
println!("is empty: {}", b.is_empty());
println!("is not empty: {}",¬†!b.is_empty());
```

# Random numbers<a id="sec-183"></a>

Task

Generate a collection filled with ¬† 1000 ¬† normally distributed random (or pseudo-random) numbers with a mean of ¬† 1.0 ¬† and a ¬† standard deviation ¬† of ¬† 0.5

Many libraries only generate uniformly distributed random numbers.

If so, use this formula to convert them to a normal distribution.

Related task

¬† Standard deviation

Library: rand

Using a for-loop:

```rust
extern crate rand;
use rand::distributions::{Normal, IndependentSample};
¬†
fn main() {
    let mut rands = [0.0; 1000];
    let normal = Normal::new(1.0, 0.5);
    let mut rng = rand::thread_rng();
    for num in rands.iter_mut() {
        *num = normal.ind_sample(&mut rng);
    }
}
```

Using iterators:

```rust
extern crate rand;
use rand::distributions::{Normal, IndependentSample};
¬†
fn main() {
    let rands: Vec<_> = {
        let normal = Normal::new(1.0, 0.5);
        let mut rng = rand::thread_rng();
        (0..1000).map(|_| normal.ind_sample(&mut rng)).collect()
    };
}
```

# Evolutionary algorithm<a id="sec-184"></a>

Starting with:

The target string: "METHINKS IT IS LIKE A WEASEL". An array of random characters chosen from the set of upper-case letters together with the space, and of the same length as the target string. (Call it the parent). A fitness function that computes the ‚Äòcloseness‚Äô of its argument to the target string. A mutate function that given a string and a mutation rate returns a copy of the string, with some characters probably mutated. While the parent is not yet the target:

copy the parent C times, each time allowing some random probability that another character might be substituted using mutate. Assess the fitness of the parent and all the copies to the target and make the most fit string the new parent, discarding the others. repeat until the parent converges, (hopefully), to the target.

See also

¬† Wikipedia entry: ¬† Weasel algorithm. ¬† Wikipedia entry: ¬† Evolutionary algorithm.

Note: to aid comparison, try and ensure the variables and functions mentioned in the task description appear in solutions

A cursory examination of a few of the solutions reveals that the instructions have not been followed rigorously in some solutions. Specifically,

While the parent is not yet the target:

copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.

Note that some of the the solutions given retain characters in the mutated string that are correct in the target string. However, the instruction above does not state to retain any of the characters while performing the mutation. Although some may believe to do so is implied from the use of "converges"

```
(:* repeat until the parent converges, (hopefully), to the target.

```

Strictly speaking, the new parent should be selected from the new pool of mutations, and then the new parent used to generate the next set of mutations with parent characters getting retained only by not being mutated. It then becomes possible that the new set of mutations has no member that is fitter than the parent!

As illustration of this error, the code for 8th has the following remark.

```
Create a new string based on the TOS, changing randomly any characters which
don't already match the target:

```

NOTE: this has been changed, the 8th version is completely random now

Clearly, this algo will be applying the mutation function only to the parent characters that don't match to the target characters!

To ensure that the new parent is never less fit than the prior parent, both the parent and all of the latest mutations are subjected to the fitness test to select the next parent.

```rust
//! Author¬†: Thibault Barbie
//!
//! A simple evolutionary algorithm written in Rust.
¬†
extern crate rand;
¬†
use rand::Rng;
¬†
fn main() {
    let target = "METHINKS IT IS LIKE A WEASEL";
    let copies = 100;
    let mutation_rate = 20; // 1/20 = 0.05 = 5%
¬†
    let mut rng = rand::weak_rng();
¬†
    // Generate first sentence, mutating each character
    let start = mutate(&mut rng, target, 1); // 1/1 = 1 = 100%
¬†
    println!("{}", target);
    println!("{}", start);
¬†
    evolve(&mut rng, target, start, copies, mutation_rate);
}
¬†
/// Evolution algorithm
///
/// Evolves `parent` to match `target`.  Returns the number of evolutions performed.
fn evolve<R: Rng>(
    rng: &mut R,
    target: &str,
    mut parent: String,
    copies: usize,
    mutation_rate: u32,
) -> usize {
    let mut counter = 0;
    let mut parent_fitness = target.len() + 1;
¬†
    loop {
        counter += 1;
¬†
        let (best_fitness, best_sentence) = (0..copies)
            .map(|_| {
                // Copy and mutate a new sentence.
                let sentence = mutate(rng, &parent, mutation_rate);
                // Find the fitness of the new mutation
                (fitness(target, &sentence), sentence)
            })
            .min_by_key(|&(f, _)| f) // find the closest mutation to the target
            .unwrap(); // fails if `copies == 0`
¬†
        // If the best mutation of this generation is better than `parent` then "the fittest
        // survives" and the next parent becomes the best of this generation.
        if best_fitness < parent_fitness {
            parent = best_sentence;
            parent_fitness = best_fitness;
            println!(
                "{}¬†: generation {} with fitness {}",
                parent, counter, best_fitness
            );
¬†
            if best_fitness == 0 {
                return counter;
            }
        }
    }
}
¬†
/// Computes the fitness of a sentence against a target string, returning the number of
/// incorrect characters.
fn fitness(target: &str, sentence: &str) -> usize {
    sentence
        .chars()
        .zip(target.chars())
        .filter(|&(c1, c2)| c1¬†!= c2)
        .count()
}
¬†
/// Mutation algorithm.
///
/// It mutates each character of a string, according to a `mutation_rate`.
fn mutate<R: Rng>(rng: &mut R, sentence: &str, mutation_rate: u32) -> String {
    let maybe_mutate = |c| {
        if rng.gen_weighted_bool(mutation_rate) {
            random_char(rng)
        } else {
            c
        }
    };
    sentence.chars().map(maybe_mutate).collect()
}
¬†
/// Generates a random letter or space.
fn random_char<R: Rng>(rng: &mut R) -> char {
    // Returns a value in the range [A, Z] + an extra slot for the space character.  (The `u8`
    // values could be cast to larger integers for a better chance of the RNG hitting the proper
    // range).
    match rng.gen_range(b'A', b'Z' + 2) {
        c if c == b'Z' + 1 => ' ', // the `char` after 'Z'
        c => c as char,
    }
}
```

Output:

METHINKS IT IS LIKE A WEASEL ZPNUDZUKIHR SRD SZNRWOZDAXJX ZPNUDZKKIHR SRD SZNJWOZDAXJX¬†: generation 1 with fitness 25 ZPHUDZKKIHR SRD SZNJWOWDAXJX¬†: generation 2 with fitness 24 ZPGUDZKSIHR SRD SZNJWOWDAXJX¬†: generation 3 with fitness 23 ZPGUDZKSIIR SRD SUNJWOWXAXJX¬†: generation 4 with fitness 22 ZEGUDZKSIIR SRD SUNJWOWXAXJX¬†: generation 5 with fitness 21 ZECUDZKSIIR SRD SUN WOWEAXJX¬†: generation 6 with fitness 19 ZECUDZKSIIN SRD SUN AOWEAXJX¬†: generation 7 with fitness 18 ZECUDSKSIIN IRD SUN AOWEAXJX¬†: generation 8 with fitness 17 ZECUDSKSIIN IRDLSUN AOWEAXJX¬†: generation 9 with fitness 16 ZETUDSKSIIN IRDLSUN AOWEAXJX¬†: generation 10 with fitness 15 ZETUDSKSIIN IRDLSUN A WEAXJX¬†: generation 11 with fitness 14 ZETUDSKSIIT IRDLSUN A WEAXJX¬†: generation 12 with fitness 13 ZETUDSKSIIT IRDLSUN A WEAXER¬†: generation 13 with fitness 12 ZETHDSKSIIT IRDLSUN A WEAXER¬†: generation 14 with fitness 11 ZETHDSKSIIT IRDLSKN A WEAXER¬†: generation 15 with fitness 10 ZETHDSKSIIT IRDLIKN A WEAXER¬†: generation 17 with fitness 9 ZETHDSKSIIT IR LIKN A WEAXER¬†: generation 19 with fitness 8 ZETHDSKS IT IR LIKN A WEAXER¬†: generation 23 with fitness 7 ZETHDSKS IT IR LIKN A WEASER¬†: generation 26 with fitness 6 ZETHDOKS IT IR LIKE A WEASER¬†: generation 28 with fitness 5 ZETHDNKS IT IR LIKE A WEASER¬†: generation 31 with fitness 4 ZETHCNKS IT IR LIKE A WEASEL¬†: generation 45 with fitness 3 ZETHCNKS IT IS LIKE A WEASEL¬†: generation 46 with fitness 2 METHCNKS IT IS LIKE A WEASEL¬†: generation 68 with fitness 1 METHINKS IT IS LIKE A WEASEL¬†: generation 79 with fitness 0

# Gray code<a id="sec-185"></a>

Gray code

Karnaugh maps

Create functions to encode a number to and decode a number from Gray code.

Display the normal binary representations, Gray code representations, and decoded Gray code values for all 5-bit binary numbers (0-31 inclusive, leading 0's not necessary).

There are many possible Gray codes. The following encodes what is called "binary reflected Gray code."

Encoding (MSB is bit 0, b is binary, g is Gray code):

```
if b[i-1] = 1
   g[i] = not b[i]
else
   g[i] = b[i]
```

Or:

```
g = b xor (b logically right shifted 1 time)
```

Decoding (MSB is bit 0, b is binary, g is Gray code):

```
b[0] = g[0]

for other bits:
b[i] = g[i] xor b[i-1]
```

Reference

Converting Between Gray and Binary Codes. It includes step-by-step animations.

Works with: Rust version 1.1

```rust
fn gray_encode(integer: u64) -> u64 {
    (integer >> 1) ^ integer
}
¬†
fn gray_decode(integer: u64) -> u64 {
    match integer {
        0 => 0,
        _ => integer ^ gray_decode(integer >> 1)
    }
}
¬†
fn main() {
    for i in 0..32 {
        println!("{:2} {:0>5b} {:0>5b} {:2}", i, i, gray_encode(i),
            gray_decode(i));
    }
¬†
}
```

# Harshad or Niven series<a id="sec-186"></a>

The Harshad or Niven numbers are positive integers ‚â• 1 that are divisible by the sum of their digits.

For example, ¬† 42 ¬† is a Harshad number as ¬† 42 ¬† is divisible by ¬† (4 + 2) ¬† without remainder. Assume that the series is defined as the numbers in increasing order.

Task

The task is to create a function/method/procedure to generate successive members of the Harshad sequence.

Use it to list the first twenty members of the sequence and list the first Harshad number greater than 1000.

Show your output here.

```rust
¬†
fn is_hashard (n¬†: u32) -> bool {
    let sum_digits = n.to_string()
                      .chars()
                      .map(|c| c.to_digit(10).unwrap())
                      .fold(0, |a, b| a+b);
    n¬†% sum_digits == 0
}
¬†
fn main() {
    for i in (1u32..).filter(|num| is_hashard(*num)).take(20) {
        println!("Hashard¬†: {}", i);
    }
    for i in (1_001u32..).filter(|num| is_hashard(*num)).take(1) {
        println!("First Hashard bigger than 1_000¬†: {}", i);
    }
}
¬†
```

Output:

```rust
Hashard¬†: 1
Hashard¬†: 2
Hashard¬†: 3
Hashard¬†: 4
Hashard¬†: 5
Hashard¬†: 6
Hashard¬†: 7
Hashard¬†: 8
Hashard¬†: 9
Hashard¬†: 10
Hashard¬†: 12
Hashard¬†: 18
Hashard¬†: 20
Hashard¬†: 21
Hashard¬†: 24
Hashard¬†: 27
Hashard¬†: 30
Hashard¬†: 36
Hashard¬†: 40
Hashard¬†: 42
First Hashard bigger than 1_000¬†: 1002

```

# Vector products<a id="sec-187"></a>

A vector is defined as having three dimensions as being represented by an ordered collection of three numbers: ¬† (X, Y, Z).

If you imagine a graph with the ¬† x ¬† and ¬† y ¬† axis being at right angles to each other and having a third, ¬† z ¬† axis coming out of the page, then a triplet of numbers, ¬† (X, Y, Z) ¬† would represent a point in the region, ¬† and a vector from the origin to the point.

Given the vectors:

```
A = (a1,  a2,  a3) 
B = (b1,  b2,  b3) 
C = (c1,  c2,  c3) 

```

then the following common vector products are defined:

The dot product ¬† ¬† ¬† (a scalar quantity)

A ‚Ä¢ B = a1b1 ¬† + ¬† a2b2 ¬† + ¬† a3b3

The cross product ¬† ¬† ¬† (a vector quantity)

A x B = (a2b3¬† - ¬† a3b2, ¬† ¬† a3b1 ¬† - ¬† a1b3, ¬† ¬† a1b2 ¬† - ¬† a2b1)

The scalar triple product ¬† ¬† ¬† (a scalar quantity)

A ‚Ä¢ (B x C)

The vector triple product ¬† ¬† ¬† (a vector quantity)

A x (B x C)

Task

Given the three vectors:

```
a = ( 3,    4,    5)
b = ( 4,    3,    5)
c = (-5,  -12,  -13)

```

Create a named function/subroutine/method to compute the dot product of two vectors. Create a function to compute the cross product of two vectors. Optionally create a function to compute the scalar triple product of three vectors. Optionally create a function to compute the vector triple product of three vectors. Compute and display: a ‚Ä¢ b Compute and display: a x b Compute and display: a ‚Ä¢ (b x c), the scalar triple product. Compute and display: a x (b x c), the vector triple product.

References

¬† A starting page on Wolfram MathWorld is ¬† Vector Multiplication . ¬† Wikipedia ¬† dot product,

¬† Wikipedia ¬† cross product ¬† Wikipedia ¬† triple product entries.

Related tasks

¬† Dot product ¬† Quaternion type

```rust
#[derive(Debug)]
struct Vector {
    x: f64,
    y: f64,
    z: f64,
}
¬†
impl Vector {
    fn new(x: f64, y: f64, z: f64) -> Self {
        Vector {
            x: x,
            y: y,
            z: z,
        }
    }
¬†
    fn dot_product(&self, other: &Vector) -> f64 {
        (self.x * other.x) + (self.y * other.y) + (self.z * other.z)
    }
¬†
    fn cross_product(&self, other: &Vector) -> Vector {
        Vector::new(self.y * other.z - self.z * other.y,
                    self.z * other.x - self.x * other.z,
                    self.x * other.y - self.y * other.x)
    }
¬†
    fn scalar_triple_product(&self, b: &Vector, c: &Vector) -> f64 {
        self.dot_product(&b.cross_product(&c))
    }
¬†
    fn vector_triple_product(&self, b: &Vector, c: &Vector) -> Vector {
        self.cross_product(&b.cross_product(&c))
    }
}
¬†
fn main(){
    let a = Vector::new(3.0, 4.0, 5.0);
    let b = Vector::new(4.0, 3.0, 5.0);
    let c = Vector::new(-5.0, -12.0, -13.0);
¬†
    println!("a . b = {}", a.dot_product(&b));
    println!("a x b = {:?}", a.cross_product(&b));
    println!("a . (b x c) = {}", a.scalar_triple_product(&b, &c));
    println!("a x (b x c) = {:?}", a.vector_triple_product(&b, &c));
}
```

```rust
a . b = 49
a x b = Vector { x: 5, y: 5, z: -7 }
a . (b x c) = 6
a x (b x c) = Vector { x: -267, y: 204, z: -3 }
```

# Address of a variable<a id="sec-188"></a>

Task

Demonstrate how to get the address of a variable and how to set the address of a variable.

It is not possible to change the memory address of an existing variable in Rust directly. However, you could make a copy of the value and then write it to a specific address.

```rust
let v1 = vec![vec![1,2,3]; 10];
println!("Original address: {:p}", &v1);
let mut v2;
// Override rust protections on reading from uninitialized memory
unsafe {v2 = mem::uninitialized();} 
let addr = &mut v2 as *mut _;
¬†
// ptr::write() though it takes v1 by value, v1s destructor is not run when it goes out of
// scope, which is good since then we'd have a vector of free'd vectors
unsafe {ptr::write(addr, v1)}
println!("New address: {:p}", &v2);
```

Get the memory address of a variable:

```rust
let var = 1;
println!("address of var: {:p}", &var);
```

Get the value at a certain memory address:

```rust
let address: usize = 0x7ffc8f303130;
unsafe {
    let val = *(address as *const usize);
    println!("value at {}: {:?}", address, val);
}
```

Set the value at a certain memory address:

```rust
unsafe {
    *(0x7ffc8f303130 as *mut usize) = 1;
    // Note that this invokes undefined behavior if 0x7ffc8f303130 is uninitialized. In that case, std::ptr::write should be used.
    std::ptr::write(0x7ffc8f303130 as *mut usize, 1);
}
```

# Horner's rule for polynomial evaluation<a id="sec-189"></a>

A fast scheme for evaluating a polynomial such as:

{\displaystyle -19+7x-4x<sup>2</sup>+6x<sup>3</sup>\\,}

when

{\displaystyle x=3\\;} .

is to arrange the computation as follows:

{\displaystyle ((((0)x+6)x+(-4))x+7)x+(-19)\\;}

And compute the result from the innermost brackets outwards as in this pseudocode:

```
coefficients := [-19, 7, -4, 6] # list coefficients of all x^0..x^n in order
x := 3
accumulator := 0
for i in length(coefficients) downto 1 do
    # Assumes 1-based indexing for arrays
    accumulator := ( accumulator * x ) + coefficients[i]
done
# accumulator now has the answer

```

Task Description

Create a routine that takes a list of coefficients of a polynomial in order of increasing powers of x; together with a value of x to compute its value at, and return the value of the polynomial at that value using Horner's rule.

Cf. Formal power series

```rust
fn horner(v: &[f64], x: f64) -> f64 {
    v.iter().rev().fold(0.0, |acc, coeff| acc*x + coeff)
}
¬†
fn main() {
    let v = [-19., 7., -4., 6.];
    println!("result: {}", horner(&v, 3.0));
}
```

A generic version that works with any number type and much more. So much more, it's hard to imagine what that may be useful for. Uses a gated feature (the Zero trait), only works in unstable Rust

```rust
#![feature(zero_one)
use std::num::Zero;
use std::ops::{Mul, Add};
¬†
fn horner<Arr,Arg, Out>(v: &[Arr], x: Arg) -> Out
  where Arr: Clone,
        Arg: Clone,
        Out: Zero + Mul<Arg, Output=Out> + Add<Arr, Output=Out>,
{
    v.iter().rev().fold(Zero::zero(), |acc, coeff| acc*x.clone() + coeff.clone())
}
¬†
fn main() {
    let v = [-19., 7., -4., 6.];
  let output: f64 = horner(&v, 3.0);
    println!("result: {}", output);
}
```

# Man or boy test<a id="sec-190"></a>

This page uses content from Wikipedia. The original article was at Man or boy test. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Background: The man or boy test was proposed by computer scientist Donald Knuth as a means of evaluating implementations of the ALGOL 60 programming language. The aim of the test was to distinguish compilers that correctly implemented "recursion and non-local references" from those that did not.

I have written the following simple routine, which may separate the 'man-compilers' from the 'boy-compilers' ‚Äî Donald Knuth

Task: Imitate Knuth's example in Algol 60 in another language, as far as possible.

Details: Local variables of routines are often kept in activation records (also call frames). In many languages, these records are kept on a call stack. In Algol (and e.g. in Smalltalk), they are allocated on a heap instead. Hence it is possible to pass references to routines that still can use and update variables from their call environment, even if the routine where those variables are declared already returned. This difference in implementations is sometimes called the Funarg Problem.

In Knuth's example, each call to A allocates an activation record for the variable A. When B is called from A, any access to k now refers to this activation record. Now B in turn calls A, but passes itself as an argument. This argument remains bound to the activation record. This call to A also "shifts" the variables xi by one place, so eventually the argument B (still bound to its particular activation record) will appear as x4 or x5 in a call to A. If this happens when the expression x4 + x5 is evaluated, then this will again call B, which in turn will update k in the activation record it was originally bound to. As this activation record is shared with other instances of calls to A and B, it will influence the whole computation.

So all the example does is to set up a convoluted calling structure, where updates to k can influence the behavior in completely different parts of the call tree.

Knuth used this to test the correctness of the compiler, but one can of course also use it to test that other languages can emulate the Algol behavior correctly. If the handling of activation records is correct, the computed value will be ‚àí67.

Performance and Memory: Man or Boy is intense and can be pushed to challenge any machine. Memory (both stack and heap) not CPU time is the constraining resource as the recursion creates a proliferation activation records which will quickly exhaust memory and present itself through a stack error. Each language may have ways of adjusting the amount of memory or increasing the recursion depth. Optionally, show how you would make such adjustments.

The table below shows the result, call depths, and total calls for a range of k:

k 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 A 1 0 -2 0 1 0 1 -1 -10 -30 -67 -138 -291 -642 -1,446 -3,250 -7,244 -16,065 -35,601 -78,985 -175,416 -389,695 -865,609 -1,922,362 -4,268,854 -9,479,595 -21,051,458 -46,750,171 -103,821,058 -230,560,902 -512,016,658 A called 1 2 3 4 8 18 38 80 167 347 722 1,509 3,168 6,673 14,091 29,825 63,287 134,652 287,264 614,442 1,317,533 2,831,900 6,100,852 13,172,239 28,499,827 61,786,266 134,202,509 292,011,464 ¬† ¬† ¬† A depth 1 2 3 4 8 16 32 64 128 256 512 1,024 2,048 4,096 8,192 16,384 32,768 65,536 131,072 262,144 524,288 1,048,576 2,097,152 4,194,304 8,388,608 ¬† ¬† ¬† ¬† ¬† ¬† B called 0 1 2 3 7 17 37 79 166 346 721 1,508 3,167 6,672 14,090 29,824 63,286 134,651 287,263 614,441 1,317,532 2,831,899 6,100,851 13,172,238 28,499,826 ¬† ¬† ¬† ¬† ¬† ¬† B depth 0 1 2 3 7 15 31 63 127 255 511 1,023 2,047 4,095 8,191 16,383 32,767 65,535 131,071 262,143 524,287 1,048,575 2,097,151 4,194,303 8,388,607 ¬† ¬† ¬† ¬† ¬† ¬†

Related tasks

¬† Jensen's Device

```rust
use std::cell::Cell;
¬†
trait Arg {
    fn run(&self) -> i32;
}
¬†
impl Arg for i32 {
    fn run(&self) -> i32 { *self }
}
¬†
struct B<'a> {
    k: &'a Cell<i32>,
    x1: &'a Arg,
    x2: &'a Arg,
    x3: &'a Arg,
    x4: &'a Arg,
}
¬†
impl<'a> Arg for B<'a> {
    fn run(&self) -> i32 {
        self.k.set(self.k.get() - 1);
        a(self.k.get(), self, self.x1, self.x2, self.x3, self.x4)
    }
}
¬†
fn a(k: i32, x1: &Arg, x2: &Arg, x3: &Arg, x4: &Arg, x5: &Arg) -> i32 {
    if k <= 0 {
        x4.run() + x5.run()
    } else {
        B{
            k: &Cell::new(k),
            x1, x2, x3, x4
        }.run()
    }
}
¬†
pub fn main() {
    println!("{}", a(10, &1, &-1, &-1, &1, &0));
}
```

# Strip whitespace from a string/Top and tail<a id="sec-191"></a>

Task

Demonstrate how to strip leading and trailing whitespace from a string.

The solution should demonstrate how to achieve the following three results:

String with leading whitespace removed String with trailing whitespace removed String with both leading and trailing whitespace removed

For the purposes of this task whitespace includes non printable characters such as the space character, the tab character, and other such characters that have no corresponding graphical representation.

```rust
fn main() {
    let spaces = " \t\n\x0B\x0C\r \u{A0} \u{2000}\u{3000}";
    let string_with_spaces = spaces.to_owned() + "String without spaces" + spaces;
¬†
    assert_eq!(string_with_spaces.trim(), "String without spaces");
    assert_eq!(string_with_spaces.trim_left(), "String without spaces".to_owned() + spaces);
    assert_eq!(string_with_spaces.trim_right(), spaces.to_owned() + "String without spaces");
}
```

# Check that file exists<a id="sec-192"></a>

Task

Verify that a file called ¬† ¬† input.txt ¬† ¬† and ¬† a directory called ¬† ¬† docs ¬† ¬† exist.

This should be done twice: ¬†

¬† once for the current working directory, ¬† and ¬† once for a file and a directory in the filesystem root.

Optional criteria (May 2015): ¬† verify it works with:

¬† zero-length files ¬† an unusual filename: ¬† \`Abdu'l-Bah√°.txt

```rust
use std::fs;
¬†
fn main() {
    for file in ["input.txt", "docs", "/input.txt", "/docs"].iter() {
        match fs::metadata(file) {
            Ok(attr) => {
                if attr.is_dir() {
                    println!("{} is a directory", file);
                }else {
                    println!("{} is a file", file);
                }
            },
            Err(_) => {
                println!("{} does not exist", file);
            }
        };
    }
}
¬†
```

# Hofstadter Q sequence<a id="sec-193"></a>

Hofstadter Q sequence

{\displaystyle {\begin{aligned}Q(1)&=Q(2)=1,\\\Q(n)&=Q{\big (}n-Q(n-1){\big )}+Q{\big (}n-Q(n-2){\big )},\quad n>2.\end{aligned}}}

It is defined like the Fibonacci sequence, but whereas the next term in the Fibonacci sequence is the sum of the previous two terms, in the Q sequence the previous two terms tell you how far to go back in the Q sequence to find the two numbers to sum to make the next term of the sequence.

Task

Confirm and display that the first ten terms of the sequence are: 1, 1, 2, 3, 3, 4, 5, 5, 6, and 6 Confirm and display that the 1000th term is: ¬† 502

Optional extra credit

Count and display how many times a member of the sequence is less than its preceding term for terms up to and including the 100,000th term. Ensure that the extra credit solution ¬† safely ¬† handles being initially asked for an nth term where ¬† n ¬† is large.

(This point is to ensure that caching and/or recursion limits, if it is a concern, is correctly handled).

Rust doesn't allow static Vec's (but there's lazy<sub>static</sub> crate), thus memoization storage is allocated in main.

```rust
fn hofq(q: &mut Vec<u32>, x¬†: u32) -> u32 {
    let cur_len=q.len()-1;
    let i=x as usize;
    if i>cur_len {
        // extend storage
        q.reserve(i+1);
        for j in (cur_len+1)..(i+1) {
            let qj=(q[j-q[j-1] as usize]+q[j-q[j-2] as usize]) as u32;
            q.push(qj);
        }
    }
    q[i]
}
¬†
fn main() {
    let mut q_memo: Vec<u32>=vec![0,1,1];
    let mut q=|i| {hofq(&mut q_memo, i)};
    for i in 1..11 {
        println!("Q({})={}", i, q(i));
    }
    println!("Q(1000)={}", q(1000));
    let q100001=q(100_000); // precompute all
    println!("Q(100000)={}", q100000);
    let nless=(1..100_000).fold(0,|s,i|{if q(i+1)<q(i) {s+1} else {s}});
    println!("Term is less than preceding term {} times", nless);
}
¬†
```

Output:

```rust
Q(1)=1
Q(2)=1
Q(3)=2
Q(4)=3
Q(5)=3
Q(6)=4
Q(7)=5
Q(8)=5
Q(9)=6
Q(10)=6
Q(1000)=502
Q(100001)=53471
Term is less than preceding term 49798 times

```

# Letter frequency<a id="sec-194"></a>

Task

Open a text file and count the occurrences of each letter.

Some of these programs count all characters (including punctuation), but some only count letters A to Z.

Works with all UTF-8 characters

```rust
use std::collections::btree_map::BTreeMap;
use std::{env, process};
use std::io::{self, Read, Write};
use std::fmt::Display;
use std::fs::File;
¬†
fn main() {
    let filename = env::args().nth(1)
        .ok_or("Please supply a file name")
        .unwrap_or_else(|e| exit_err(e, 1));
¬†
    let mut buf = String::new();
    let mut count = BTreeMap::new();
¬†
    File::open(&filename)
        .unwrap_or_else(|e| exit_err(e, 2))
        .read_to_string(&mut buf)
        .unwrap_or_else(|e| exit_err(e, 3));
¬†
¬†
    for c in buf.chars() {
        *count.entry(c).or_insert(0) += 1;
    }
¬†
    println!("Number of occurences per character");
    for (ch, count) in &count {
        println!("{:?}: {}", ch, count);
    }
}
¬†
#[inline]
fn exit_err<T>(msg: T, code: i32) ->¬†! where T: Display {
    writeln!(&mut io::stderr(), "{}", msg).expect("Could not write to stderr");
    process::exit(code)
}
```

Output when run on source file:

```rust
Number of occurences per character
'\n': 35
' ': 167
'!': 4
'\"': 10
'#': 1
'&': 4
'(': 25
')': 25
'*': 1
'+': 1
',': 12
'-': 1
'.': 10
'0': 1
'1': 3
'2': 2
'3': 2
':': 37
';': 13
'<': 1
'=': 4
'>': 2
'?': 1
'B': 2
'C': 1
'D': 2
'F': 2
'M': 2
'N': 1
'P': 1
'R': 1
'S': 1
'T': 5
'W': 1
'[': 1
']': 1
'_': 15
'a': 20
'b': 5
'c': 22
'd': 12
'e': 75
'f': 14
'g': 5
'h': 6
'i': 29
'k': 1
'l': 23
'm': 13
'n': 36
'o': 28
'p': 17
'r': 45
's': 33
't': 42
'u': 24
'v': 2
'w': 8
'x': 6
'y': 4
'{': 9
'|': 6
'}': 9

```

# Input loop<a id="sec-195"></a>

Task

Read from a text stream either word-by-word or line-by-line until the stream runs out of data.

The stream will have an unknown amount of data on it.

```rust
 use std::io::{self, BufReader, Read, BufRead};
use std::fs::File;
¬†
fn main() {
    print_by_line(io::stdin())
        .expect("Could not read from stdin");
¬†
    File::open("/etc/fstab")
        .and_then(print_by_line)
        .expect("Could not read from file");
}
¬†
fn print_by_line<T: Read>(reader: T) -> io::Result<()> {
    let buffer = BufReader::new(reader);
    for line in buffer.lines() {
        println!("{}", line?)
    }
    Ok(())
}
```

# Map range<a id="sec-196"></a>

Given two ranges:

¬† {\displaystyle [a<sub>1</sub>,a<sub>2</sub>]} ¬† and ¬† {\displaystyle [b<sub>1</sub>,b<sub>2</sub>]} ; ¬† then a value ¬† {\displaystyle s} ¬† in range ¬† {\displaystyle [a<sub>1</sub>,a<sub>2</sub>]} ¬† is linearly mapped to a value ¬† {\displaystyle t} ¬† in range ¬† {\displaystyle [b<sub>1</sub>,b<sub>2</sub>]}

¬† where:

¬† {\displaystyle t=b<sub>1</sub>+{(s-a<sub>1</sub>)(b<sub>2</sub>-b<sub>1</sub>) \over (a<sub>2</sub>-a<sub>1</sub>)}}

Task

Write a function/subroutine/&#x2026; that takes two ranges and a real number, and returns the mapping of the real number from the first to the second range.

Use this function to map values from the range ¬† [0, 10] ¬† to the range ¬† [-1, 0].

Extra credit

Show additional idiomatic ways of performing the mapping, using tools available to the language.

```rust
use std::f64;
¬†
fn map_range(from_range: (f64, f64), to_range: (f64, f64), s: f64) -> f64 {
    to_range.0 + (s - from_range.0) * (to_range.1 - to_range.0) / (from_range.1 - from_range.0)
}
¬†
fn main() {
    let input: Vec<f64> = vec![0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];
    let result = input.into_iter()
        .map(|x| map_range((0.0, 10.0), (-1.0, 0.0), x))
        .collect::<Vec<f64>>();
    print!("{:?}", result);
}
```

Output:

```rust
[-1, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.30000000000000004, -0.19999999999999996, -0.09999999999999998, 0]

```

# 24 game<a id="sec-197"></a>

The 24 Game tests one's mental arithmetic.

Task

Write a program that randomly chooses and displays four digits, each from 1 ‚îÄ‚îÄ‚ñ∫ 9 (inclusive) with repetitions allowed.

The program should prompt for the player to enter an arithmetic expression using just those, and all of those four digits, used exactly once each. The program should check then evaluate the expression.

The goal is for the player to enter an expression that (numerically) evaluates to 24.

Only the following operators/functions are allowed: multiplication, division, addition, subtraction Division should use floating point or rational arithmetic, etc, to preserve remainders. Brackets are allowed, if using an infix expression evaluator. Forming multiple digit numbers from the supplied digits is disallowed. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong). The order of the digits when given does not have to be preserved.

Notes

The type of expression evaluator used is not mandated. An RPN evaluator is equally acceptable for example. The task is not for the program to generate the expression, or test whether an expression is even possible.

Related tasks

24 game/Solve

Reference

The 24 Game on h2g2.

The solution below converts the infix notation to RPN and then calculates the result.

I am still new to Rust so i am certain it could be written in a shorter way. So if there is someone better than me please feel free to improve.

Library: rand

```rust
use std::io::{self,BufRead};
extern crate rand;
use rand::Rng;
¬†
fn op_type(x: char) -> i32{
    match x {
        '-' | '+' => return 1,
        '/' | '*' => return 2,
        '(' | ')' => return -1,
        _   => return 0,
    }
}
¬†
fn to_rpn(input: &mut String){
¬†
    let mut rpn_string¬†: String = String::new();
    let mut rpn_stack¬†: String = String::new();
    let mut last_token = '#';
    for token in input.chars(){
        if token.is_digit(10) {
            rpn_string.push(token);
        }
        else if op_type(token) == 0 {
            continue;
        }
        else if op_type(token) > op_type(last_token) || token == '(' {
                rpn_stack.push(token);
                last_token=token;
        }
        else {
            while let Some(top) = rpn_stack.pop() {
                if top=='(' {
                    break;
                }
                rpn_string.push(top);
            }
            if token¬†!= ')'{
                rpn_stack.push(token);
            }
        }
    }
    while let Some(top) = rpn_stack.pop() {
        rpn_string.push(top);
    }
¬†
    println!("you formula results in {}", rpn_string);
¬†
    *input=rpn_string;
}
¬†
fn calculate(input: &String, list¬†: &mut [u32;4]) -> f32{
    let mut stack¬†: Vec<f32> = Vec::new();
    let mut accumulator¬†: f32 = 0.0;
¬†
    for token in input.chars(){
        if token.is_digit(10) {
            let test = token.to_digit(10).unwrap() as u32;
            match list.iter().position(|&x| x == test){
                Some(idx) => list[idx]=10 ,
                _         => println!(" invalid digit: {} ",test),
            }
            stack.push(accumulator);
            accumulator = test as f32;
        }else{
            let a = stack.pop().unwrap();
            accumulator = match token {
                '-' => a-accumulator,
                '+' => a+accumulator,
                '/' => a/accumulator,
                '*' => a*accumulator,
                _ => {accumulator},//NOP
            };
        }
    }
    println!("you formula results in {}",accumulator);
    accumulator
}
¬†
fn main() {
¬†
    let mut rng = rand::thread_rng();
    let mut list¬†:[u32;4]=[rng.gen::<u32>()%10,rng.gen::<u32>()%10,rng.gen::<u32>()%10,rng.gen::<u32>()%10];
¬†
    println!("form 24 with using + - / * {:?}",list);
    //get user input
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    //convert to rpn
    to_rpn(&mut input);
    let result = calculate(&input, &mut list);
¬†
    if list.iter().any(|&list| list¬†!=10){
        println!("and you used all numbers");
        match result {
            24.0 => println!("you won"),
            _ => println!("but your formulla doesn't result in 24"),
        }
    }else{
        println!("you didn't use all the numbers");
    }
¬†
}
```

# Entropy<a id="sec-198"></a>

Task

Calculate the Shannon entropy ¬† H ¬† of a given input string.

Given the discrete random variable {\displaystyle X} that is a string of {\displaystyle N} "symbols" (total characters) consisting of {\displaystyle n} different characters (n=2 for binary), the Shannon entropy of X in bits/symbol is¬†:

{\displaystyle H<sub>2</sub>(X)=-&sum; \_{i=1}<sup>n</sup>{\frac {count<sub>i</sub>}{N}}log \_{2}\left({\frac {count<sub>i</sub>}{N}}\right)}

where {\displaystyle count<sub>i</sub>} is the count of character {\displaystyle n<sub>i</sub>} .

For this task, use X="1223334444" as an example. The result should be 1.84644&#x2026; bits/symbol. This assumes X was a random variable, which may not be the case, or it may depend on the observer.

This coding problem calculates the "specific" or "intensive" entropy that finds its parallel in physics with "specific entropy" S0 which is entropy per kg or per mole, not like physical entropy S and therefore not the "information" content of a file. It comes from Boltzmann's H-theorem where {\displaystyle S=k<sub>B</sub>NH} where N=number of molecules. Boltzmann's H is the same equation as Shannon's H, and it gives the specific entropy H on a "per molecule" basis.

The "total", "absolute", or "extensive" information entropy is

{\displaystyle S=H<sub>2</sub>N} bits

This is not the entropy being coded here, but it is the closest to physical entropy and a measure of the information content of a string. But it does not look for any patterns that might be available for compression, so it is a very restricted, basic, and certain measure of "information". Every binary file with an equal number of 1's and 0's will have S=N bits. All hex files with equal symbol frequencies will have {\displaystyle S=Nlog \_{2}(16)} bits of entropy. The total entropy in bits of the example above is S= 10\*18.4644 = 18.4644 bits.

The H function does not look for any patterns in data or check if X was a random variable. For example, X=000000111111 gives the same calculated entropy in all senses as Y=010011100101. For most purposes it is usually more relevant to divide the gzip length by the length of the original data to get an informal measure of how much "order" was in the data.

Two other "entropies" are useful:

Normalized specific entropy:

{\displaystyle H<sub>n</sub>={\frac {H<sub>2</sub>\*log(2)}{log(n)}}}

which varies from 0 to 1 and it has units of "entropy/symbol" or just 1/symbol. For this example, Hn<&sub;>= 0.923.

Normalized total (extensive) entropy:

{\displaystyle S<sub>n</sub>={\frac {H<sub>2</sub>N\*log(2)}{log(n)}}}

which varies from 0 to N and does not have units. It is simply the "entropy", but it needs to be called "total normalized extensive entropy" so that it is not confused with Shannon's (specific) entropy or physical entropy. For this example, Sn<&sub;>= 9.23.

Shannon himself is the reason his "entropy/symbol" H function is very confusingly called "entropy". That's like calling a function that returns a speed a "meter". See section 1.7 of his classic A Mathematical Theory of Communication and search on "per symbol" and "units" to see he always stated his entropy H has units of "bits/symbol" or "entropy/symbol" or "information/symbol". So it is legitimate to say entropy NH is "information".

In keeping with Landauer's limit, the physics entropy generated from erasing N bits is {\displaystyle S=H<sub>2</sub>Nk<sub>B</sub>ln(2)} if the bit storage device is perfectly efficient. This can be solved for H2\*N to (arguably) get the number of bits of information that a physical entropy represents.

Related tasks Fibonacci<sub>word</sub> Entropy/Narcissist

```rust
fn entropy(s: &[u8]) -> f32 {
    let mut entropy: f32 = 0.0;
    let mut histogram = [0; 256];
¬†
    for i in 0..s.len() {
        histogram.get_mut(s[i] as usize).map(|v| *v += 1);
    }
    for i in 0..256 {
        if histogram[i] > 0 {
            let ratio = (histogram[i] as f32 / s.len() as f32) as f32;
            entropy -= (ratio * ratio.log2()) as f32;
        }
    }
    entropy
}
¬†
fn main() {
    let arg = std::env::args().nth(1).expect("Need a string.");
    println!("Entropy of {} is {}.", arg, entropy(&arg.bytes().collect::<Vec<_>>()));
}
```

Output:

```rust
$ ./entropy 1223334444
Entropy of 1223334444 is 1.8464394.

```

# Call a foreign-language function<a id="sec-199"></a>

Task

Show how a foreign language function can be called from the language.

As an example, consider calling functions defined in the C language. Create a string containing "Hello World!" of the string type typical to the language. Pass the string content to C's strdup. The content can be copied if necessary. Get the result from strdup and print it using language means. Do not forget to free the result of strdup (allocated in the heap).

Notes

It is not mandated if the C run-time library is to be loaded statically or dynamically. You are free to use either way. C++ and C solutions can take some other language to communicate with. It is not mandatory to use strdup, especially if the foreign function interface being demonstrated makes that uninformative.

See also

¬† Use another language to call a function

```rust
extern crate libc;
¬†
//c function that returns the sum of two integers
extern {
    fn add_input(in1: libc::c_int, in2: libc::c_int) -> libc::c_int;
}
¬†
fn main() {
    let (in1, in2) = (5, 4);
    let output = unsafe {
        add_input(in1, in2) };
    assert!( (output == (in1 + in2) ),"Error in sum calculation")¬†;
}
```

# Reverse words in a string<a id="sec-200"></a>

Task

Reverse the order of all tokens in each of a number of strings and display the result; ¬† the order of characters within a token should not be modified.

Example

Hey you, Bub! ¬† would be shown reversed as: ¬† Bub! you, Hey

Tokens are any non-space characters separated by spaces (formally, white-space); ¬† the visible punctuation form part of the word within which it is located and should not be modified.

You may assume that there are no significant non-visible characters in the input. ¬† Multiple or superfluous spaces may be compressed into a single space.

Some strings have no tokens, so an empty string ¬† (or one just containing spaces) ¬† would be the result.

Display the strings in order ¬† (1st, 2nd, 3rd, ¬∑¬∑¬∑), ¬† and one string per line.

(You can consider the ten strings as ten lines, and the tokens as words.)

Input data

```
            (ten lines within the box)
line
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
  1 ‚ïë  ---------- Ice and Fire ------------  ‚ïë
  2 ‚ïë                                        ‚ïë  ‚óÑ‚îÄ‚îÄ‚îÄ a blank line here.
  3 ‚ïë  fire, in end will world the say Some  ‚ïë
  4 ‚ïë  ice. in say Some                      ‚ïë
  5 ‚ïë  desire of tasted I've what From       ‚ïë
  6 ‚ïë  fire. favor who those with hold I     ‚ïë
  7 ‚ïë                                        ‚ïë  ‚óÑ‚îÄ‚îÄ‚îÄ a blank line here.
  8 ‚ïë  ... elided paragraph last ...         ‚ïë
  9 ‚ïë                                        ‚ïë  ‚óÑ‚îÄ‚îÄ‚îÄ a blank line here.
 10 ‚ïë  Frost Robert -----------------------  ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

```

Cf.

Phrase reversals

```rust
const TEXT: &'static str = 
"---------- Ice and Fire ------------
¬†
fire, in end will world the say Some
ice. in say Some
desire of tasted I've what From
fire. favor who those with hold I
¬†
... elided paragraph last ...
¬†
Frost Robert -----------------------";
¬†
fn main() {
    println!("{}", 
             TEXT.lines() // Returns iterator over lines
             .map(|line|  // Applies closure to each item in iterator (for each line)
                  line.split_whitespace() // Returns iterator of words
                  .rev() // Reverses iterator of words
                  .collect::<Vec<_>>() // Collects words into Vec<&str>
                  .join(" ")) // Convert vector of words back into line
             .collect::<Vec<_>>() // Collect lines into Vec<String>
             .join("\n")); // Concatenate lines into String
}
```

# Hash from two arrays<a id="sec-201"></a>

Task

Using two Arrays of equal length, create a Hash object where the elements from one array (the keys) are linked to the elements of the other (the values)

Related task

¬† Associative arrays/Creation

```rust
use std::collections::HashMap;
¬†
fn main() {
    let keys = ["a", "b", "c"];
    let values = [1, 2, 3];
¬†
    let hash = keys.iter().zip(values.iter()).collect::<HashMap<_, _>>();
    println!("{:?}", hash);
}
```

# Fibonacci n-step number sequences<a id="sec-202"></a>

These number series are an expansion of the ordinary Fibonacci sequence where:

For {\displaystyle n=2} we have the Fibonacci sequence; with initial values {\displaystyle [1,1]} and {\displaystyle F<sub>k</sub><sup>2</sup>=F<sub>k-1</sub><sup>2</sup>+F<sub>k-2</sub><sup>2</sup>} For {\displaystyle n=3} we have the tribonacci sequence; with initial values {\displaystyle [1,1,2]} and {\displaystyle F<sub>k</sub><sup>3</sup>=F<sub>k-1</sub><sup>3</sup>+F<sub>k-2</sub><sup>3</sup>+F<sub>k-3</sub><sup>3</sup>} For {\displaystyle n=4} we have the tetranacci sequence; with initial values {\displaystyle [1,1,2,4]} and {\displaystyle F<sub>k</sub><sup>4</sup>=F<sub>k-1</sub><sup>4</sup>+F<sub>k-2</sub><sup>4</sup>+F<sub>k-3</sub><sup>4</sup>+F<sub>k-4</sub><sup>4</sup>}

&#x2026; For general {\displaystyle n>2} we have the Fibonacci {\displaystyle n} -step sequence - {\displaystyle F<sub>k</sub><sup>n</sup>} ; with initial values of the first {\displaystyle n} values of the {\displaystyle (n-1)} 'th Fibonacci {\displaystyle n} -step sequence {\displaystyle F<sub>k</sub><sup>n-1</sup>} ; and {\displaystyle k} 'th value of this {\displaystyle n} 'th sequence being {\displaystyle F<sub>k</sub><sup>n</sup>=&sum; \_{i=1}<sup>(n)</sup>{F<sub>k-i</sub><sup>(n)</sup>}}

For small values of {\displaystyle n} , Greek numeric prefixes are sometimes used to individually name each series.

Fibonacci {\displaystyle n} -step sequences {\displaystyle n} Series name Values 2 fibonacci 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 &#x2026; 3 tribonacci 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 &#x2026; 4 tetranacci 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 &#x2026; 5 pentanacci 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 &#x2026; 6 hexanacci 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 &#x2026; 7 heptanacci 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 &#x2026; 8 octonacci 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 &#x2026; 9 nonanacci 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 &#x2026; 10 decanacci 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 &#x2026;

Allied sequences can be generated where the initial values are changed:

The Lucas series sums the two preceding values like the fibonacci series for {\displaystyle n=2} but uses {\displaystyle [2,1]} as its initial values.

Task

Write a function to generate Fibonacci {\displaystyle n} -step number sequences given its initial values and assuming the number of initial values determines how many previous values are summed to make the next number of the series. Use this to print and show here at least the first ten members of the Fibo/tribo/tetra-nacci and Lucas sequences.

Related tasks

¬† Fibonacci sequence ¬† Wolfram Mathworld ¬† Hofstadter Q sequence‚Äé ¬† Leonardo numbers

Also see

¬† Lucas Numbers - Numberphile (Video)

```rust
¬†
struct GenFibonacci {
    buf:    Vec<u64>,
    sum:    u64,
    idx:    usize,
}
¬†
impl Iterator for GenFibonacci {
    type Item = u64;
    fn next(&mut self) -> Option<u64> {
        let result = Some(self.sum);
        self.sum -= self.buf[self.idx];
        self.buf[self.idx] += self.sum;
        self.sum += self.buf[self.idx];
        self.idx = (self.idx + 1)¬†% self.buf.len();
        result
    }
}
¬†
fn print(buf: Vec<u64>, len: usize) {
    let mut sum = 0;
    for &elt in buf.iter() { sum += elt; print!("\t{}", elt); }
    let iter = GenFibonacci { buf: buf, sum: sum, idx: 0 };
    for x in iter.take(len) {
        print!("\t{}", x);
    }
}
¬†
¬†
fn main() {
    print!("Fib2:");
    print(vec![1,1], 10 - 2);
¬†
    print!("\nFib3:");
    print(vec![1,1,2], 10 - 3);
¬†
    print!("\nFib4:");
    print(vec![1,1,2,4], 10 - 4);
¬†
    print!("\nLucas:");
    print(vec![2,1], 10 - 2);
}
¬†
```

```rust
¬†
Fib2:	1	1	2	3	5	8	13	21	34	55
Fib3:	1	1	2	4	7	13	24	44	81	149
Fib4:	1	1	2	4	8	15	29	56	108	208
Lucas:	2	1	3	4	7	11	18	29	47	76
¬†
```

# Sorting algorithms/Merge sort<a id="sec-203"></a>

The ¬† merge sort ¬† is a recursive sort of order ¬† n\*log(n).

It is notable for having a worst case and average complexity of ¬† O(n\*log(n)), ¬† and a best case complexity of ¬† O(n) ¬† (for pre-sorted input).

The basic idea is to split the collection into smaller groups by halving it until the groups only have one element or no elements ¬† (which are both entirely sorted groups).

Then merge the groups back together so that their elements are in order.

This is how the algorithm gets its ¬† divide and conquer ¬† description.

Task

Write a function to sort a collection of integers using the merge sort.

The merge sort algorithm comes in two parts:

```
a sort function     and 
a merge function 

```

The functions in pseudocode look like this:

```
function mergesort(m)
   var list left, right, result
   if length(m) ‚â§ 1
       return m
   else
       var middle = length(m) / 2
       for each x in m up to middle - 1
           add x to left
       for each x in m at and after middle
           add x to right
       left = mergesort(left)
       right = mergesort(right)
       if last(left) ‚â§ first(right) 
          append right to left
          return left
       result = merge(left, right)
       return result

function merge(left,right)
   var list result
   while length(left) > 0 and length(right) > 0
       if first(left) ‚â§ first(right)
           append first(left) to result
           left = rest(left)
       else
           append first(right) to result
           right = rest(right)
   if length(left) > 0 
       append rest(left) to result
   if length(right) > 0 
       append rest(right) to result
   return result

```

See also

¬† the Wikipedia entry: ¬† merge sort

Note: ¬† better performance can be expected if, rather than recursing until ¬† length(m) ‚â§ 1, ¬† an insertion sort is used for ¬† length(m) ¬† smaller than some threshold larger than ¬† 1. ¬† However, this complicates the example code, so it is not shown here.

Works with: rustc version 1.9.0

```rust
¬†
fn merge<T: Copy + PartialOrd>(x1: &[T], x2: &[T], y: &mut [T]) {
  assert_eq!(x1.len() + x2.len(), y.len());
  let mut i = 0;
  let mut j = 0;
  let mut k = 0;
  while i < x1.len() && j < x2.len() {
    if x1[i] < x2[j] {
      y[k] = x1[i];
      k += 1;
      i += 1;
    } else {
      y[k] = x2[j];
      k += 1;
      j += 1;
    }
  }
  if i < x1.len() {
    y[k..].copy_from_slice(&x1[i..]);
  }
  if j < x2.len() {
    y[k..].copy_from_slice(&x2[j..]);
  }
}
¬†
```

The sort algorithm¬†:

```rust
¬†
fn merge_sort_rec<T: Copy + Ord>(x: &mut [T]) {
  let n = x.len();
  let m = n / 2;
¬†
  if n <= 1 {
    return;
  }
¬†
  merge_sort_rec(&mut x[0..m]);
  merge_sort_rec(&mut x[m..n]);
¬†
  let mut y: Vec<T> = x.to_vec();
¬†
  merge(&x[0..m], &x[m..n], &mut y[..]);
¬†
  x.copy_from_slice(&y);
}
¬†
```

Version without recursion call (faster)¬†:

```rust
¬†
fn merge_sort<T: Copy + PartialOrd>(x: &mut [T]) {
  let n = x.len();
  let mut y = x.to_vec();
  let mut len = 1;
  while len < n {
    let mut i = 0;
    while i < n {
      if i + len >= n {
        y[i..].copy_from_slice(&x[i..]);
      } else if i + 2 * len > n {
        merge(&x[i..i+len], &x[i+len..], &mut y[i..]);				
      } else {
        merge(&x[i..i+len], &x[i+len..i+2*len], &mut y[i..i+2*len]);
      }
      i += 2 * len;
    }
    len *= 2;
    if len >= n {
      x.copy_from_slice(&y);
      return;
    }
    i = 0;
    while i < n {
      if i + len >= n {
        x[i..].copy_from_slice(&y[i..]);
      } else if i + 2 * len > n {
        merge(&y[i..i+len], &y[i+len..], &mut x[i..]);				
      } else {
        merge(&y[i..i+len], &y[i+len..i+2*len], &mut x[i..i+2*len]);
      }
      i += 2 * len;
    }
    len *= 2;
  }
}
¬†
```

# Proper divisors<a id="sec-204"></a>

The ¬† proper divisors ¬† of a positive integer N are those numbers, other than N itself, that divide N without remainder.

For N > 1 they will always include 1, ¬† but for N == 1 there are no proper divisors.

Examples

The proper divisors of ¬† ¬† 6 ¬† ¬† are ¬† 1, 2, and 3. The proper divisors of ¬† 100 ¬† are ¬† 1, 2, 4, 5, 10, 20, 25, and 50.

Task

Create a routine to generate all the proper divisors of a number. use it to show the proper divisors of the numbers 1 to 10 inclusive. Find a number in the range 1 to 20,000 with the most proper divisors. Show the number and just the count of how many proper divisors it has.

Show all output here.

Related tasks

¬† Amicable pairs ¬† Abundant, deficient and perfect number classifications ¬† Aliquot sequence classifications ¬† Factors of an integer ¬† Prime decomposition

```rust
trait ProperDivisors {
    fn proper_divisors(&self) -> Option<Vec<u64>>;
}
¬†
impl ProperDivisors for u64 {
    fn proper_divisors(&self) -> Option<Vec<u64>> {
        if self.le(&1) {
            return None;
        }
        let mut divisors: Vec<u64> = Vec::new();
¬†
        for i in 1..*self {
            if *self¬†% i == 0 {
                divisors.push(i);
            }
        }
        Option::from(divisors)
    }
}
¬†
fn main() {
    for i in 1..11 {
        println!("Proper divisors of {:2}: {:?}", i,
                 i.proper_divisors().unwrap_or(vec![]));
    }
¬†
    let mut most_idx: u64 = 0;
    let mut most_divisors: Vec<u64> = Vec::new();
    for i in 1..20_001 {
        let divs = i.proper_divisors().unwrap_or(vec![]);
        if divs.len() > most_divisors.len() {
            most_divisors = divs;
            most_idx = i;
        }
    }
    println!("In 1 to 20000, {} has the most proper divisors at {}", most_idx,
             most_divisors.len());
}
¬†
```

Output:

```rust
Proper divisors of  1: []
Proper divisors of  2: [1]
Proper divisors of  3: [1]
Proper divisors of  4: [1, 2]
Proper divisors of  5: [1]
Proper divisors of  6: [1, 2, 3]
Proper divisors of  7: [1]
Proper divisors of  8: [1, 2, 4]
Proper divisors of  9: [1, 3]
Proper divisors of 10: [1, 2, 5]
In 1 to 20000, 15120 has the most proper divisors at 79

```

# Sort using a custom comparator<a id="sec-205"></a>

Task

Sort an array (or list) of strings in order of descending length, and in ascending lexicographic order for strings of equal length.

Use a sorting facility provided by the language/library, combined with your own callback comparison function.

Note: ¬† Lexicographic order is case-insensitive.

```rust
¬†
fn main() {
    let mut words = ["Here", "are", "some", "sample", "strings", "to", "be", "sorted"];
    words.sort_by(|l, r| if l.len() == r.len() {
        l.cmp(&r)
    } else {
        r.len().cmp(&l.len())
    });
    println!("{:?}", words);
}
¬†
```

# N'th<a id="sec-206"></a>

Write a function/method/subroutine/&#x2026; that when given an integer greater than or equal to zero returns a string of the number followed by an apostrophe then the ordinal suffix. Example returns would include 1'st 2'nd 3'rd 11'th 111'th 1001'st 1012'th

Task

Use your routine to show here the output for at least the following (inclusive) ranges of integer inputs: 0..25, 250..265, 1000..1025

Note: apostrophes are now optional to allow correct apostrophe-less English.

```rust
fn nth(num: isize) -> String {
    format!("{}{}", num, match (num¬†% 10, num¬†% 100) {
        (1, 11) | (2, 12) | (3, 13) => "th",
        (1, _) => "st",
        (2, _) => "nd",
        (3, _) => "rd",
        _ => "th",
    })
}
¬†
fn main() {
    let ranges = [(0, 26), (250, 266), (1000, 1026)];
    for &(s, e) in &ranges {
        println!("[{}, {})¬†:", s, e);
        for i in s..e {
            print!("{}, ", nth(i));
        }
        println!();
    }
}
```

Output:

```rust
[0, 26)¬†:
0th, 1st, 2nd, 3rd, 4th, 5th, 6th, 7th, 8th, 9th, 10th, 11th, 12th, 13th, 14th, 15th, 16th, 17th, 18th, 19th, 20th, 21st, 22nd, 23rd, 24th, 25th, 
[250, 266)¬†:
250th, 251st, 252nd, 253rd, 254th, 255th, 256th, 257th, 258th, 259th, 260th, 261st, 262nd, 263rd, 264th, 265th, 
[1000, 1026)¬†:
1000th, 1001st, 1002nd, 1003rd, 1004th, 1005th, 1006th, 1007th, 1008th, 1009th, 1010th, 1011th, 1012th, 1013th, 1014th, 1015th, 1016th, 1017th, 1018th, 1019th, 1020th, 1021st, 1022nd, 1023rd, 1024th, 1025th,
```

# AKS test for primes<a id="sec-207"></a>

The AKS algorithm for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles.

The theorem on which the test is based can be stated as follows:

¬† a number ¬† {\displaystyle p} ¬† is prime ¬† if and only if ¬† all the coefficients of the polynomial expansion of

{\displaystyle (x-1)<sup>p</sup>-(x<sup>p</sup>-1)}

are divisible by ¬† {\displaystyle p} .

Example

Using ¬† {\displaystyle p=3}

    

```
(x-1)^3 - (x^3 - 1)
   = (x^3 - 3x^2 + 3x - 1) - (x^3 - 1)
   = -3x^2 + 3x

```

And all the coefficients are divisible by 3, ¬† so 3 is prime.

Task

Create a function/subroutine/method that given ¬† {\displaystyle p} ¬† generates the coefficients of the expanded polynomial representation of ¬† {\displaystyle (x-1)<sup>p</sup>} . Use the function to show here the polynomial expansions of ¬† {\displaystyle (x-1)<sup>p</sup>} ¬† for ¬† {\displaystyle p} ¬† in the range ¬† 0 ¬† to at least ¬† 7, ¬† inclusive. Use the previous function in creating another function that when given ¬† {\displaystyle p} ¬† returns whether ¬† {\displaystyle p} ¬† is prime using the theorem. Use your test to generate a list of all primes under ¬† 35. As a stretch goal, ¬† generate all primes under ¬† 50 ¬† (needs integers larger than 31-bit).

References

Agrawal-Kayal-Saxena (AKS) primality test (Wikipedia) Fool-Proof Test for Primes - Numberphile (Video). The accuracy of this video is disputed &#x2013; at best it is an oversimplification.

```rust
use std::iter::repeat;
¬†
fn aks_coefficients(k: usize) -> Vec<i64> {
    let mut coefficients = repeat(0i64).take(k + 1).collect::<Vec<_>>();
    coefficients[0] = 1;
    for i in 1..(k + 1) {
        coefficients[i] = -(1..i).fold(coefficients[0], |prev, j|{
            let old = coefficients[j];
            coefficients[j] = old - prev;
            old
        });
    }
    coefficients
}
¬†
fn is_prime(p: usize) -> bool {
    if p < 2 {
        false
    } else {
        let c = aks_coefficients(p);
        (1 .. (c.len() - 1) / 2 + 1).all(|i| (c[i]¬†% (p as i64)) == 0)
    }
}
¬†
fn main() {
    for i in 0..8 {
        println!("{}: {:?}", i, aks_coefficients(i));
    }
    for i in (1..51).filter(|&i| is_prime(i)) {
        print!("{} ", i);
    }
}
```

Output:

```rust
0: [1]
1: [1, -1]
2: [1, -2, 1]
3: [1, -3, 3, -1]
4: [1, -4, 6, -4, 1]
5: [1, -5, 10, -10, 5, -1]
6: [1, -6, 15, -20, 15, -6, 1]
7: [1, -7, 21, -35, 35, -21, 7, -1]
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 
```

An alternative version which computes the coefficients in a more functional but less efficient way.

```rust
¬†
fn aks_coefficients(k: usize) -> Vec<i64> {
  if k == 0 {
    vec![1i64]
  } else {
    let zero = Some(0i64);
    range(1, k).fold(vec![1i64, -1], |r, _| {
      let a = r.iter().chain(zero.iter());
      let b = zero.iter().chain(r.iter());
      a.zip(b).map(|(x, &y)| x-y).collect()
    })
  }
}
¬†
```

# Set<a id="sec-208"></a>

A ¬† set ¬†is a collection of elements, without duplicates and without order.

Task

Show each of these set operations:

Set creation Test m ‚àà S &#x2013; "m is an element in set S" A ‚à™ B &#x2013; union; a set of all elements either in set A or in set B. A ‚à© B &#x2013; intersection; a set of all elements in both set A and set B. A ‚àñ B &#x2013; difference; a set of all elements in set A, except those in set B. A ‚äÜ B &#x2013; subset; true if every element in set A is also in set B. A = B &#x2013; equality; true if every element of set A is in set B and vice versa.

As an option, show some other set operations. (If A ‚äÜ B, but A ‚â† B, then A is called a true or proper subset of B, written A ‚äÇ B or A ‚ää B.)

As another option, show how to modify a mutable set.

One might implement a set using an associative array (with set elements as array keys and some dummy value as the values).

One might also implement a set with a binary search tree, or with a hash table, or with an ordered array of binary bits (operated on with bit-wise binary operators).

The basic test, m ‚àà S, is O(n) with a sequential list of elements, O(log n) with a balanced binary search tree, or (O(1) average-case, O(n) worst case) with a hash table.

See also

Array Associative array: Creation, Iteration Collections Compound data type Doubly-linked list: Definition, Element definition, Element insertion, Traversal Linked list Queue: Definition, Usage Set Singly-linked list: Element definition, Element insertion, Traversal Stack

```rust
use std::collections::HashSet;
¬†
fn main() {
  let a = vec![1, 3, 4].into_iter().collect::<HashSet<i32>>();
  let b = vec![3, 5, 6].into_iter().collect::<HashSet<i32>>();
¬†
  println!("Set A: {:?}", a.iter().collect::<Vec<_>>());
  println!("Set B: {:?}", b.iter().collect::<Vec<_>>());
  println!("Does A contain 4? {}", a.contains(&4));
  println!("Union: {:?}", a.union(&b).collect::<Vec<_>>());
  println!("Intersection: {:?}", a.intersection(&b).collect::<Vec<_>>());
  println!("Difference: {:?}", a.difference(&b).collect::<Vec<_>>());
  println!("Is A a subset of B? {}", a.is_subset(&b));
  println!("Is A equal to B? {}", a == b);
}
```

# Abundant, deficient and perfect number classifications<a id="sec-209"></a>

These define three classifications of positive integers based on their ¬† proper divisors.

Let ¬† P(n) ¬† be the sum of the proper divisors of ¬† n ¬† where the proper divisors are all positive divisors of ¬† n ¬† other than ¬† n ¬† itself.

```
if    P(n) <  n    then  n  is classed as  deficient  (OEIS A005100).
if    P(n) == n    then  n  is classed as  perfect    (OEIS A000396).
if    P(n) >  n    then  n  is classed as  abundant   (OEIS A005101).

```

Example

6 ¬† has proper divisors of ¬† 1, ¬† 2, ¬† and ¬† 3.

1 + 2 + 3 = 6, ¬† so ¬† 6 ¬† is classed as a perfect number.

Task

Calculate how many of the integers ¬† 1 ¬† to ¬† 20,000 ¬† (inclusive) are in each of the three classes.

Show the results here.

Related tasks

¬† Aliquot sequence classifications. ¬† (The whole series from which this task is a subset.) ¬† Proper divisors ¬† Amicable pairs

With proper<sub>divisors</sub>#Rust in place:

```rust
fn main() {
    // deficient starts at 1 because 1 is deficient but proper_divisors returns
    // and empty Vec
    let (mut abundant, mut deficient, mut perfect) = (0u32, 1u32, 0u32);
    for i in 1..20_001 {
        if let Some(divisors) = i.proper_divisors() {
            let sum: u64 = divisors.iter().sum();
            if sum < i {
                deficient += 1
            } else if sum > i {
                abundant += 1
            } else {
                perfect += 1
            }
        }
    }
    println!("deficient:\t{:5}\nperfect:\t{:5}\nabundant:\t{:5}",
             deficient, perfect, abundant);
}
¬†
```

Output:

```rust
deficient:      15043
perfect:            4
abundant:        4953

```

# Averages/Mode<a id="sec-210"></a>

Task[edit]

Write a program to find the mode value of a collection.

The case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.

If it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.

See also

Tasks for calculating statistical measures

in one go moving (sliding window) moving (cumulative) Mean Arithmetic Statistics/Basic Averages/Arithmetic mean Averages/Pythagorean means

Averages/Simple moving average

Geometric Averages/Pythagorean means

Harmonic Averages/Pythagorean means

Quadratic Averages/Root mean square

Circular Averages/Mean angle Averages/Mean time of day

Median Averages/Median

Mode Averages/Mode

Standard deviation Statistics/Basic

Cumulative standard deviation

```rust
use std::collections::HashMap;
¬†
fn main() {
    let mode_vec1 = mode(vec![ 1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17]);
    let mode_vec2 = mode(vec![ 1, 1, 2, 4, 4]);
¬†
    println!("Mode of vec1 is: {:?}", mode_vec1);
    println!("Mode of vec2 is: {:?}", mode_vec2);
¬†
    assert!( mode_vec1 == [6], "Error in mode calculation");
    assert!( (mode_vec2 == [1, 4]) || (mode_vec2 == [4,1]), "Error in mode calculation" );
}
¬†
fn mode(vs: Vec<i32>) -> Vec<i32> {
    let mut vec_mode = Vec::new();
    let mut seen_map = HashMap::new();
    let mut max_val = 0;
    for i in vs{
        let ctr = seen_map.entry(i).or_insert(0);
        *ctr += 1;
        if *ctr > max_val{
            max_val = *ctr;
        }
    }
    for (key, val) in seen_map {
        if val == max_val{
            vec_mode.push(key);
        }
    }
    vec_mode
}
¬†
```

Output:

```rust

Mode of vec1 is: [6]
Mode of vec2 is: [1,4] // may also print [4, 1], vector has no order guarantee

```

# Digital root<a id="sec-211"></a>

The digital root, {\displaystyle X} , of a number, {\displaystyle n} , is calculated:

find {\displaystyle X} as the sum of the digits of {\displaystyle n} find a new {\displaystyle X} by summing the digits of {\displaystyle X} , repeating until {\displaystyle X} has only one digit.

The additive persistence is the number of summations required to obtain the single digit.

The task is to calculate the additive persistence and the digital root of a number, e.g.:

{\displaystyle 627615} has additive persistence {\displaystyle 2} and digital root of {\displaystyle 9} ; {\displaystyle 39390} has additive persistence {\displaystyle 2} and digital root of {\displaystyle 6} ; {\displaystyle 588225} has additive persistence {\displaystyle 2} and digital root of {\displaystyle 3} ; {\displaystyle 393900588225} has additive persistence {\displaystyle 2} and digital root of {\displaystyle 9} ;

The digital root may be calculated in bases other than 10.

See

Casting out nines for this wiki's use of this procedure. Digital root/Multiplicative digital root Sum digits of an integer Digital root sequence on OEIS Additive persistence sequence on OEIS Iterated digits squaring

```rust
fn sum_digits(mut n: u64, base: u64) -> u64 {
    let mut sum = 0u64;
    while n > 0 {
        sum = sum + (n¬†% base);
        n = n / base;
    }
    sum
}
¬†
// Returns tuple of (additive-persistence, digital-root)
fn digital_root(mut num: u64, base: u64) -> (u64, u64) {
    let mut pers = 0;
    while num >= base {
        pers = pers + 1;
        num = sum_digits(num, base);
    }
    (pers, num)
}
¬†
fn main() {
¬†
    // Test base 10
    let values = [627615u64, 39390u64, 588225u64, 393900588225u64];
    for &value in values.iter() {
        let (pers, root) = digital_root(value, 10);
        println!("{} has digital root {} and additive persistance {}",
                 value,
                 root,
                 pers);
    }
¬†
    println!("");
¬†
    // Test base 16
    let values_base16 = [0x7e0, 0x14e344, 0xd60141, 0x12343210];
    for &value in values_base16.iter() {
        let (pers, root) = digital_root(value, 16);
        println!("0x{:x} has digital root 0x{:x} and additive persistance 0x{:x}",
                 value,
                 root,
                 pers);
    }
}
```

Output:

```rust
627615 has digital root 9 and additive persistance 2
39390 has digital root 6 and additive persistance 2
588225 has digital root 3 and additive persistance 2
393900588225 has digital root 9 and additive persistance 2

0x7e0 has digital root 0x6 and additive persistance 0x2
0x14e344 has digital root 0xf and additive persistance 0x2
0xd60141 has digital root 0xa and additive persistance 0x2
0x12343210 has digital root 0x1 and additive persistance 0x2

```

# Count in octal<a id="sec-212"></a>

Task

Produce a sequential count in octal, ¬† starting at zero, ¬† and using an increment of a one for each consecutive number.

Each number should appear on a single line, ¬† and the program should count until terminated, ¬† or until the maximum value of the numeric type in use is reached.

Related task

¬† Integer sequence ¬† is a similar task without the use of octal numbers.

```rust
fn main() {
    for i in 0..std::usize::MAX {
        println!("{:o}", i);
    }
}
```

# Guess the number<a id="sec-213"></a>

Task

Write a program where the program chooses a number between ¬† 1 ¬† and ¬† 10.

A player is then prompted to enter a guess. ¬† If the player guesses wrong, ¬† then the prompt appears again until the guess is correct.

When the player has made a successful guess the computer will issue a ¬† "Well guessed!" ¬† message, ¬† and the program exits.

A ¬† conditional loop ¬† may be used to repeat the guessing until the user is correct.

Related tasks

¬† Bulls and cows ¬† Bulls and cows/Player ¬† Guess the number/With Feedback ¬† Mastermind

Library: rand

```rust
extern crate rand;
¬†
fn main() {
    println!("Type in an integer between 1 and 10 and press enter.");
¬†
    let n = rand::random::<u32>()¬†% 10 + 1;
    loop {
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).unwrap();
        let option: Result<u32,_> = line.trim().parse();
        match option {
            Ok(guess) => {
                if guess < 1 || guess > 10 {
                    println!("Guess is out of bounds; try again.");
                } else if guess == n {
                    println!("Well guessed!");
                    break;
                } else {
                    println!("Wrong! Try again.");
                }
            },
            Err(_) => println!("Invalid input; try again.")
        }
    }
}
```

# Best shuffle<a id="sec-214"></a>

Task

Shuffle the characters of a string in such a way that as many of the character values are in a different position as possible.

A shuffle that produces a randomized result among the best choices is to be preferred. A deterministic approach that produces the same sequence every time is acceptable as an alternative.

Display the result as follows:

```
original string, shuffled string, (score) 

```

The score gives the number of positions whose character value did not change.

Example

```
tree, eetr, (0)

```

Test cases

```
abracadabra
seesaw
elk
grrrrrr
up
a

```

Related tasks

¬† Anagrams/Deranged anagrams ¬† Permutations/Derangements

Library: rand

```rust
extern crate permutohedron;
extern crate rand;
¬†
use std::cmp::{min, Ordering};
use std::env;
use rand::{thread_rng, Rng};
use std::str;
¬†
const WORDS: &'static [&'static str] = &["abracadabra", "seesaw", "elk", "grrrrrr", "up", "a"];
¬†
#[derive(Eq)]
struct Solution {
    original: String,
    shuffled: String,
    score: usize,
}
¬†
// Ordering trait implementations are only needed for the permutations method
impl PartialOrd for Solution {
    fn partial_cmp(&self, other: &Solution) -> Option<Ordering> {
        match (self.score, other.score) {
            (s, o) if s < o => Some(Ordering::Less),
            (s, o) if s > o => Some(Ordering::Greater),
            (s, o) if s == o => Some(Ordering::Equal),
            _ => None,
        }
    }
}
¬†
¬†
impl PartialEq for Solution {
    fn eq(&self, other: &Solution) -> bool {
        match (self.score, other.score) {
            (s, o) if s == o => true,
            _ => false,
        }
    }
}
¬†
impl Ord for Solution {
    fn cmp(&self, other: &Solution) -> Ordering {
        match (self.score, other.score) {
            (s, o) if s < o => Ordering::Less,
            (s, o) if s > o => Ordering::Greater,
            _ => Ordering::Equal,
        }
    }
}
¬†
fn _help() {
    println!("Usage: best_shuffle <word1> <word2> ...");
}
¬†
fn main() {
    let args: Vec<String> = env::args().collect();
    let mut words: Vec<String> = vec![];
¬†
    match args.len() {
        1 => {
            for w in WORDS.iter() {
                words.push(String::from(*w));
            }
        }
        _ => {
            for w in args.split_at(1).1 {
                words.push(w.clone());
            }
        }
    }
¬†
    let solutions = words.iter().map(|w| best_shuffle(w)).collect::<Vec<_>>();
¬†
    for s in solutions {
        println!("{}, {}, ({})", s.original, s.shuffled, s.score);
    }
}
¬†
// Implementation iterating over all permutations
fn _best_shuffle_perm(w: &String) -> Solution {
    let mut soln = Solution {
        original: w.clone(),
        shuffled: w.clone(),
        score: w.len(),
    };
    let w_bytes: Vec<u8> = w.clone().into_bytes();
    let mut permutocopy = w_bytes.clone();
    let mut permutations = permutohedron::Heap::new(&mut permutocopy);
    while let Some(p) = permutations.next_permutation() {
        let hamm = hamming(&w_bytes, p);
        soln = min(soln,
                   Solution {
                       original: w.clone(),
                       shuffled: String::from(str::from_utf8(p).unwrap()),
                       score: hamm,
                   });
        // Accept the solution if score 0 found
        if hamm == 0 {
            break;
        }
    }
    soln
}
¬†
// Quadratic implementation
fn best_shuffle(w: &String) -> Solution {
    let w_bytes: Vec<u8> = w.clone().into_bytes();
    let mut shuffled_bytes: Vec<u8> = w.clone().into_bytes();
¬†
    // Shuffle once
    let sh: &mut [u8] = shuffled_bytes.as_mut_slice();
    thread_rng().shuffle(sh);
¬†
    // Swap wherever it doesn't decrease the score
    for i in 0..sh.len() {
        for j in 0..sh.len() {
            if (i == j) | (sh[i] == w_bytes[j]) | (sh[j] == w_bytes[i]) | (sh[i] == sh[j]) {
                continue;
            }
            sh.swap(i, j);
            break;
        }
    }
¬†
    let res = String::from(str::from_utf8(sh).unwrap());
    let res_bytes: Vec<u8> = res.clone().into_bytes();
    Solution {
        original: w.clone(),
        shuffled: res,
        score: hamming(&w_bytes, &res_bytes),
    }
}
¬†
fn hamming(w0: &Vec<u8>, w1: &Vec<u8>) -> usize {
    w0.iter().zip(w1.iter()).filter(|z| z.0 == z.1).count()
}
¬†
```

Output:

```rust
abracadabra, caadabarabr, (0)
seesaw, esswea, (0)
elk, lke, (0)
grrrrrr, rrrrgrr, (5)
up, pu, (0)
a, a, (1)

```

# Here document<a id="sec-215"></a>

A ¬† here document ¬† (or "heredoc") ¬† is a way of specifying a text block, preserving the line breaks, indentation and other whitespace within the text.

Depending on the language being used, a ¬† here document ¬† is constructed using a command followed by "<<" (or some other symbol) followed by a token string.

The text block will then start on the next line, and will be followed by the chosen token at the beginning of the following line, which is used to mark the end of the text block.

Task

Demonstrate the use of ¬† here documents ¬† within the language.

Related task

¬† Documentation

Similar to C++, Rust offers raw strings:

```rust
let x = r#"
    This is a "raw string literal," roughly equivalent to a heredoc.   
  "#;
```

# Arithmetic/Rational<a id="sec-216"></a>

Task

Create a reasonably complete implementation of rational arithmetic in the particular language using the idioms of the language.

Example

Define a new type called frac with binary operator "//" of two integers that returns a structure made up of the numerator and the denominator (as per a rational number).

Further define the appropriate rational unary operators abs and '-', with the binary operators for addition '+', subtraction '-', multiplication '√ó', division '/', integer division '√∑', modulo division, the comparison operators (e.g. '<', '‚â§', '>', & '‚â•') and equality operators (e.g. '=' & '‚â†').

Define standard coercion operators for casting int to frac etc.

If space allows, define standard increment and decrement operators (e.g. '+:=' & '-:=' etc.).

Finally test the operators: Use the new type frac to find all perfect numbers less than 219 by summing the reciprocal of the factors.

Related task

¬† Perfect Numbers

```rust
use std::cmp::Ordering;
use std::ops::{Add, AddAssign, Sub, SubAssign, Mul, MulAssign, Div, DivAssign, Neg};
¬†
fn gcd(a: i64, b: i64) -> i64 {
    match b {
        0 => a,
        _ => gcd(b, a¬†% b),
    }
}
¬†
fn lcm(a: i64, b: i64) -> i64 {
    a / gcd(a, b) * b
}
¬†
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash, Ord)]
pub struct Rational {
    numerator: i64,
    denominator: i64,
}
¬†
impl Rational {
    fn new(numerator: i64, denominator: i64) -> Self {
        let divisor = gcd(numerator, denominator);
        Rational {
            numerator: numerator / divisor,
            denominator: denominator / divisor,
        }
    }
}
¬†
impl Add for Rational {
    type Output = Self;
¬†
    fn add(self, other: Self) -> Self {
        let multiplier = lcm(self.denominator, other.denominator);
        Rational::new(self.numerator * multiplier / self.denominator +
                      other.numerator * multiplier / other.denominator,
                      multiplier)
    }
}
¬†
impl AddAssign for Rational {
    fn add_assign(&mut self, other: Self) {
        *self = *self + other;
    }
}
¬†
impl Sub for Rational {
    type Output = Self;
¬†
    fn sub(self, other: Self) -> Self {
        self + -other
    }
}
¬†
impl SubAssign for Rational {
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
¬†
impl Mul for Rational {
    type Output = Self;
¬†
    fn mul(self, other: Self) -> Self {
        Rational::new(self.numerator * other.numerator,
                      self.denominator * other.denominator)
    }
}
¬†
impl MulAssign for Rational {
    fn mul_assign(&mut self, other: Self) {
        *self = *self * other;
    }
}
¬†
impl Div for Rational {
    type Output = Self;
¬†
    fn div(self, other: Self) -> Self {
        self *
        Rational {
            numerator: other.denominator,
            denominator: other.numerator,
        }
    }
}
¬†
impl DivAssign for Rational {
    fn div_assign(&mut self, other: Self) {
        *self = *self / other;
    }
}
¬†
impl Neg for Rational {
    type Output = Self;
¬†
    fn neg(self) -> Self {
        Rational {
            numerator: -self.numerator,
            denominator: self.denominator,
        }
    }
}
¬†
impl PartialOrd for Rational {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        (self.numerator * other.denominator).partial_cmp(&(self.denominator * other.numerator))
    }
}
¬†
impl<T: Into<i64>> From<T> for Rational {
    fn from(value: T) -> Self {
        Rational::new(value.into(), 1)
    }
}
¬†
fn main() {
    let max = 1 << 19;
    for candidate in 2..max {
        let mut sum = Rational::new(1, candidate);
        for factor in 2..(candidate as f64).sqrt().ceil() as i64 {
            if candidate¬†% factor == 0 {
                sum += Rational::new(1, factor);
                sum += Rational::new(1, candidate / factor);
            }
        }
¬†
        if sum == 1.into() {
            println!("{} is perfect", candidate);
        }
    }
}
¬†
```

# Langton's ant<a id="sec-217"></a>

Langton's ant is a cellular automaton that models an ant sitting on a plane of cells, all of which are white initially, the ant facing in one of four directions.

Each cell can either be black or white.

The ant moves according to the color of the cell it is currently sitting in, with the following rules:

¬† If the cell is black, it changes to white and the ant turns left; ¬† If the cell is white, it changes to black and the ant turns right; ¬† The ant then moves forward to the next cell, and repeat from step 1.

This rather simple ruleset leads to an initially chaotic movement pattern, and after about 10000 steps, a cycle appears where the ant moves steadily away from the starting location in a diagonal corridor about 10 cells wide. Conceptually the ant can then walk infinitely far away.

Task

Start the ant near the center of a 100x100 field of cells, which is about big enough to contain the initial chaotic part of the movement.

Follow the movement rules for the ant, terminate when it moves out of the region, and show the cell colors it leaves behind.

The problem has received some analysis; for more details, please take a look at the Wikipedia article ¬† (a link is below)..

See also

¬† Wikipedia: ¬† Langton's ant.

Related task

¬† Rosetta Code: ¬† Conway's Game of Life.

```rust
struct Ant {
    x: usize,
    y: usize,
    dir: Direction
}
¬†
#[derive(Clone,Copy)]
enum Direction {
    North,
    East,
    South,
    West
}
¬†
use Direction::*;
¬†
impl Ant {
    fn mv(&mut self, vec: &mut Vec<Vec<u8>>) {
        let pointer = &mut vec[self.y][self.x];
        //change direction
        match *pointer {
            0 => self.dir = self.dir.right(),
            1 => self.dir = self.dir.left(),
            _ => panic!("Unexpected colour in grid")
        }
        //flip colour
        //if it's 1 it's black
        //if it's 0 it's white
        *pointer ^= 1;
¬†
        //move direction
        match self.dir {
            North => self.y -= 1,
            South => self.y += 1,
            East => self.x += 1,
            West => self.x -= 1,
        }
¬†
    }
}
¬†
impl Direction {
    fn right(self) -> Direction {
        match self {
            North => East,
            East => South,
            South => West,
            West => North,
        }
    }
¬†
    fn left(self) -> Direction {
        //3 rights equal a left
        self.right().right().right()
    }
}
¬†
fn main(){
    //create a 100x100 grid using vectors
    let mut grid: Vec<Vec<u8>> = vec![vec![0; 100]; 100];
    let mut ant = Ant {
        x: 50, y: 50, dir: Direction::North
    };
¬†
    while ant.x < 100 && ant.y < 100 {
        ant.mv(&mut grid);
    }
    for each in grid.iter() {
        //construct string
        //using iterator methods to quickly convert the vector
        //to a string
        let string = each.iter()
                         .map(|&x| if x == 0 { " " } else { "#" })
                         .fold(String::new(), |x, y| x+y);
        println!("{}", string);
    }
}
```

# Magic squares of odd order<a id="sec-218"></a>

A magic square is an ¬† NxN ¬† square matrix whose numbers (usually integers) consist of consecutive numbers arranged so that the sum of each row and column, ¬† and ¬† both long (main) diagonals are equal to the same sum (which is called the ¬† magic number ¬† or ¬† magic constant).

The numbers are usually (but not always) the first ¬† N2 ¬† positive integers.

A magic square whose rows and columns add up to a magic number but whose main diagonals do not, is known as a semimagic square.

8 1 6 3 5 7 4 9 2

Task

For any odd ¬† N, ¬† generate a magic square with the integers ¬† 1 ‚îÄ‚îÄ‚ñ∫ N, ¬† and show the results here.

Optionally, show the magic number.

You should demonstrate the generator by showing at least a magic square for ¬† N = 5.

Related tasks

Magic squares of singly even order Magic squares of doubly even order

See also

MathWorld‚Ñ¢ entry: Magic<sub>square</sub> Odd Magic Squares (1728.org)

```rust
fn main() {
    let n = 9;
    let mut square = vec![vec![0; n]; n];
    for (i, row) in square.iter_mut().enumerate() {
        for (j, e) in row.iter_mut().enumerate() {
            *e = n * (((i + 1) + (j + 1) - 1 + (n >> 1))¬†% n) + (((i + 1) + (2 * (j + 1)) - 2)¬†% n) + 1;
            print!("{:3} ", e);
        }
        println!("");
    }
    let sum = n * (((n * n) + 1) / 2);
    println!("The sum of the square is {}.", sum);
}
```

Output:

```rust
 47  58  69  80   1  12  23  34  45 
 57  68  79   9  11  22  33  44  46 
 67  78   8  10  21  32  43  54  56 
 77   7  18  20  31  42  53  55  66 
  6  17  19  30  41  52  63  65  76 
 16  27  29  40  51  62  64  75   5 
 26  28  39  50  61  72  74   4  15 
 36  38  49  60  71  73   3  14  25 
 37  48  59  70  81   2  13  24  35 
The sum of the square is 369.
```

# Amb<a id="sec-219"></a>

Define and give an example of the Amb operator.

The Amb operator expresses nondeterminism. This doesn't refer to randomness (as in "nondeterministic universe") but is closely related to the term as it is used in automata theory ("non-deterministic finite automaton").

The Amb operator takes a variable number of expressions (or values if that's simpler in the language) and yields a correct one which will satisfy a constraint in some future computation, thereby avoiding failure.

Problems whose solution the Amb operator naturally expresses can be approached with other tools, such as explicit nested iterations over data sets, or with pattern matching. By contrast, the Amb operator appears integrated into the language. Invocations of Amb are not wrapped in any visible loops or other search patterns; they appear to be independent.

Essentially Amb(x, y, z) splits the computation into three possible futures: a future in which the value x is yielded, a future in which the value y is yielded and a future in which the value z is yielded. The future which leads to a successful subsequent computation is chosen. The other "parallel universes" somehow go away. Amb called with no arguments fails.

For simplicity, one of the domain values usable with Amb may denote failure, if that is convenient. For instance, it is convenient if a Boolean false denotes failure, so that Amb(false) fails, and thus constraints can be expressed using Boolean expressions like Amb(x \* y == 8) which unless x and y add to four.

A pseudo-code program which satisfies this constraint might look like:

```
let x = Amb(1, 2, 3)
let y = Amb(7, 6, 4, 5)
Amb(x * y = 8)
print x, y
```

The output is 2 4 because Amb(1, 2, 3) correctly chooses the future in which x has value 2, Amb(7, 6, 4, 5) chooses 4 and consequently Amb(x \* y = 8) produces a success.

Alternatively, failure could be represented using strictly Amb():

```
unless x * y = 8 do Amb()
```

Or else Amb could take the form of two operators or functions: one for producing values and one for enforcing constraints:

```
let x = Ambsel(1, 2, 3)
let y = Ambsel(4, 5, 6)
Ambassert(x * y = 8)
print x, y
```

where Ambassert behaves like Amb() if the Boolean expression is false, otherwise it allows the future computation to take place, without yielding any value.

The task is to somehow implement Amb, and demonstrate it with a program which chooses one word from each of the following four sets of character strings to generate a four-word sentence:

"the" "that" "a" "frog" "elephant" "thing" "walked" "treaded" "grows" "slowly" "quickly"

The constraint to be satisfied is that the last character of each word (other than the last) is the same as the first character of its successor.

The only successful sentence is "that thing grows slowly"; other combinations do not satisfy the constraint and thus fail.

The goal of this task isn't to simply process the four lists of words with explicit, deterministic program flow such as nested iteration, to trivially demonstrate the correct output. The goal is to implement the Amb operator, or a facsimile thereof that is possible within the language limitations.

```rust
¬†
use std::ops::Add;
struct Amb<'a> {
    list: Vec<Vec<&'a str>>,
}
fn main() {
    let amb = Amb {
        list: vec![
            vec!["the", "that", "a"],
            vec!["frog", "elephant", "thing"],
            vec!["walked", "treaded", "grows"],
            vec!["slowly", "quickly"],
        ],
    };
    match amb.do_amb(0, 0 as char) {
        Some(text) => println!("{}", text),
        None => println!("Nothing found"),
    }
}
impl<'a> Amb<'a> {
    fn do_amb(&self, level: usize, last_char: char) -> Option<String> {
        if self.list.is_empty() {
            panic!("No word list");
        }
        if self.list.len() <= level {
            return Some(String::new());
        }
        let mut res = String::new();
        let word_list = &self.list[level];
        for word in word_list {
            if word.chars().next().unwrap() == last_char || last_char == 0 as char {
                res = res.add(word).add(" ");
                let answ = self.do_amb(level + 1, word.chars().last().unwrap());
                match answ {
                    Some(x) => {
                        res = res.add(&x);
                        return Some(res);
                    }
                    None => res.clear(),
                }
            }
        }
        None
    }
}
¬†
```

# String interpolation (included)<a id="sec-220"></a>

Given a string and defined variables or values, string interpolation is the replacement of defined character sequences in the string by values or variable values.

For example, given an original string of "Mary had a X lamb.", a value of "big", and if the language replaces X in its interpolation routine, then the result of its interpolation would be the string "Mary had a big lamb".

(Languages usually include an infrequently used character or sequence of characters to indicate what is to be replaced such as "%", or "#" rather than "X").

The task is to

Use your languages inbuilt string interpolation abilities to interpolate a string missing the text "little" which is held in a variable, to produce the output string "Mary had a little lamb". If possible, give links to further documentation on your languages string interpolation features.

Note: The task is not to create a string interpolation routine, but to show a language's built-in capability.

Rust has very powerful string interpolation. Documentation here.

```rust
fn main() {
    println!("Mary had a {} lamb", "little");
    // You can specify order
    println!("{1} had a {0} lamb", "little", "Mary");
    // Or named arguments if you prefer
    println!("{name} had a {adj} lamb", adj="little", name="Mary");
}
```

# Euler's sum of powers conjecture<a id="sec-221"></a>

There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.

Euler's (disproved) sum of powers ¬† conjecture

```
At least  k  positive  kth  powers are required to sum to a  kth  power,  
except for the trivial case of one  kth power:  yk = yk 

```

Lander and Parkin are known to have used a brute-force search on a ¬† CDC 6600 ¬† computer restricting numbers to those less than 250.

Task

Write a program to search for an integer solution for:

x05 + x15 + x25 + x35 == y5

Where all ¬† xi's ¬† and ¬† y ¬† are distinct integers between ¬† 0 ¬† and ¬† 250 ¬† (exclusive).

Show an answer here.

Related tasks

¬† Pythagorean quadruples. ¬† Pythagorean triples.

```rust
const MAX_N¬†: u64 = 250;
¬†
fn eulers_sum_of_powers() -> (usize, usize, usize, usize, usize) {
    let pow5: Vec<u64> = (0..MAX_N).map(|i| i.pow(5)).collect();
    let pow5_to_n = |pow| pow5.binary_search(&pow);
¬†
    for x0 in 1..MAX_N as usize {
        for x1 in 1..x0 {
            for x2 in 1..x1 {
                for x3 in 1..x2 {
                    let pow_sum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3];
                    if let Ok(n) = pow5_to_n(pow_sum) {
                        return (x0, x1, x2, x3, n)
                    }
                }
            }
        }
    }
¬†
    panic!();
}
¬†
fn main() {
  let (x0, x1, x2, x3, y) = eulers_sum_of_powers();
  println!("{}^5 + {}^5 + {}^5 + {}^5 == {}^5", x0, x1, x2, x3, y)
}
```

Output:

```rust
133^5 + 110^5 + 84^5 + 27^5 == 144^5
```

# Monte Carlo methods<a id="sec-222"></a>

A Monte Carlo Simulation is a way of approximating the value of a function where calculating the actual value is difficult or impossible. It uses random sampling to define constraints on the value and then makes a sort of "best guess."

A simple Monte Carlo Simulation can be used to calculate the value for {\displaystyle &pi; } .

If you had a circle and a square where the length of a side of the square was the same as the diameter of the circle, the ratio of the area of the circle to the area of the square would be {\displaystyle &pi; /4} .

So, if you put this circle inside the square and select many random points inside the square, the number of points inside the circle divided by the number of points inside the square and the circle would be approximately {\displaystyle &pi; /4} .

Task

Write a function to run a simulation like this, with a variable number of random points to select.

Also, show the results of a few different sample sizes.

For software where the number {\displaystyle &pi; } is not built-in, we give {\displaystyle &pi; } as a number of digits:

```
3.141592653589793238462643383280

```

```rust
extern crate rand;
¬†
use rand::Rng;
use std::f64::consts::PI;
¬†
// `(f32, f32)` would be faster for some RNGs (including `rand::thread_rng` on 32-bit platforms
// and `rand::weak_rng` as of rand v0.4) as `next_u64` combines two `next_u32`s if not natively
// supported by the RNG.  It would less accurate however.
fn is_inside_circle((x, y): (f64, f64)) -> bool {
    x * x + y * y <= 1.0
}
¬†
fn simulate<R: Rng>(rng: &mut R, samples: usize) -> f64 {
    let mut count = 0;
    for _ in 0..samples {
        if is_inside_circle(rng.gen()) {
            count += 1;
        }
    }
    (count as f64) / (samples as f64)
}
¬†
fn main() {
    let mut rng = rand::weak_rng();
¬†
    println!("Real pi: {}", PI);
¬†
    for samples in (3..9).map(|e| 10_usize.pow(e)) {
        let estimate = 4.0 * simulate(&mut rng, samples);
        let deviation = 100.0 * (1.0 - estimate / PI).abs();
        println!("{:9}: {:<11} dev: {:.5}%", samples, estimate, deviation);
    }
}
```

Output:

```rust
Real pi: 3.141592653589793
     1000: 3.212       dev: 2.24114%
    10000: 3.156       dev: 0.45860%
   100000: 3.14112     dev: 0.01505%
  1000000: 3.14122     dev: 0.01186%
 10000000: 3.1408112   dev: 0.02487%
100000000: 3.14186092  dev: 0.00854%
```

# Extend your language<a id="sec-223"></a>

Some programming languages allow you to extend the language. While this can be done to a certain degree in most languages (e.g. by using macros), other languages go much further. Most notably in the Forth and Lisp families, programming per se is done by extending the language without any formal distinction between built-in and user-defined elements.

If your language supports it, show how to introduce a new flow control mechanism. A practical and useful example is a four-way branch:

Occasionally, code must be written that depends on two conditions, resulting in up to four branches (depending on whether both, only the first, only the second, or none of the conditions are "true"). In a C-like language this could look like the following:

```
if (condition1isTrue) {
   if (condition2isTrue)
      bothConditionsAreTrue();
   else
      firstConditionIsTrue();
}
else if (condition2isTrue)
   secondConditionIsTrue();
else
   noConditionIsTrue();

```

Besides being rather cluttered, the statement(s) for 'condition2isTrue' must be written down twice. If 'condition2isTrue' were a lengthy and involved expression, it would be quite unreadable, and the code generated by the compiler might be unnecessarily large.

This can be improved by introducing a new keyword if2. It is similar to if, but takes two conditional statements instead of one, and up to three 'else' statements. One proposal (in pseudo-C syntax) might be:

```
if2 (condition1isTrue) (condition2isTrue)
   bothConditionsAreTrue();
else1
   firstConditionIsTrue();
else2
   secondConditionIsTrue();
else
   noConditionIsTrue();

```

Pick the syntax which suits your language. The keywords 'else1' and 'else2' are just examples. The new conditional expression should look, nest and behave analogously to the language's built-in 'if' statement.

```rust
#![allow(unused_variables)]
macro_rules! if2 {
    ($cond1: expr, $cond2: expr 
        => $both:expr 
        => $first: expr 
        => $second:expr 
        => $none:expr) 
    => {
        match ($cond1, $cond2) {
            (true, true) => $both,
            (true, _   ) => $first,
            (_   , true) => $second,
            _            => $none
        }
    }
}
¬†
fn main() {
    let i = 1;
    let j = 2;
    if2!(i > j, i + j >= 3
        => {
            // code blocks and statements can go here also
            let k = i + j;
            println!("both were true")
        }
        => println!("the first was true")
        => println!("the second was true")
        => println!("neither were true")
    )
}
```

# Shell one-liner<a id="sec-224"></a>

Task

Show how to specify and execute a short program in the language from a command shell, where the input to the command shell is only one line in length.

Avoid depending on the particular shell or operating system used as much as is reasonable; if the language has notable implementations which have different command argument syntax, or the systems those implementations run on have different styles of shells, it would be good to show multiple examples.

The following code leaves the file rust<sub>out</sub> in the current directory (it does not delete it to avoid to call another shell/system dependent command/program). The current directory is not specified by ./ in every system&#x2026;

```rust
$ echo 'fn main(){println!("Hello!")}' | rustc -;./rust_out
```

# String comparison<a id="sec-225"></a>

The task is to demonstrate how to compare two strings from within the language and how to achieve a lexical comparison.

The task should demonstrate:

Comparing two strings for exact equality Comparing two strings for inequality (i.e., the inverse of exact equality) Comparing two strings to see if one is lexically ordered before than the other Comparing two strings to see if one is lexically ordered after than the other How to achieve both case sensitive comparisons and case insensitive comparisons within the language How the language handles comparison of numeric strings if these are not treated lexically Demonstrate any other kinds of string comparisons that the language provides, particularly as it relates to your type system. ¬† For example, you might demonstrate the difference between generic/polymorphic comparison and coercive/allomorphic comparison if your language supports such a distinction.

Here "generic/polymorphic" comparison means that the function or operator you're using doesn't always do string comparison, but bends the actual semantics of the comparison depending on the types one or both arguments; with such an operator, you achieve string comparison only if the arguments are sufficiently string-like in type or appearance.

In contrast, a "coercive/allomorphic" comparison function or operator has fixed string-comparison semantics regardless of the argument type; ¬† instead of the operator bending, it's the arguments that are forced to bend instead and behave like strings if they can, ¬† and the operator simply fails if the arguments cannot be viewed somehow as strings. ¬† A language may have one or both of these kinds of operators; ¬† see the Perl¬†6 entry for an example of a language with both kinds of operators.

Related tasks

¬† Integer comparison ¬† String matching ¬† Compare a list of strings

Comparisons are case sensitive by default, all (Ascii) uppercase letters are treated as lexically before all lowercase letters. For case-insensitive comparisons, use Ascii Extensions. In general, case is not a concept that applies to all unicode symbols.

```rust
use std::ascii::AsciiExt; // for case insensitives only
¬†
fn main() {
    // only same types can be compared
    // String and String or &str and &str
    // exception: strict equality and inequality also work on &str and String
    let a: &str = "abc";
    let b: String = "Bac".to_owned();
¬†
    // Strings are coerced to &str when borrowed and needed
    if a == b { println!("The strings are equal") }
    if a¬†!= b { println!("The strings are not equal") }
    if a  > &b { println!("The first string is lexically after the second") }
    if a  < &b { println!("The first string is lexically before the second") }
    if a >= &b { println!("The first string is not lexically before the second") }
    if a <= &b { println!("The first string is not lexically after the second") }
¬†
    // case-insensitives:
¬†
    // equality
    // this avoids new allocations
    if a.eq_ignore_ascii_case(&b) { println!("Both strings are equal when ignoring case") }
¬†
    // everything else, create owned Strings, then compare as above
    let a2 = a.to_ascii_uppercase();
    let b2 = b.to_ascii_uppercase();
¬†
    // repeat checks
}
```

Output:

```rust
The strings are not equal
The first string is lexically after the second
The first string is not lexically before the second
```

# Walk a directory/Recursively<a id="sec-226"></a>

Task

Walk a given directory tree and print files matching a given pattern.

Note: This task is for recursive methods. ¬† These tasks should read an entire directory tree, not a single directory.

Note: Please be careful when running any code examples found here.

Related task

¬† Walk a directory/Non-recursively ¬† (read a single directory).

Using std::fs::walk<sub>dir</sub> (unstable as of Rust 1.1) with imperative for-loop:

```rust
#![feature(fs_walk)]
¬†
use std::fs;
use std::path::Path;
¬†
fn main() {
    for f in fs::walk_dir(&Path::new("/home/pavel/Music")).unwrap() {
        let p = f.unwrap().path();
        if p.extension().unwrap_or("".as_ref()) == "mp3" {
            println!("{:?}", p);
        }
    }
}
```

# MD5<a id="sec-227"></a>

Task

Encode a string using an MD5 algorithm. ¬† The algorithm can be found on ¬† Wikipedia.

Optionally, validate your implementation by running all of the test values in ¬† IETF RFC (1321) ¬† for MD5.

Additionally, ¬† RFC 1321 ¬† provides more precise information on the algorithm than the Wikipedia article.

If the solution on this page is a library solution, see ¬† MD5/Implementation ¬† for an implementation from scratch.

Cargo.toml

```rust
¬†
[dependencies]
rust-crypto = "0.2"
¬†
```

src/main.rs

```rust
¬†
extern crate crypto;
¬†
use crypto::digest::Digest;
use crypto::md5::Md5;
¬†
fn main() {
    let mut sh = Md5::new();
    sh.input_str("The quick brown fox jumped over the lazy dog's back");
    println!("{}", sh.result_str());
}
¬†
```

# Modulinos<a id="sec-228"></a>

It is useful to be able to execute a main() function only when a program is run directly. This is a central feature in programming scripts. A script that behaves this way is called a modulino.

Examples from <https://github.com/mcandre/modulinos>

Sometimes getting the ScriptName is required in order to determine when to run main().

This is still a draft task, and the current task description has caused mega confusion. See Talk:Modulinos for numerous attempts to understand the task and to rewrite the task description.

The task Executable library is written to replace this task. This task's future is in doubt as its aims are not clear enough.

Note: this code is deprecated, and does not compile with Rust 1.0.0 and newer.

Makefile:

```rust
all: scriptedmain
¬†
scriptedmain: scriptedmain.rs
  rustc scriptedmain.rs
¬†
test: test.rs scriptedmain.rs
  rustc --lib scriptedmain.rs
  rustc test.rs -L .
¬†
clean:
  -rm test
  -rm -rf *.dylib
  -rm scriptedmain
  -rm -rf *.dSYM
```

scriptedmain.rs:

```rust
#[link(name = "scriptedmain")];
¬†
use std;
¬†
fn meaning_of_life() -> int {
  ret 42;
}
¬†
fn main() {
  std::io::println("Main: The meaning of life is " + core::int::to_str(meaning_of_life(), 10u));
}
```

test.rs:

```rust
use scriptedmain;
use std;
¬†
fn main() {
  std::io::println("Test: The meaning of life is " + core::int::to_str(scriptedmain::meaning_of_life(), 10u));
}
```

Example:

```rust
$ make
$ make test
$ ./scriptedmain
Main: The meaning of life is 42
$ ./test
Test: The meaning of life is 42
```

# Read a configuration file<a id="sec-229"></a>

The task is to read a configuration file in standard configuration file format, and set variables accordingly.

For this task, we have a configuration file as follows:

```
# This is a configuration file in standard configuration file format
#
# Lines beginning with a hash or a semicolon are ignored by the application
# program. Blank lines are also ignored by the application program.

# This is the fullname parameter
FULLNAME Foo Barber

# This is a favourite fruit
FAVOURITEFRUIT banana

# This is a boolean that should be set
NEEDSPEELING

# This boolean is commented out
; SEEDSREMOVED

# Configuration option names are not case sensitive, but configuration parameter
# data is case sensitive and may be preserved by the application program.

# An optional equals sign can be used to separate configuration parameter data
# from the option name. This is dropped by the parser. 

# A configuration option may take multiple parameters separated by commas.
# Leading and trailing whitespace around parameter names and parameter data fields
# are ignored by the application program.

OTHERFAMILY Rhu Barber, Harry Barber

```

For the task we need to set four variables according to the configuration entries as follows:

fullname = Foo Barber favouritefruit = banana needspeeling = true seedsremoved = false

We also have an option that contains multiple parameters. These may be stored in an array.

otherfamily(1) = Rhu Barber otherfamily(2) = Harry Barber

Related tasks

Update a configuration file

```rust
use std::fs::File;
use std::io::BufRead;
use std::io::BufReader;
use std::iter::FromIterator;
use std::path::Path;
¬†
fn main() {
    let path = String::from("file.conf");
    let cfg = config_from_file(path);
    println!("{:?}", cfg);
}
¬†
fn config_from_file(path: String) -> Config {
    let path = Path::new(&path);
    let file = File::open(path).expect("File not found or cannot be opened");
    let content = BufReader::new(&file);
    let mut cfg = Config::new();
¬†
    for line in content.lines() {
        let line = line.expect("Could not read the line");
        // Remove whitespaces at the beginning and end
        let line = line.trim();
¬†
        // Ignore comments and empty lines
        if line.starts_with("#") || line.starts_with(";") || line.is_empty() {
            continue;
        }
¬†
        // Split line into parameter name and rest tokens
        let tokens = Vec::from_iter(line.split_whitespace()); 
        let name = tokens.first().unwrap();
        let tokens = tokens.get(1..).unwrap();
¬†
        // Remove the equal signs
        let tokens = tokens.iter().filter(|t|¬†!t.starts_with("="));
        // Remove comment after the parameters
        let tokens = tokens.take_while(|t|¬†!t.starts_with("#") &&¬†!t.starts_with(";"));
¬†
        // Concat back the parameters into one string to split for separated parameters
        let mut parameters = String::new();
        tokens.for_each(|t| { parameters.push_str(t); parameters.push(' '); });
        // Splits the parameters and trims
        let parameters = parameters.split(',').map(|s| s.trim());
        // Converts them from Vec<&str> into Vec<String>
        let parameters: Vec<String> = parameters.map(|s| s.to_string()).collect();
¬†
        // Setting the config parameters
        match name.to_lowercase().as_str() {
            "fullname" => cfg.full_name = parameters.get(0).cloned(),
            "favouritefruit" => cfg.favourite_fruit = parameters.get(0).cloned(),
            "needspeeling" => cfg.needs_peeling = true,
            "seedsremoved" => cfg.needs_peeling = true,
            "otherfamily" => cfg.other_family = Some(parameters),
            _ => (),
        }
    }
¬†
    cfg
}
¬†
#[derive(Clone, Debug)]
struct Config {
    full_name: Option<String>,
    favourite_fruit: Option<String>,
    needs_peeling: bool,
    seeds_removed: bool,
    other_family: Option<Vec<String>>,
}
¬†
impl Config {
    fn new() -> Config {
        Config {
            full_name: None,
            favourite_fruit: None,
            needs_peeling: false,
            seeds_removed: false,
            other_family: None,
        }
    }
}
```

Output:

```rust
Config { full_name: Some("Foo Barber"), favourite_fruit: Some("banana"), needs_peeling: true, seeds_removed: false, other_family: Some(["Rhu Barber", "Harry Barber"]) }

```

# Binary strings<a id="sec-230"></a>

Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks. This task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language. In particular the functions you need to create are:

String creation and destruction (when needed and if there's no garbage collection or similar mechanism) String assignment String comparison String cloning and copying Check if a string is empty Append a byte to a string Extract a substring from a string Replace every occurrence of a byte (or a string) in a string with another string Join strings

Possible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.

For extra documentation, refer to [1] and [2].

```rust
use std::str;
¬†
fn main() {
    // Create new string
    let string = String::from("Hello world!");
    println!("{}", string);
    assert_eq!(string, "Hello world!", "Incorrect string text");
¬†
    // Create and assign value to string
    let mut assigned_str = String::new();
    assert_eq!(assigned_str, "", "Incorrect string creation");
    assigned_str += "Text has been assigned!";
    println!("{}", assigned_str);
    assert_eq!(assigned_str, "Text has been assigned!","Incorrect string text");
¬†
    // String comparison, compared lexicographically byte-wise same as the asserts above
    if string == "Hello world!" && assigned_str == "Text has been assigned!" {
        println!("Strings are equal");
    }
¬†
    // Cloning -> string can still be used after cloning
    let clone_str = string.clone();
    println!("String is:{}  and  Clone string is: {}", string, clone_str);
    assert_eq!(clone_str, string, "Incorrect string creation");
¬†
    // Copying, string won't be usable anymore, accessing it will cause compiler failure
    let copy_str = string;
    println!("String copied now: {}", copy_str);
¬†
    // Check if string is empty
    let empty_str = String::new();
    assert!(empty_str.is_empty(), "Error, string should be empty");
¬†
    // Append byte, Rust strings are a stream of UTF-8 bytes
    let byte_vec = [65]; // contains A
    let byte_str = str::from_utf8(&byte_vec).unwrap();
    assert_eq!(byte_str, "A", "Incorrect byte append");
¬†
    // Substrings can be accessed through slices
    let test_str = "Blah String";
    let mut sub_str = &test_str[0..11];
    assert_eq!(sub_str, "Blah String", "Error in slicing");
    sub_str = &test_str[1..5];
    assert_eq!(sub_str, "lah ", "Error in slicing");
    sub_str = &test_str[3..];
    assert_eq!(sub_str, "h String", "Error in slicing");
    sub_str = &test_str[..2];
    assert_eq!(sub_str, "Bl", "Error in slicing");
¬†
    // String replace, note string is immutable
    let org_str = "Hello";
    assert_eq!(org_str.replace("l", "a"), "Heaao", "Error in replacement");
    assert_eq!(org_str.replace("ll", "r"), "Hero", "Error in replacement");
¬†
    // Joining strings requires a `String` and an &str or a two `String`s one of which needs an & for coercion
    let str1 = "Hi";
    let str2 = " There";
    let fin_str = str1.to_string() + str2;
    assert_eq!(fin_str, "Hi There", "Error in concatenation");
¬†
    // Joining strings requires a `String` and an &str or two `Strings`s, one of which needs an & for coercion
    let str1 = "Hi";
    let str2 = " There";
    let fin_str = str1.to_string() + str2;
    assert_eq!(fin_str, "Hi There", "Error in concatenation");
¬†
    // Splits -- note Rust supports passing patterns to splits
    let f_str = "Pooja and Sundar are up in Tumkur";
    let split_str: Vec<_> = f_str.split(' ').collect();
    assert_eq!(split_str, ["Pooja", "and", "Sundar", "are", "up", "in", "Tumkur"], "Error in string split");
}
```

# Iterated digits squaring<a id="sec-231"></a>

If you add the square of the digits of a Natural number (an integer bigger than zero), you always end with either 1 or 89:

```
15 -> 26 -> 40 -> 16 -> 37 -> 58 -> 89
7 -> 49 -> 97 -> 130 -> 10 -> 1
```

An example in Python:

```
>>> step = lambda x: sum(int(d) ** 2 for d in str(x))
>>> iterate = lambda x: x if x in [1, 89] else iterate(step(x))
>>> [iterate(x) for x in xrange(1, 20)]
[1, 89, 89, 89, 89, 89, 1, 89, 89, 1, 89, 89, 1, 89, 89, 89, 89, 89, 1]
```

Task Count how many number chains for integers 1 <= n < 100<sub>000</sub><sub>000</sub> end with a value 89.

Or, for much less credit - (showing that your algorithm and/or language is slow):

Count how many number chains for integers 1 <= n < 1<sub>000</sub><sub>000</sub> end with a value 89.

This problem derives from the Project Euler problem 92.

For a quick algorithm for this task see the talk page

Related tasks

Combinations with repetitions Digital root Digital root/Multiplicative digital root

These are two naive solutions, one with lots of redundant calculations (memoizationless recursion) and one with a few precomputed values. All digit square sums are no greater than 648 for numbers < 100<sub>000</sub><sub>000</sub>.

Both are slow algorithms, however, Rust is among faster languages, so this doesn't take minutes or hours.

Naive Recursion

```rust
fn digit_square_sum(mut num: usize) -> usize {
    let mut sum = 0;
    while num¬†!= 0 {
        sum += (num¬†% 10).pow(2);
        num /= 10;
    }
    sum
}
¬†
fn last_in_chain(num: usize) -> usize {
    match num {
        1 | 89 => num,
        _ => last_in_chain(digit_square_sum(num)),
    }
}
¬†
fn main() {
    let count = (1..100_000_000).filter(|&n| last_in_chain(n) == 89).count();
    println!("{}", count);
}
```

Output:

```rust
85744333
```

Runtime: 6s on a 2500k @ 4Ghz

With precomputation

```rust
fn dig_sq_sum(mut num¬†: usize ) -> usize {
    let mut sum = 0;
    while num¬†!= 0 {
        sum += (num¬†% 10).pow(2);
        num /= 10;
    }
    sum
}
¬†
fn last_in_chain(num: usize) -> usize {
    match num {
        0 => 0,
        1 | 89 => num,
        _ => last_in_chain(dig_sq_sum(num)),
    }
}
¬†
fn main() {
    let prec: Vec<_> = (0..649).map(|n| last_in_chain(n)).collect();
    let count = (1..100_000_000).filter(|&n| prec[dig_sq_sum(n)] == 89).count();
    println!("{}", count);
}
```

Runtime: 1.7s on a 2500k @ 4Ghz

Output:

```rust
85744333
```

# Lucas-Lehmer test<a id="sec-232"></a>

Lucas-Lehmer Test: for {\displaystyle p} an odd prime, the Mersenne number {\displaystyle 2<sup>p</sup>-1} is prime if and only if {\displaystyle 2<sup>p</sup>-1} divides {\displaystyle S(p-1)} where {\displaystyle S(n+1)=(S(n))<sup>2</sup>-2} , and {\displaystyle S(1)=4} .

Task

Calculate all Mersenne primes up to the implementation's maximum precision, or the 47th Mersenne prime ¬† (whichever comes first).

```rust
¬†
¬†
extern crate rug;
extern crate primal;
¬†
use rug::Integer;
use rug::ops::Pow;
use std::thread::spawn;
¬†
fn is_mersenne (p¬†: usize) {
    let p = p as u32;
    let mut m = Integer::from(1);
    m = m << p;  
    m = Integer::from(&m - 1);
    let mut flag1 = false;
    for k in 1..10_000 {
        let mut flag2 = false;
        let mut div¬†: u32 = 2*k*p + 1;
        if &div >= &m {break; }
        for j in [3,5,7,11,13,17,19,23,29,31,37].iter() {
            if div¬†% j == 0 {
                flag2 = true;
                break;
            }   
        }
        if flag2 == true {continue;}
        if div¬†% 8¬†!= 1 && div¬†% 8¬†!= 7 { continue; }
        if m.is_divisible_u(div) { 
            flag1 = true;
            break;
        }
    }
    if flag1 == true {return ()}
    let mut s = Integer::from(4);
    let two = Integer::from(2);
    for _i in 2..p {
    let mut sqr = s.pow(2);
    s = Integer::from(&Integer::from(&sqr & &m) + &Integer::from(&sqr >> p));
    if &s >= &m {s = s - &m}
    s = Integer::from(&s - &two);
    }
  if s == 0 {println!("Mersenne¬†: {}",p);} 
}
¬†
fn main () {
    println!("Mersenne¬†: 2");
    let limit = 11_214;
    let mut thread_handles = vec![];
    for p in primal::Primes::all().take_while(|p| *p < limit) {
        thread_handles.push(spawn(move || is_mersenne(p))); 
    }
    for handle in thread_handles {
        handle.join().unwrap();
    }
}
¬†
```

with Intel(R) Core(TM) i7-5500U CPU @ 2.40GHz¬†: Less than 8,6 seconds to get the Mersenne primes up to 11213

Output:

```rust
Mersenne¬†: 2
Mersenne¬†: 5
Mersenne¬†: 3
Mersenne¬†: 7
Mersenne¬†: 13
Mersenne¬†: 17
Mersenne¬†: 19
Mersenne¬†: 31
Mersenne¬†: 61
Mersenne¬†: 89
Mersenne¬†: 127
Mersenne¬†: 107
Mersenne¬†: 521
Mersenne¬†: 607
Mersenne¬†: 1279
Mersenne¬†: 2281
Mersenne¬†: 2203
Mersenne¬†: 3217
Mersenne¬†: 4423
Mersenne¬†: 4253
Mersenne¬†: 9689
Mersenne¬†: 9941
Mersenne¬†: 11213

real	0m8.581s
user	0m33.894s
sys	0m0.107s

```

# Show the epoch<a id="sec-233"></a>

Task

Choose popular date libraries used by your language and show the ¬† epoch ¬† those libraries use.

A demonstration is preferable ¬† (e.g. setting the internal representation of the date to 0 ms/ns/etc., ¬† or another way that will still show the epoch even if it is changed behind the scenes by the implementers), ¬† but text from (with links to) documentation is also acceptable where a demonstration is impossible/impractical.

For consistency's sake, show the date in UTC time where possible.

Related task

¬† Date format

```rust
extern crate time;
¬†
use time::{at_utc, Timespec};
¬†
fn main() {
    let epoch = at_utc(Timespec::new(0, 0));  
    println!("{}", epoch.asctime());
}
```

Output:

```rust
Thu Jan  1 00:00:00 1970
```

# Almost prime<a id="sec-234"></a>

A ¬† k-Almost-prime ¬† is a natural number ¬† {\displaystyle n} ¬† that is the product of ¬† {\displaystyle k} ¬† (possibly identical) primes.

Example

1-almost-primes, ¬† where ¬† {\displaystyle k=1} , ¬† are the prime numbers themselves. 2-almost-primes, ¬† where ¬† {\displaystyle k=2} , ¬† are the ¬† semiprimes.

Task

Write a function/method/subroutine/&#x2026; that generates k-almost primes and use it to create a table here of the first ten members of k-Almost primes for ¬† {\displaystyle 1<=K<=5} .

Related tasks

¬† Semiprime ¬† Category:Prime Numbers

```rust
fn is_kprime(n: u32, k: u32) -> bool {
    let mut primes = 0;
    let mut f = 2;
    let mut rem = n;
    while primes < k && rem > 1{
        while (rem¬†% f) == 0 && rem > 1{
            rem /= f;
            primes += 1;
        }
        f += 1;
    }
    rem == 1 && primes == k
}
¬†
struct KPrimeGen {
    k: u32,
    n: u32,
}
¬†
impl Iterator for KPrimeGen {
    type Item = u32;
    fn next(&mut self) -> Option<u32> {
        self.n += 1;
        while¬†!is_kprime(self.n, self.k) {
            self.n += 1;
        }
        Some(self.n)
    }
}
¬†
fn kprime_generator(k: u32) -> KPrimeGen {
    KPrimeGen {k: k, n: 1}
}
¬†
fn main() {
    for k in 1..6 {
        println!("{}: {:?}", k, kprime_generator(k).take(10).collect::<Vec<_>>());
    }
}
```

Output:

```rust
1: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
2: [4, 6, 9, 10, 14, 15, 21, 22, 25, 26]
3: [8, 12, 18, 20, 27, 28, 30, 42, 44, 45]
4: [16, 24, 36, 40, 54, 56, 60, 81, 84, 88]
5: [32, 48, 72, 80, 108, 112, 120, 162, 168, 176]

```

# File size<a id="sec-235"></a>

Verify the size of a file called ¬† ¬† input.txt ¬† ¬† for a file in the current working directory, and another one in the file system root.

```rust
use std::{env, fs, process};
use std::io::{self, Write};
use std::fmt::Display;
¬†
fn main() {
    let file_name = env::args().nth(1).unwrap_or_else(|| exit_err("No file name supplied", 1));
    let metadata = fs::metadata(file_name).unwrap_or_else(|e| exit_err(e, 2));
¬†
    println!("Size of file.txt is {} bytes", metadata.len());
}
¬†
#[inline]
fn exit_err<T: Display>(msg: T, code: i32) ->¬†! {
    writeln!(&mut io::stderr(), "Error: {}", msg).expect("Could not write to stdout");
    process::exit(code)
}
¬†
}
```

# Catamorphism<a id="sec-236"></a>

Reduce is a function or method that is used to take the values in an array or a list and apply a function to successive members of the list to produce (or reduce them to), a single value.

Task

Show how reduce (or foldl or foldr etc), work (or would be implemented) in your language.

See also

Wikipedia article: ¬† Fold Wikipedia article: ¬† Catamorphism

```rust
fn main() {
    println!("Sum: {}", (1..10).fold(0, |acc, n| acc + n));
    println!("Product: {}", (1..10).fold(1, |acc, n| acc * n));
    let chars = ['a', 'b', 'c', 'd', 'e'];
    println!("Concatenation: {}",
             chars.iter().map(|&c| (c as u8 + 1) as char).collect::<String>());
}
```

Output:

```rust
Sum: 45
Product: 362880
Concatenation: bcdef

```

# Price fraction<a id="sec-237"></a>

A friend of mine runs a pharmacy. ¬† He has a specialized function in his Dispensary application which receives a decimal value of currency and replaces it to a standard value. ¬† This value is regulated by a government department.

Task

Given a floating point value between ¬† 0.00 ¬† and ¬† 1.00, ¬† rescale according to the following table:

```
>=  0.00  <  0.06 ¬†:=  0.10
>=  0.06  <  0.11 ¬†:=  0.18
>=  0.11  <  0.16 ¬†:=  0.26
>=  0.16  <  0.21 ¬†:=  0.32
>=  0.21  <  0.26 ¬†:=  0.38
>=  0.26  <  0.31 ¬†:=  0.44
>=  0.31  <  0.36 ¬†:=  0.50
>=  0.36  <  0.41 ¬†:=  0.54
>=  0.41  <  0.46 ¬†:=  0.58
>=  0.46  <  0.51 ¬†:=  0.62
>=  0.51  <  0.56 ¬†:=  0.66
>=  0.56  <  0.61 ¬†:=  0.70
>=  0.61  <  0.66 ¬†:=  0.74
>=  0.66  <  0.71 ¬†:=  0.78
>=  0.71  <  0.76 ¬†:=  0.82
>=  0.76  <  0.81 ¬†:=  0.86
>=  0.81  <  0.86 ¬†:=  0.90
>=  0.86  <  0.91 ¬†:=  0.94
>=  0.91  <  0.96 ¬†:=  0.98
>=  0.96  <  1.01 ¬†:=  1.00

```

```rust
fn fix_price(num: f64) -> f64 {
    match num {
        0.96...1.00 => 1.00,
        0.91...0.96 => 0.98,
        0.86...0.91 => 0.94,
        0.81...0.86 => 0.90,
        0.76...0.81 => 0.86,
        0.71...0.76 => 0.82,
        0.66...0.71 => 0.78,
        0.61...0.66 => 0.74,
        0.56...0.61 => 0.70,
        0.51...0.56 => 0.66,
        0.46...0.51 => 0.62,
        0.41...0.46 => 0.58,
        0.36...0.41 => 0.54,
        0.31...0.36 => 0.50,
        0.26...0.31 => 0.44,
        0.21...0.26 => 0.38,
        0.16...0.21 => 0.32,
        0.11...0.16 => 0.26,
        0.06...0.11 => 0.18,
        0.00...0.06 => 0.10,
        // panics on invalid value
        _ => unreachable!(),
    }
}
¬†
fn main() {
    let mut n: f64 = 0.04;
    while n <= 1.00 {
        println!("{:.2} => {}", n, fix_price(n));
        n += 0.04;
    }
}
¬†
// and a unit test to check that we haven't forgotten a branch, use 'cargo test' to execute test.
//
// typically this could be included in the match as those check for exhaustiveness already
// by explicitly listing all remaining ranges / values instead of a catch-all underscore (_)
// but f64::NaN, f64::INFINITY and f64::NEG_INFINITY can't be matched like this
#[test]
fn exhaustiveness_check() {
    let mut input_price = 0.;
    while input_price <= 1. {
        fix_price(input_price);
        input_price += 0.01;
    }
}
```

Output:

```rust
0.04 => 0.1
0.09 => 0.18
0.14 => 0.26
0.19 => 0.32
0.24 => 0.38
0.29 => 0.44
0.34 => 0.5
0.39 => 0.54
0.44 => 0.58
0.49 => 0.62
0.54 => 0.66
0.59 => 0.7
0.64 => 0.74
0.69 => 0.78
0.74 => 0.82
0.79 => 0.86
0.84 => 0.9
0.89 => 0.94
0.94 => 0.98
0.99 => 1
```

Output of unit test:

```rust
running 1 test
test exhaustiveness_check ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
```

# Guess the number/With feedback<a id="sec-238"></a>

Task

Write a game (computer program) that follows the following rules:

The computer chooses a number between given set limits. The player is asked for repeated guesses until the the target number is guessed correctly At each guess, the computer responds with whether the guess is: higher than the target, equal to the target, less than the target, ¬† or the input was inappropriate.

Related task

¬† Guess the number/With Feedback (Player)

Library: rand

```rust
use std::io::stdin;
use rand::{Rng, thread_rng};
¬†
extern crate rand;
¬†
const LOWEST: isize = 1;
const HIGHEST: isize = 100;
¬†
fn main() {
    let mut rng = thread_rng();
¬†
    loop {
        let number: isize = rng.gen_range(LOWEST, HIGHEST + 1);
        let mut num_guesses = 0;
¬†
        println!("I have chosen my number between {} and {}. You know what to do", LOWEST, HIGHEST);
¬†
        loop {
            num_guesses += 1;
¬†
            let mut line = String::new();
            let res = stdin().read_line(&mut line);
            let input: Option<isize> = res.ok().map_or(None, |_| line.trim().parse().ok());
¬†
            match input {
                None => println!("numbers only, please"),
                Some(n) if n == number => {
                    println!("you got it in {} tries!", num_guesses);
                    break;
                }
                Some(n) if n < number => println!("too low!"),
                Some(n) if n > number => println!("too high!"),
                Some(_) => println!("something went wrong")
            }
        }
    }
}
```

```rust
I have chosen my number between 0 and 100. You know what to do
50
too high!
25
too high!
12
too low!
18
too low!
21
too low!
23
you got it in 6 tries!
```

# Sorting algorithms/Selection sort<a id="sec-239"></a>

Task

Sort an array (or list) of elements using the Selection sort algorithm.

It works as follows:

First find the smallest element in the array and exchange it with the element in the first position, then find the second smallest element and exchange it with the element in the second position, and continue in this way until the entire array is sorted.

Its asymptotic complexity is ¬† O(n2) ¬† making it inefficient on large arrays.

Its primary purpose is for when writing data is very expensive (slow) when compared to reading, eg. writing to flash memory or EEPROM.

No other sorting algorithm has less data movement.

Reference

Wikipedia: ¬† Selection sort

```rust
¬†
fn selection_sort(array: &mut [i32]) {
¬†
    let mut min;
¬†
    for i in 0..array.len() {
¬†
        min = i;
¬†
        for j in (i+1)..array.len() {
¬†
            if array[j] < array[min] {
                min = j;
            }
        }
¬†
        let tmp = array[i];
        array[i] = array[min];
        array[min] = tmp;
    }
}
¬†
fn main() {
¬†
    let mut array = [ 9, 4, 8, 3, -5, 2, 1, 6 ];
    println!("The initial array is {:?}", array);
¬†
    selection_sort(&mut array);
    println!(" The sorted array is {:?}", array);
}
¬†
```

# Playing cards<a id="sec-240"></a>

Task

Create a data structure and the associated methods to define and manipulate a deck of ¬† playing cards.

The deck should contain 52 unique cards.

The methods must include the ability to:

¬† make a new deck ¬† shuffle (randomize) the deck ¬† deal from the deck ¬† print the current contents of a deck

Each card must have a pip value and a suit value which constitute the unique value of the card.

Library: rand

```rust
extern crate rand;
¬†
use std::fmt;
use rand::Rng;
use Pip::*;
use Suit::*;
¬†
#[derive(Copy, Clone, Debug)]
enum Pip { Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King }
¬†
#[derive(Copy, Clone, Debug)]
enum Suit { Spades, Hearts, Diamonds, Clubs }
¬†
struct Card {
  pip: Pip,
  suit: Suit
}
¬†
impl fmt::Display for Card {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?} of {:?}", self.pip, self.suit)
    }
}
¬†
struct Deck(Vec<Card>);
¬†
impl Deck {
    fn new() -> Deck {
        let mut cards:Vec<Card> = Vec::with_capacity(52);
        for &suit in &[Spades, Hearts, Diamonds, Clubs] {
            for &pip in &[Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King] {
                cards.push( Card{pip: pip, suit: suit} );
            }
        }
        Deck(cards)
    }
¬†
    fn deal(&mut self) -> Option<Card> {
        self.0.pop()
    }
¬†
    fn shuffle(&mut self) {
        rand::thread_rng().shuffle(&mut self.0)
    }
}
¬†
impl fmt::Display for Deck {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for card in self.0.iter() {
            writeln!(f, "{}", card);
        }
        write!(f, "")
    }
}
¬†
fn main() {
    let mut deck = Deck::new();
    deck.shuffle();
    //println!("{}", deck);
    for _ in 0..5 {
        println!("{}", deck.deal().unwrap());
    }
}
```

Sample output: 5 random cards

```rust
Jack of Diamonds
Nine of Hearts
Queen of Hearts
Six of Clubs
Five of Clubs
```

# Delete a file<a id="sec-241"></a>

Task

Delete a file called "input.txt" and delete a directory called "docs".

This should be done twice: once "here", i.e. in the current working directory and once in the filesystem root.

```rust
use std::io::{self, Write};
use std::fs::{remove_file,remove_dir};
use std::path::Path;
use std::{process,display};
¬†
const FILE_NAME: &'static str = "output.txt";
const DIR_NAME¬†: &'static str = "docs";
¬†
fn main() {
    delete(".").and(delete("/"))
               .unwrap_or_else(|e| error_handler(e,1));
}
¬†
¬†
fn delete<P>(root: P) -> io::Result<()>
    where P: AsRef<Path>
{
    remove_file(root.as_ref().join(FILE_NAME))
        .and(remove_dir(root.as_ref().join(DIR_NAME)))
}
¬†
fn error_handler<E: fmt::Display>(error: E, code: i32) ->¬†! {
    let _ = writeln!(&mut io::stderr(), "{:?}", error);
    process::exit(code)
}
```

# Quaternion type<a id="sec-242"></a>

Quaternions ¬† are an extension of the idea of ¬† complex numbers.

A complex number has a real and complex part, ¬† sometimes written as ¬† a + bi, where ¬† a ¬† and ¬† b ¬† stand for real numbers, and ¬† i ¬† stands for the square root of minus 1.

An example of a complex number might be ¬† -3 + 2i, ¬† where the real part, ¬† a ¬† is ¬† -3.0 ¬† and the complex part, ¬† b ¬† is ¬† +2.0.

A quaternion has one real part and three imaginary parts, ¬† i, ¬† j, ¬† and ¬† k.

A quaternion might be written as ¬† a + bi + cj + dk.

In the quaternion numbering system:

¬† i‚àôi = j‚àôj = k‚àôk = i‚àôj‚àôk = -1, ¬† ¬† ¬† or more simply, ¬† ii ¬†= jj ¬†= kk ¬†= ijk ¬† = -1.

The order of multiplication is important, as, in general, for two quaternions:

¬† q1 ¬† and ¬† q2: ¬† ¬† q1q2 ‚â† q2q1.

An example of a quaternion might be ¬† 1 +2i +3j +4k

There is a list form of notation where just the numbers are shown and the imaginary multipliers ¬† i, ¬† j, ¬† and ¬† k ¬† are assumed by position.

So the example above would be written as ¬† (1, 2, 3, 4)

Task

Given the three quaternions and their components:

```
q  = (1, 2, 3, 4) = (a,  b,  c,  d)
q1 = (2, 3, 4, 5) = (a1, b1, c1, d1)
q2 = (3, 4, 5, 6) = (a2, b2, c2, d2) 

```

And a wholly real number ¬† r = 7.

Create functions ¬† (or classes) ¬† to perform simple maths with quaternions including computing:

The norm of a quaternion:

{\displaystyle ={\sqrt {a<sup>2</sup>+b<sup>2</sup>+c<sup>2</sup>+d<sup>2</sup>}}} The negative of a quaternion: = (-a, -b, -c, -d) The conjugate of a quaternion: = ( a, -b, -c, -d) Addition of a real number ¬† r ¬† and a quaternion ¬† q: r + q = q + r = (a+r, b, c, d) Addition of two quaternions: q1 + q2 = (a1+a2, b1+b2, c1+c2, d1+d2) Multiplication of a real number and a quaternion: qr = rq = (ar, br, cr, dr) Multiplication of two quaternions ¬† q1 ¬† and ¬† q2 ¬† is given by: ( a1a2 ‚àí b1b2 ‚àí c1c2 ‚àí d1d2, ¬† a1b2 + b1a2 + c1d2 ‚àí d1c2, ¬† a1c2 ‚àí b1d2 + c1a2 + d1b2, ¬† a1d2 + b1c2 ‚àí c1b2 + d1a2 ) Show that, for the two quaternions ¬† q1 ¬† and ¬† q2: q1q2 ‚â† q2q1

If a language has built-in support for quaternions, then use it.

C.f.

¬† Vector products ¬† On Quaternions; ¬† or on a new System of Imaginaries in Algebra. ¬† By Sir William Rowan Hamilton LL.D, P.R.I.A., F.R.A.S., Hon. M. R. Soc. Ed. and Dub., Hon. or Corr. M. of the Royal or Imperial Academies of St. Petersburgh, Berlin, Turin and Paris, Member of the American Academy of Arts and Sciences, and of other Scientific Societies at Home and Abroad, Andrews' Prof. of Astronomy in the University of Dublin, and Royal Astronomer of Ireland.

```rust
use std::fmt::{Display, Error, Formatter};
use std::ops::{Add, Mul, Neg};
¬†
#[derive(Clone,Copy,Debug)]
struct Quaternion {
    a: f64,
    b: f64,
    c: f64,
    d: f64
}
¬†
impl Quaternion {
    pub fn new(a: f64, b: f64, c: f64, d: f64) -> Quaternion {
        Quaternion {
            a: a,
            b: b,
            c: c,
            d: d
        }
    }
¬†
    pub fn norm(&self) -> f64 {
        (self.a.powi(2) + self.b.powi(2) + self.c.powi(2) + self.d.powi(2)).sqrt()
    }
¬†
    pub fn conjugate(&self) -> Quaternion {
        Quaternion {
            a: self.a,
            b: -self.b,
            c: -self.c,
            d: -self.d
        }
    }
}
¬†
impl Add for Quaternion {
    type Output = Quaternion;
¬†
    #[inline]
    fn add(self, other: Quaternion) -> Self::Output {
        Quaternion {
            a: self.a + other.a,
            b: self.b + other.b,
            c: self.c + other.c,
            d: self.d + other.d
        }
    }
}
¬†
impl Add<f64> for Quaternion {
    type Output = Quaternion;
¬†
    #[inline]
    fn add(self, other: f64) -> Self::Output {
        Quaternion {
            a: self.a + other,
            b: self.b,
            c: self.c,
            d: self.d
        }
    }
}
¬†
impl Add<Quaternion> for f64 {
    type Output = Quaternion;
¬†
    #[inline]
    fn add(self, other: Quaternion) -> Self::Output {
        Quaternion {
            a: other.a + self,
            b: other.b,
            c: other.c,
            d: other.d
        }
    }
}
¬†
impl Display for Quaternion {
    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {
        write!(f, "({} + {}i + {}j + {}k)", self.a, self.b, self.c, self.d)
    }
}
¬†
impl Mul for Quaternion {
    type Output = Quaternion;
¬†
    #[inline]
    fn mul(self, rhs: Quaternion) -> Self::Output {
        Quaternion {
            a: self.a * rhs.a - self.b * rhs.b - self.c * rhs.c - self.d * rhs.d,
            b: self.a * rhs.b + self.b * rhs.a + self.c * rhs.d - self.d * rhs.c,
            c: self.a * rhs.c - self.b * rhs.d + self.c * rhs.a + self.d * rhs.b,
            d: self.a * rhs.d + self.b * rhs.c - self.c * rhs.b + self.d * rhs.a,
        }
    }
}
¬†
impl Mul<f64> for Quaternion {
    type Output = Quaternion;
¬†
    #[inline]
    fn mul(self, other: f64) -> Self::Output {
        Quaternion {
            a: self.a * other,
            b: self.b * other,
            c: self.c * other,
            d: self.d * other
        }
    }
}
¬†
impl Mul<Quaternion> for f64 {
    type Output = Quaternion;
¬†
    #[inline]
    fn mul(self, other: Quaternion) -> Self::Output {
        Quaternion {
            a: other.a * self,
            b: other.b * self,
            c: other.c * self,
            d: other.d * self
        }
    }
}
¬†
impl Neg for Quaternion {
    type Output = Quaternion;
¬†
    #[inline]
    fn neg(self) -> Self::Output {
        Quaternion {
            a: -self.a,
            b: -self.b,
            c: -self.c,
            d: -self.d
        }
    }
}
¬†
fn main() {
    let q0 = Quaternion { a: 1., b: 2., c: 3., d: 4. };
    let q1 = Quaternion::new(2., 3., 4., 5.);
    let q2 = Quaternion::new(3., 4., 5., 6.);
    let r: f64 = 7.;
¬†
    println!("q0 = {}", q0);
    println!("q1 = {}", q1);
    println!("q2 = {}", q2);
    println!("r  = {}", r);
    println!();
    println!("-q0 = {}", -q0);
    println!("conjugate of q0 = {}", q0.conjugate());
    println!();
    println!("r + q0 = {}", r + q0);
    println!("q0 + r = {}", q0 + r);
    println!();
    println!("r * q0 = {}", r * q0);
    println!("q0 * r = {}", q0 * r);
    println!();
    println!("q0 + q1 = {}", q0 + q1);
    println!("q0 * q1 = {}", q0 * q1);
    println!();
    println!("q0 * (conjugate of q0) = {}", q0 * q0.conjugate());
    println!();
    println!(" q0 + q1  * q2 = {}", q0 + q1 * q2);
    println!("(q0 + q1) * q2 = {}", (q0 + q1) * q2);
    println!();
    println!(" q0 *  q1  * q2  = {}", q0 *q1 * q2);
    println!("(q0 *  q1) * q2  = {}", (q0 * q1) * q2);
    println!(" q0 * (q1  * q2) = {}", q0 * (q1 * q2));
    println!();
    println!("normal of q0 = {}", q0.norm());
}
```

Output:

```rust
q0 = (1 + 2i + 3j + 4k)
q1 = (2 + 3i + 4j + 5k)
q2 = (3 + 4i + 5j + 6k)
r  = 7

-q0 = (-1 + -2i + -3j + -4k)
conjugate of q0 = (1 + -2i + -3j + -4k)

r + q0 = (8 + 2i + 3j + 4k)
q0 + r = (8 + 2i + 3j + 4k)

r * q0 = (7 + 14i + 21j + 28k)
q0 * r = (7 + 14i + 21j + 28k)

q0 + q1 = (3 + 5i + 7j + 9k)
q0 * q1 = (-36 + 6i + 12j + 12k)

q0 * (conjugate of q0) = (30 + 0i + 0j + 0k)

 q0 + q1  * q2 = (-55 + 18i + 27j + 30k)
(q0 + q1) * q2 = (-100 + 24i + 42j + 42k)

 q0 *  q1  * q2  = (-264 + -114i + -132j + -198k)
(q0 *  q1) * q2  = (-264 + -114i + -132j + -198k)
 q0 * (q1  * q2) = (-264 + -114i + -132j + -198k)

normal of q0 = 5.477225575051661

```

# Random number generator (included)<a id="sec-243"></a>

The task is to:

State the type of random number generator algorithm used in a language's built-in random number generator. If the language or its immediate libraries don't provide a random number generator, skip this task. If possible, give a link to a wider explanation of the algorithm used.

Note: the task is not to create an RNG, but to report on the languages in-built RNG that would be the most likely RNG used.

The main types of pseudo-random number generator (PRNG) that are in use are the Linear Congruential Generator (LCG), and the Generalized Feedback Shift Register (GFSR), (of which the Mersenne twister generator is a subclass). The last main type is where the output of one of the previous ones (typically a Mersenne twister) is fed through a cryptographic hash function to maximize unpredictability of individual bits.

Note that neither LCGs nor GFSRs should be used for the most demanding applications (cryptography) without additional steps.

Rust's rand crate offers several PRNGs. (It is also available via #\![feature(rustc<sub>private</sub>)]). The offering includes some cryptographically secure PRNGs: ISAAC (both 32 and 64-bit variants) and ChaCha20. StdRng is a wrapper of one of those efficient on the current platform. The crate also provides a weak PRNG: Xorshift128. It passes diehard but fails TestU01, replacement is being considered. thread<sub>rng</sub> returns a thread local StdRng initialized from the OS. Other PRNGs can be created from the OS or with thread<sub>rng</sub>.

For any other PRNGs not provided, they merely have to implement the Rng trait.

# String append<a id="sec-244"></a>

Most languages provide a way to concatenate two string values, but some languages also provide a convenient way to append in-place to an existing string variable without referring to the variable twice.

Task

Create a string variable equal to any text value.

Append the string variable with another string literal in the most idiomatic way, without double reference if your language supports it.

Show the contents of the variable after the append operation.

```rust
¬†
use std::ops::Add;
¬†
fn main(){
    let hello = String::from("Hello world");
    println!("{}", hello.add("!!!!"));
}
```

Output:

Hello world!!!!

# 24 game/Solve<a id="sec-245"></a>

task

Write a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the 24 game.

Show examples of solutions generated by the program.

Related task

¬† Arithmetic Evaluator

Works with: Rust version 1.17

```rust
#[derive(Clone, Copy, Debug)]
enum Operator {
    Sub,
    Plus,
    Mul,
    Div,
}
¬†
#[derive(Clone, Debug)]
struct Factor {
    content: String,
    value: i32,
}
¬†
fn apply(op: Operator, left: &[Factor], right: &[Factor]) -> Vec<Factor> {
    let mut ret = Vec::new();
    for l in left.iter() {
        for r in right.iter() {
            use Operator::*;
            ret.push(match op {
                Sub if l.value > r.value => Factor {
                    content: format!("({} - {})", l.content, r.content),
                    value: l.value - r.value,
                },
                Plus => Factor {
                    content: format!("({} + {})", l.content, r.content),
                    value: l.value + r.value,
                },
                Mul => Factor {
                    content: format!("({} x {})", l.content, r.content),
                    value: l.value * r.value,
                },
                Div if l.value >= r.value && r.value > 0 && l.value¬†% r.value == 0 => Factor {
                    content: format!("({} / {})", l.content, r.content),
                    value: l.value / r.value,
                },
                _ => continue,
            })
        }
    }
    ret
}
¬†
fn calc(op: [Operator; 3], numbers: [i32; 4]) -> Vec<Factor> {
    fn calc(op: &[Operator], numbers: &[i32], acc: &[Factor]) -> Vec<Factor> {
        use Operator::*;
        if op.is_empty() {
            return Vec::from(acc)
        }
        let mut ret = Vec::new();
        let mono_factor = [Factor {
            content: numbers[0].to_string(),
            value: numbers[0],
        }];
        match op[0] {
            Mul => ret.extend_from_slice(&apply(op[0], acc, &mono_factor)),
            Div => {
                ret.extend_from_slice(&apply(op[0], acc, &mono_factor));
                ret.extend_from_slice(&apply(op[0], &mono_factor, acc));
            },
            Sub => {
                ret.extend_from_slice(&apply(op[0], acc, &mono_factor));
                ret.extend_from_slice(&apply(op[0], &mono_factor, acc));
            },
            Plus => ret.extend_from_slice(&apply(op[0], acc, &mono_factor)),   
        }
        calc(&op[1..], &numbers[1..], &ret)
    }
    calc(&op, &numbers[1..], &[Factor { content: numbers[0].to_string(), value: numbers[0] }])
}
¬†
fn solutions(numbers: [i32; 4]) -> Vec<Factor> {
    use std::collections::hash_set::HashSet;
    let mut ret = Vec::new();
    let mut hash_set = HashSet::new();
¬†
    for ops in OpIter(0) {
        for o in orders().iter() {
            let numbers = apply_order(numbers, o);
            let r = calc(ops, numbers);
            ret.extend(r.into_iter().filter(|&Factor { value, ref content }| value == 24 && hash_set.insert(content.to_owned())))
        }
    }
    ret
}
¬†
fn main() {
    let mut numbers = Vec::new();
    if let Some(input) = std::env::args().skip(1).next() {
        for c in input.chars() {
            if let Ok(n) = c.to_string().parse() {
                numbers.push(n)
            }
            if numbers.len() == 4 {
                let numbers = [numbers[0], numbers[1], numbers[2], numbers[3]];
                let solutions = solutions(numbers);
                let len = solutions.len();
                if len == 0 {
                    println!("no solution for {}, {}, {}, {}", numbers[0], numbers[1], numbers[2], numbers[3]);
                    return
                }
                println!("solutions for {}, {}, {}, {}", numbers[0], numbers[1], numbers[2], numbers[3]);
                for s in solutions {
                    println!("{}", s.content)
                }
                println!("{} solutions found", len);
                return
            }
        }
    } else {
        println!("empty input")
    }
}
¬†
¬†
struct OpIter (usize);
¬†
impl Iterator for OpIter {
    type Item = [Operator; 3];
    fn next(&mut self) -> Option<[Operator; 3]> {
        use Operator::*;
        const OPTIONS: [Operator; 4] = [Mul, Sub, Plus, Div];
        if self.0 >= 1 << 6 {
            return None
        }
        let f1 = OPTIONS[(self.0 & (3 << 4)) >> 4];
        let f2 = OPTIONS[(self.0 & (3 << 2)) >> 2];
        let f3 = OPTIONS[(self.0 & (3 << 0)) >> 0];
        self.0 += 1;
        Some([f1, f2, f3])
    }
}
¬†
fn orders() -> [[usize; 4]; 24] {
    [
        [0, 1, 2, 3],
        [0, 1, 3, 2],
        [0, 2, 1, 3],
        [0, 2, 3, 1],
        [0, 3, 1, 2],
        [0, 3, 2, 1],
        [1, 0, 2, 3],
        [1, 0, 3, 2],
        [1, 2, 0, 3],
        [1, 2, 3, 0],
        [1, 3, 0, 2],
        [1, 3, 2, 0],
        [2, 0, 1, 3],
        [2, 0, 3, 1],
        [2, 1, 0, 3],
        [2, 1, 3, 0],
        [2, 3, 0, 1],
        [2, 3, 1, 0],
        [3, 0, 1, 2],
        [3, 0, 2, 1],
        [3, 1, 0, 2],
        [3, 1, 2, 0],
        [3, 2, 0, 1],
        [3, 2, 1, 0]
    ]
}
¬†
fn apply_order(numbers: [i32; 4], order: &[usize; 4]) -> [i32; 4] {
    [numbers[order[0]], numbers[order[1]], numbers[order[2]], numbers[order[3]]]
}
¬†
```

Output:

```rust
$cargo run 5598
solutions for 5, 5, 9, 8
(((5 x 5) - 9) + 8)
(((5 x 5) + 8) - 9)
(((8 - 5) x 5) + 9)
3 solutions found

```

# Averages/Mean angle<a id="sec-246"></a>

When calculating the average or mean of an angle one has to take into account how angles wrap around so that any angle in degrees plus any integer multiple of 360 degrees is a measure of the same angle.

If one wanted an average direction of the wind over two readings where the first reading was of 350 degrees and the second was of 10 degrees then the average of the numbers is 180 degrees, whereas if you can note that 350 degrees is equivalent to -10 degrees and so you have two readings at 10 degrees either side of zero degrees leading to a more fitting mean angle of zero degrees.

To calculate the mean angle of several angles:

Assume all angles are on the unit circle and convert them to complex numbers expressed in real and imaginary form. Compute the mean of the complex numbers. Convert the complex mean to polar coordinates whereupon the phase of the complex mean is the required angular mean.

(Note that, since the mean is the sum divided by the number of numbers, and division by a positive real number does not affect the angle, you can also simply compute the sum for step 2.)

You can alternatively use this formula:

Given the angles {\displaystyle &alpha; \_{1},&hellip; ,&alpha; \_{n}} the mean is computed by

{\displaystyle {\bar {&alpha; }}=\operatorname {atan2} \left({\frac {1}{n}}&sdot; &sum; \_{j=1}<sup>n</sup>sin &alpha; \_{j},{\frac {1}{n}}&sdot; &sum; \_{j=1}<sup>n</sup>cos &alpha; \_{j}\right)}

Task[edit]

write a function/method/subroutine/&#x2026; that given a list of angles in degrees returns their mean angle. (You should use a built-in function if you have one that does this for degrees or radians). Use the function to compute the means of these lists of angles (in degrees): ¬† [350, 10] ¬† [90, 180, 270, 360] ¬† [10, 20, 30] Show your output here.

See also

Tasks for calculating statistical measures

in one go moving (sliding window) moving (cumulative) Mean Arithmetic Statistics/Basic Averages/Arithmetic mean Averages/Pythagorean means

Averages/Simple moving average

Geometric Averages/Pythagorean means

Harmonic Averages/Pythagorean means

Quadratic Averages/Root mean square

Circular Averages/Mean angle Averages/Mean time of day

Median Averages/Median

Mode Averages/Mode

Standard deviation Statistics/Basic

Cumulative standard deviation

```rust
¬†
use std::f64;
// the macro is from
// http://stackoverflow.com/questions/30856285/assert-eq-with-floating-
// point-numbers-and-delta
fn mean_angle(angles: &[f64]) -> f64 {
    let length: f64 = angles.len() as f64;
    let cos_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().cos()) / length;
    let sin_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().sin()) / length;
    (sin_mean).atan2(cos_mean).to_degrees()
}
¬†
fn main() {
    let angles1 = [350.0_f64, 10.0];
    let angles2 = [90.0_f64, 180.0, 270.0, 360.0];
    let angles3 = [10.0_f64, 20.0, 30.0];
    println!("Mean Angle for {:?}  is {:.5} degrees",
             &angles1,
             mean_angle(&angles1));
    println!("Mean Angle for {:?}  is {:.5} degrees",
             &angles2,
             mean_angle(&angles2));
    println!("Mean Angle for {:?}  is {:.5} degrees",
             &angles3,
             mean_angle(&angles3));
}
¬†
macro_rules! assert_diff{
    ($x: expr,$y¬†: expr, $diff¬†:expr)=>{
        if ( $x - $y ).abs() > $diff {
            panic!("floating point difference is to big {}", $x - $y );
        }
    }
}
¬†
#[test]
fn calculate() {
    let angles1 = [350.0_f64, 10.0];
    let angles2 = [90.0_f64, 180.0, 270.0, 360.0];
    let angles3 = [10.0_f64, 20.0, 30.0];
    assert_diff!(0.0, mean_angle(&angles1), 0.001);
    assert_diff!(-90.0, mean_angle(&angles2), 0.001);
    assert_diff!(20.0, mean_angle(&angles3), 0.001);
}
¬†
```

# Linear congruential generator<a id="sec-247"></a>

The linear congruential generator is a very simple example of a random number generator. All linear congruential generators use this formula:

{\displaystyle r<sub>n+1</sub>=a&times; r<sub>n</sub>+c{\pmod {m}}}

Where:

{\displaystyle r<sub>0</sub>} is a seed. {\displaystyle r<sub>1</sub>} , {\displaystyle r<sub>2</sub>} , {\displaystyle r<sub>3</sub>} , &#x2026;, are the random numbers. {\displaystyle a} , {\displaystyle c} , {\displaystyle m} are constants.

If one chooses the values of {\displaystyle a} , {\displaystyle c} and {\displaystyle m} with care, then the generator produces a uniform distribution of integers from {\displaystyle 0} to {\displaystyle m-1} .

LCG numbers have poor quality. {\displaystyle r<sub>n</sub>} and {\displaystyle r<sub>n+1</sub>} are not independent, as true random numbers would be. Anyone who knows {\displaystyle r<sub>n</sub>} can predict {\displaystyle r<sub>n+1</sub>} , therefore LCG is not cryptographically secure. The LCG is still good enough for simple tasks like Miller-Rabin primality test, or FreeCell deals. Among the benefits of the LCG, one can easily reproduce a sequence of numbers, from the same {\displaystyle r<sub>0</sub>} . One can also reproduce such sequence with a different programming language, because the formula is so simple.

The task is to replicate two historic random number generators. One is the rand() function from BSD libc, and the other is the rand() function from the Microsoft C Runtime (MSCVRT.DLL). Each replica must yield the same sequence of integers as the original generator, when starting from the same seed.

In these formulas, the seed becomes {\displaystyle state<sub>0</sub>} . The random sequence is {\displaystyle rand<sub>1</sub>} , {\displaystyle rand<sub>2</sub>} and so on.

BSD formula:

{\displaystyle state<sub>n+1</sub>=1103515245&times; state<sub>n</sub>+12345{\pmod {2<sup>31</sup>}}} {\displaystyle rand<sub>n</sub>=state<sub>n</sub>} {\displaystyle rand<sub>n</sub>} is in range 0 to 2147483647.

Microsoft formula:

{\displaystyle state<sub>n+1</sub>=214013&times; state<sub>n</sub>+2531011{\pmod {2<sup>31</sup>}}} {\displaystyle rand<sub>n</sub>=state<sub>n</sub>&divide; 2<sup>16</sup>} {\displaystyle rand<sub>n</sub>} is in range 0 to 32767.

The BSD formula was so awful that FreeBSD switched to a different formula. More info is at Random number generator (included)#C.

```rust
extern crate rand;
¬†
pub use rand::{Rng, SeedableRng};
¬†
pub struct BsdLcg {
    state: u32,
}
¬†
impl Rng for BsdLcg {
    // Because the output is in the range [0, 2147483647], this should technically be `next_u16`
    // (the largest integer size which is fully covered, as `rand::Rng` assumes).  The `rand`
    // crate does not provide it however.  If serious usage is required, implementing this
    // function as a concatenation of two `next_u16`s (elsewhere defined) should work.
    fn next_u32(&mut self) -> u32 {
        self.state = self.state.wrapping_mul(1_103_515_245).wrapping_add(12_345);
        self.state¬†%= 1 << 31;
        self.state
    }
}
¬†
impl SeedableRng<u32> for BsdLcg {
    fn from_seed(seed: u32) -> Self {
        Self { state: seed }
    }
    fn reseed(&mut self, seed: u32) {
        self.state = seed;
    }
}
¬†
pub struct MsLcg {
    state: u32,
}
¬†
impl Rng for MsLcg {
    // Similarly, this outputs in the range [0, 32767] and should output a `u8`.  Concatenate
    // four `next_u8`s for serious usage.
    fn next_u32(&mut self) -> u32 {
        self.state = self.state.wrapping_mul(214_013).wrapping_add(2_531_011);
        self.state¬†%= 1 << 31;
        self.state >> 16 // rand_n = state_n / 2^16
    }
}
¬†
impl SeedableRng<u32> for MsLcg {
    fn from_seed(seed: u32) -> Self {
        Self { state: seed }
    }
    fn reseed(&mut self, seed: u32) {
        self.state = seed;
    }
}
¬†
fn main() {
    println!("~~~ BSD ~~~");
    let mut bsd = BsdLcg::from_seed(0);
    for _ in 0..10 {
        println!("{}", bsd.next_u32());
    }
¬†
    println!("~~~ MS ~~~");
    let mut ms = MsLcg::from_seed(0);
    for _ in 0..10 {
        println!("{}", ms.next_u32());
    }
¬†
    // Because we have implemented the `rand::Rng` trait, we can generate a variety of other types.
    println!("~~~ Others ~~~");
    println!("{:?}", ms.gen::<[u32; 5]>());
    println!("{}", ms.gen::<bool>());
    println!("{}", ms.gen_ascii_chars().take(15).collect::<String>());
}
```

# String prepend<a id="sec-248"></a>

Task

Create a string variable equal to any text value.

Prepend the string variable with another string literal.

If your language supports any idiomatic ways to do this without referring to the variable twice in one expression, include such solutions.

To illustrate the operation, show the content of the variable.

```rust
¬†
let mut s = "World".to_string();
s.insert_str(0, "Hello ");
println!("{}", s);
¬†
```

# Numerical integration<a id="sec-249"></a>

Write functions to calculate the definite integral of a function ∆í(x) using all five of the following methods:

rectangular left right midpoint trapezium Simpson's composite

Your functions should take in the upper and lower bounds (a and b), and the number of approximations to make in that range (n).

Assume that your example already has a function that gives values for ∆í(x) .

Simpson's method is defined by the following pseudo-code:

Pseudocode: Simpson's method, composite procedure quad<sub>simpson</sub><sub>composite</sub>(f, a, b, n) h¬†:= (b - a) / n sum1¬†:= f(a + h/2) sum2¬†:= 0

loop on i from 1 to (n - 1) sum1¬†:= sum1 + f(a + h \* i + h/2) sum2¬†:= sum2 + f(a + h \* i)

answer¬†:= (h / 6) \* (f(a) + f(b) + 4\*sum1 + 2\*sum2)

Demonstrate your function by showing the results for:

∆í(x) = x3, where x is [0,1], with 100 approximations. The exact result is 1/4, or 0.25. ∆í(x) = 1/x, where x is [1,100], with 1,000 approximations. The exact result is the natural log of 100, or about 4.605170 ∆í(x) = x, where x is [0,5000], with 5,000,000 approximations. The exact result is 12,500,000. ∆í(x) = x, where x is [0,6000], with 6,000,000 approximations. The exact result is 18,000,000.

See also

Active object for integrating a function of real time. Special:PrefixIndex/Numerical integration for other integration methods.

This is a partial solution and only implements trapezium integration.

```rust
fn integral<F>(f: F, range: std::ops::Range<f64>, n_steps: u32) -> f64
    where F: Fn(f64) -> f64
{
    let step_size = (range.end - range.start)/n_steps as f64;
¬†
    let mut integral = (f(range.start) + f(range.end))/2.;
    let mut pos = range.start + step_size;
    while pos < range.end {
        integral += f(pos);
        pos += step_size;
    }
    integral * step_size
}
¬†
fn main() {
    println!("{}", integral(|x| x.powi(3), 0.0..1.0, 100));
    println!("{}", integral(|x| 1.0/x, 1.0..100.0, 1000));
    println!("{}", integral(|x| x, 0.0..5000.0, 5_000_000));
    println!("{}", integral(|x| x, 0.0..6000.0, 6_000_000));
}
```

Output:

```rust
0.2500250000000004
4.605986057514688
12500000.000728702
18000000.001390498
```

# Cholesky decomposition<a id="sec-250"></a>

Every symmetric, positive definite matrix A can be decomposed into a product of a unique lower triangular matrix L and its transpose:

{\displaystyle A=LL<sup>T</sup>}

{\displaystyle L} is called the Cholesky factor of {\displaystyle A} , and can be interpreted as a generalized square root of {\displaystyle A} , as described in Cholesky decomposition.

In a 3x3 example, we have to solve the following system of equations:

{\displaystyle {\begin{aligned}A&={\begin{pmatrix}a<sub>11</sub>&a<sub>21</sub>&a<sub>31</sub>\\\a<sub>21</sub>&a<sub>22</sub>&a<sub>32</sub>\\\a<sub>31</sub>&a<sub>32</sub>&a<sub>33</sub>\\\\\end{pmatrix}}\\\\&={\begin{pmatrix}l<sub>11</sub>&0&0\\\l<sub>21</sub>&l<sub>22</sub>&0\\\l<sub>31</sub>&l<sub>32</sub>&l<sub>33</sub>\\\\\end{pmatrix}}{\begin{pmatrix}l<sub>11</sub>&l<sub>21</sub>&l<sub>31</sub>\\\\0&l<sub>22</sub>&l<sub>32</sub>\\\\0&0&l<sub>33</sub>\end{pmatrix}}&equiv; LL<sup>T</sup>\\\\&={\begin{pmatrix}l<sub>11</sub><sup>2</sup>&l<sub>21</sub>l<sub>11</sub>&l<sub>31</sub>l<sub>11</sub>\\\l<sub>21</sub>l<sub>11</sub>&l<sub>21</sub><sup>2</sup>+l<sub>22</sub><sup>2</sup>&l<sub>31</sub>l<sub>21</sub>+l<sub>32</sub>l<sub>22</sub>\\\l<sub>31</sub>l<sub>11</sub>&l<sub>31</sub>l<sub>21</sub>+l<sub>32</sub>l<sub>22</sub>&l<sub>31</sub><sup>2</sup>+l<sub>32</sub><sup>2</sup>+l<sub>33</sub><sup>2</sup>\end{pmatrix}}\end{aligned}}}

We can see that for the diagonal elements ( {\displaystyle l<sub>kk</sub>} ) of {\displaystyle L} there is a calculation pattern:

{\displaystyle l<sub>11</sub>={\sqrt {a<sub>11</sub>}}} {\displaystyle l<sub>22</sub>={\sqrt {a<sub>22</sub>-l<sub>21</sub><sup>2</sup>}}} {\displaystyle l<sub>33</sub>={\sqrt {a<sub>33</sub>-(l<sub>31</sub><sup>2</sup>+l<sub>32</sub><sup>2</sup>)}}}

or in general:

{\displaystyle l<sub>kk</sub>={\sqrt {a<sub>kk</sub>-&sum; \_{j=1}<sup>k-1</sup>l<sub>kj</sub><sup>2</sup>}}}

For the elements below the diagonal ( {\displaystyle l<sub>ik</sub>} , where {\displaystyle i>k} ) there is also a calculation pattern:

{\displaystyle l<sub>21</sub>={\frac {1}{l<sub>11</sub>}}a<sub>21</sub>} {\displaystyle l<sub>31</sub>={\frac {1}{l<sub>11</sub>}}a<sub>31</sub>} {\displaystyle l<sub>32</sub>={\frac {1}{l<sub>22</sub>}}(a<sub>32</sub>-l<sub>31</sub>l<sub>21</sub>)}

which can also be expressed in a general formula:

{\displaystyle l<sub>ik</sub>={\frac {1}{l<sub>kk</sub>}}\left(a<sub>ik</sub>-&sum; \_{j=1}<sup>k-1</sup>l<sub>ij</sub>l<sub>kj</sub>\right)}

Task description

The task is to implement a routine which will return a lower Cholesky factor {\displaystyle L} for every given symmetric, positive definite nxn matrix {\displaystyle A} . You should then test it on the following two examples and include your output.

Example 1:

```
25  15  -5                 5   0   0
15  18   0         -->     3   3   0
-5   0  11                -1   1   3

```

Example 2:

```
18  22   54   42           4.24264    0.00000    0.00000    0.00000
22  70   86   62   -->     5.18545    6.56591    0.00000    0.00000
54  86  174  134          12.72792    3.04604    1.64974    0.00000
42  62  134  106           9.89949    1.62455    1.84971    1.39262

```

Note

The Cholesky decomposition of a Pascal upper-triangle matrix is the Identity matrix of the same size. The Cholesky decomposition of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.

Translation of: C

```rust
fn cholesky(mat: Vec<f64>, n: usize) -> Vec<f64> {
    let mut res = vec![0.0; mat.len()];
    for i in 0..n {
        for j in 0..(i+1){
            let mut s = 0.0;
            for k in 0..j {
                s += res[i * n + k] * res[j * n + k];
            }
            res[i * n + j] = if i == j { (mat[i * n + i] - s).sqrt() } else { (1.0 / res[j * n + j] * (mat[i * n + j] - s)) };
        }
    }
    res
}
¬†
fn show_matrix(matrix: Vec<f64>, n: usize){
    for i in 0..n {
        for j in 0..n {
            print!("{:.4}\t", matrix[i * n + j]);
        }
        println!("");
    }
    println!("");
}
¬†
fn main(){
    let dimension = 3 as usize;
    let m1 = vec![25.0, 15.0, -5.0,
                  15.0, 18.0,  0.0,
                  -5.0,  0.0, 11.0];
    let res1 = cholesky(m1, dimension);
    show_matrix(res1, dimension);
¬†
    let dimension = 4 as usize;
    let m2 = vec![18.0, 22.0,  54.0,  42.0,
                  22.0, 70.0,  86.0,  62.0,
                  54.0, 86.0, 174.0, 134.0,
                  42.0, 62.0, 134.0, 106.0];
    let res2 = cholesky(m2, dimension);
    show_matrix(res2, dimension);
}
¬†
```

Output:

```rust
5.0000	0.0000	0.0000	
3.0000	3.0000	0.0000	
-1.0000	1.0000	3.0000	

4.2426	0.0000	0.0000	0.0000	
5.1854	6.5659	0.0000	0.0000	
12.7279	3.0460	1.6497	0.0000	
9.8995	1.6246	1.8497	1.3926	

```

# Integer overflow<a id="sec-251"></a>

Some languages support one or more integer types of the underlying processor.

This integer types have fixed size; ¬† usually ¬† 8-bit, ¬† 16-bit, ¬† 32-bit, ¬† or ¬† 64-bit. The integers supported by such a type can be ¬† signed ¬† or ¬† unsigned.

Arithmetic for machine level integers can often be done by single CPU instructions. This allows high performance and is the main reason to support machine level integers.

Definition

An integer overflow happens when the result of a computation does not fit into the fixed size integer. The result can be too small or too big to be representable in the fixed size integer.

Task

When a language has fixed size integer types, create a program that does arithmetic computations for the fixed size integers of the language.

These computations must be done such that the result would overflow.

The program should demonstrate what the following expressions do.

For 32-bit signed integers:

Expression Result that does not fit into a 32-bit signed integer -(-2147483647-1) 2147483648 2000000000 + 2000000000 4000000000 -2147483647 - 2147483647 -4294967294 46341 \* 46341 2147488281 (-2147483647-1) / -1 2147483648

For 64-bit signed integers:

Expression Result that does not fit into a 64-bit signed integer -(-9223372036854775807-1) 9223372036854775808 5000000000000000000+5000000000000000000 10000000000000000000 -9223372036854775807 - 9223372036854775807 -18446744073709551614 3037000500 \* 3037000500 9223372037000250000 (-9223372036854775807-1) / -1 9223372036854775808

For 32-bit unsigned integers:

Expression Result that does not fit into a 32-bit unsigned integer -4294967295 -4294967295 3000000000 + 3000000000 6000000000 2147483647 - 4294967295 -2147483648 65537 \* 65537 4295098369

For 64-bit unsigned integers:

Expression Result that does not fit into a 64-bit unsigned integer -18446744073709551615 -18446744073709551615 10000000000000000000 + 10000000000000000000 20000000000000000000 9223372036854775807 - 18446744073709551615 -9223372036854775808 4294967296 \* 4294967296 18446744073709551616

When the integer overflow does trigger an exception show how the exception is caught. When the integer overflow produces some value print it. It should be explicitly noted when an integer overflow is not recognized and the program continues with wrong results. This should be done for signed and unsigned integers of various sizes supported by the language. When a language has no fixed size integer type or when no integer overflow can occur for other reasons this should be noted. It is okay to mention, when a language supports unlimited precision integers, but this task is NOT the place to demonstrate the capabilities of unlimited precision integers.

Rust does not allow signed integer overflow, due to it being undefined behaviour. If an integer overflow can be determined at compile-time, a warning is emitted. e.g.

```rust
integer_overflow.rs:6:23: 6:48 warning: attempted to divide with overflow, #[warn(const_err)] on by default
integer_overflow.rs:6     let i32_5¬†: i32 = (-2_147_483_647 - 1) / -1;

```

If signed overflow occurs during program execution, a panic! is raised.

```rust
$ ./integer_overflow
thread '<main>' panicked at 'attempted to negate with overflow', integer_overflow.rs:2
note: Run with `RUST_BACKTRACE=1` for a backtrace.

```

The following code will always panic when run in any mode

```rust
¬†
    // The following will panic!
    let i32_1¬†: i32 = -(-2_147_483_647 - 1);
    let i32_2¬†: i32 = 2_000_000_000 + 2_000_000_000;
    let i32_3¬†: i32 = -2_147_483_647 - 2_147_483_647;
    let i32_4¬†: i32 = 46341 * 46341;
    let i32_5¬†: i32 = (-2_147_483_647 - 1) / -1;
¬†
    // These will panic! also
    let i64_1¬†: i64 = -(-9_223_372_036_854_775_807 - 1);
    let i64_2¬†: i64 = 5_000_000_000_000_000_000 + 5_000_000_000_000_000_000;
    let i64_3¬†: i64 = -9_223_372_036_854_775_807 - 9_223_372_036_854_775_807;
    let i64_4¬†: i64 = 3_037_000_500 * 3_037_000_500;
    let i64_5¬†: i64 = (-9_223_372_036_854_775_807 - 1) / -1;
¬†
```

Unsigned overflow works slightly different that most languages. Compiling in debug mode will make unsigned overflow act in the same way as signed overflow. When compiling in release mode, unsigned overflow is defined as it is in C, with the usual wrapping procedures.

Note: Unary negation is not allowed on unsigned types in rust, so we simulate this via a manual two's complement calculation. (! is unary negation)

```rust
¬†
    // The following will panic!, but only in release mode
    let u32_1¬†: u32 =¬†!4_294_967_295 + 1;
    let u32_2¬†: u32 = 3_000_000_000 + 3_000_000_000;
    let u32_3¬†: u32 = 2_147_483_647 - 4_294_967_295;
    let u32_4¬†: u32 = 65_537 * 65_537;
¬†
    // The following panics! in release mode
    let u64_1¬†: u64 =¬†!18_446_744_073_709_551_615 + 1;
    let u64_2¬†: u64 = 10_000_000_000_000_000_000 + 10_000_000_000_000_000_000;
    let u64_3¬†: u64 = 9_223_372_036_854_775_807 - 18_446_744_073_709_551_615;
    let u64_4¬†: u64 = 4_294_967_296 * 4_294_967_296;
¬†
    println!("{}", u32_1); // 1
    println!("{}", u32_2); // 1705032704
    println!("{}", u32_3); // 2147483648
    println!("{}", u32_4); // 131703
¬†
    println!("{}", u64_1); // 1
    println!("{}", u64_2); // 1553255926290448384
    println!("{}", u64_3); // 9223372036854775808
    println!("{}", u64_4); // 0
¬†
```

Alternatively, Rust provides a number functions on primitive integer types that do take into account overflow by default. Unlike the above unsigned values, these also work in release mode.

There are three types of functions:

checked: Return the result or 'None' on overflow saturating: Return the result or 'MAX' for the specified type. wrapping: Return the result or the wrapped value.

```rust
¬†
    // The following will never panic!
    println!("{:?}", 65_537u32.checked_mul(65_537));    // None
    println!("{:?}", 65_537u32.saturating_mul(65_537)); // 4294967295
    println!("{:?}", 65_537u32.wrapping_mul(65_537));   // 131073
¬†
    // These will never panic! either
    println!("{:?}", 65_537i32.checked_mul(65_537));     // None
    println!("{:?}", 65_537i32.saturating_mul(65_537));  // 2147483647
    println!("{:?}", 65_537i32.wrapping_mul(-65_537));   // -131073
¬†
```

# Sequence of non-squares<a id="sec-252"></a>

Task

Show that the following remarkable formula gives the sequence of non-square natural numbers:

```
n + floor(1/2 + sqrt(n))

```

Print out the values for ¬† n ¬† in the range ¬† 1 ¬† to ¬† 22 Show that no squares occur for ¬† n ¬† less than one million

This sequence is also known as ¬† A000037 ¬† in the OEIS database.

Works with: Rust version 1.1

```rust
¬†
fn f(n: i64) -> i64 {
    n + (0.5 + (n as f64).sqrt()) as i64
}
¬†
fn is_sqr(n: i64) -> bool {
    let a = (n as f64).sqrt() as i64;
    n == a * a || n == (a+1) * (a+1) || n == (a-1) * (a-1) 
}
¬†
fn main() {
    println!( "{:?}", (1..23).map(|n| f(n)).collect::<Vec<i64>>() );
    let count = (1..1_000_000).map(|n| f(n)).filter(|&n| is_sqr(n)).count();
    println!("{} unexpected squares found", count);
}
¬†
```

# Singly-linked list/Element definition<a id="sec-253"></a>

singly-linked list

See also

Array Associative array: Creation, Iteration Collections Compound data type Doubly-linked list: Definition, Element definition, Element insertion, Traversal Linked list Queue: Definition, Usage Set Singly-linked list: Element definition, Element insertion, Traversal Stack

Rust's Option<T> type make the definition of a singly-linked list trivial. The use of Box<T> (an owned pointer) is necessary because it has a known size, thus making sure the struct that contains it can have a finite size.

```rust
 struct Node<T> {
    elem: T,
    next: Option<Box<Node<T>>>,
}
```

However, the above example would not be suitable for a library because, first and foremost, it is private by default but simply making it public would not allow for any encapsulation.

```rust
type Link<T> = Option<Box<Node<T>>>; // Type alias
pub struct List<T> { // User-facing interface for list
    head: Link<T>,
}
¬†
struct Node<T> { // Private implementation of Node
    elem: T,
    next: Link<T>,
}
¬†
impl<T> List<T> {
    #[inline]
    pub fn new() -> Self { // List constructor
        List { head: None }
    // Add other methods here
}
```

Then a separate program could utilize the basic implementation above like so:

```rust
extern crate LinkedList; // Name is arbitrary here
¬†
use LinkedList::List;
¬†
fn main() {
    let list = List::new();
    // Do stuff
}
```

# Emirp primes<a id="sec-254"></a>

An ¬† emirp ¬† (prime spelled backwards) ¬† are primes that when reversed ¬† (in their decimal representation) ¬† are a different prime.

(This rules out palindromic primes.)

Task ¬† show the first ¬† twenty ¬† emirps ¬† show all emirps between ¬† 7,700 ¬† and ¬† 8,000 ¬† show the ¬† 10,000th ¬† emirp

In each list, the numbers should be in order.

Invoke the (same) program once per task requirement, this will show what limit is used as the upper bound for calculating surplus (regular) primes.

The specific method of how to determine if a range or if specific values are to be shown will be left to the programmer.

See also

¬† Wikipedia, Emirp. ¬† The Prime Pages, emirp. ¬† Wolfram MathWorld‚Ñ¢, Emirp. ¬† The On‚ÄëLine Encyclopedia of Integer Sequences, emirps (A6567).

Category: Prime<sub>Numbers</sub>

```rust
#![feature(iterator_step_by)]
¬†
extern crate primal;
¬†
fn is_prime(n: u64) -> bool {
    if n == 2 || n == 3 || n == 5 || n == 7 || n == 11 || n == 13 { return true; }
    if n¬†% 2 == 0 || n¬†% 3 == 0 || n¬†% 5 == 0 || n¬†% 7 == 0 || n¬†% 11 == 0 || n¬†% 13 == 0 { return false; }
    let root = (n as f64).sqrt() as u64 + 1;
    (17..root).step_by(2).all(|i| n¬†% i¬†!= 0)
}
¬†
fn is_emirp(n: u64) -> bool {
    let mut aux = n;
    let mut rev_prime = 0;
    while aux > 0 {
        rev_prime = rev_prime * 10 + aux ¬†% 10;
        aux /= 10;
    }
    if n == rev_prime { return false; }
    is_prime(rev_prime)
}
¬†
fn calculate() -> (Vec<usize>, Vec<usize>, usize) {
    let mut count = 1;
    let mut vec1 = Vec::new();
    let mut vec2 = Vec::new();
    let mut emirp_10_000 = 0;
¬†
    for i in primal::Primes::all() {
        if is_emirp(i as u64) {
            if count < 21 { vec1.push(i) }
            if i > 7_700 && i < 8_000 { vec2.push(i) }
            if count == 10_000 {
                emirp_10_000 = i;
                break;
            }
            count += 1;
        }
    }
¬†
    (vec1, vec2, emirp_10_000)
}
¬†
fn main() {
    let (vec1, vec2, emirp_10_000) = calculate();
¬†
    println!("First 20 emirp-s¬†: {:?}", vec1);
    println!("Emirps-s between 7700 and 8000¬†: {:?}", vec2);
    println!("10.000-th emirp¬†: {}", emirp_10_000);
}
```

Output:

```rust
First 20 primes¬†: [13, 17, 31, 37, 71, 73, 79, 97, 107, 113, 149, 157, 167, 179, 199, 311, 337, 347, 359, 389]
Emirps-s between 7700 and 8000¬†: [7717, 7757, 7817, 7841, 7867, 7879, 7901, 7927, 7949, 7951, 7963]
10.000-th emirp¬†: 948349

real	0m0.040s
user	0m0.036s
sys	0m0.003s

```

# Vigen√®re cipher<a id="sec-255"></a>

Task

Implement a ¬† Vigen√®re cypher, ¬† both encryption and decryption.

The program should handle keys and text of unequal length, and should capitalize everything and discard non-alphabetic characters. (If your program handles non-alphabetic characters in another way, make a note of it.)

Related tasks

¬† Caesar cipher ¬† Rot-13 ¬† Substitution Cipher

```rust
use std::ascii::AsciiExt;
¬†
static A: u8 = 'A' as u8;
¬†
fn uppercase_and_filter(input: &str) -> Vec<u8> {
    let alphabet = b"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let mut result = Vec::new();
¬†
    for c in input.chars() {
        // Ignore anything that is not in our short list of chars. We can then safely cast to u8.
        if alphabet.iter().any(|&x| x as char == c) {
            result.push(c.to_ascii_uppercase() as u8);
        }
    }
¬†
    return result;
}
¬†
fn vigenere(key: &str, text: &str, is_encoding: bool) -> String {
¬†
    let key_bytes = uppercase_and_filter(key);
    let text_bytes = uppercase_and_filter(text);
¬†
    let mut result_bytes = Vec::new();
¬†
    for (i, c) in text_bytes.iter().enumerate() {
        let c2 = if is_encoding {
            (c + key_bytes[i¬†% key_bytes.len()] - 2 * A)¬†% 26 + A
        } else {
            (c + 26 - key_bytes[i¬†% key_bytes.len()])¬†% 26 + A
        };
        result_bytes.push(c2);
    }
¬†
    String::from_utf8(result_bytes).unwrap()
}
¬†
fn main() {
    let text = "Beware the Jabberwock, my son! The jaws that bite, the claws that catch!";
    let key = "VIGENERECIPHER";
¬†
    println!("Text: {}", text);
    println!("Key:  {}", key);
¬†
    let encoded = vigenere(key, text, true);
    println!("Code: {}", encoded);
    let decoded = vigenere(key, &encoded, false);
    println!("Back: {}", decoded);
}
```

# Fast Fourier transform<a id="sec-256"></a>

Task

Calculate the ¬† FFT ¬† (Fast Fourier Transform) ¬† of an input sequence.

The most general case allows for complex numbers at the input and results in a sequence of equal length, again of complex numbers. If you need to restrict yourself to real numbers, the output should be the magnitude (i.e. sqrt(re¬≤+im¬≤)) of the complex result.

The classic version is the recursive Cooley‚ÄìTukey FFT. Wikipedia has pseudo-code for that. Further optimizations are possible but not required.

Translation of: C

```rust
extern crate num;
use num::complex::Complex;
use std::f64::consts::PI;
¬†
const I: Complex<f64> = Complex { re: 0.0, im: 1.0 };
¬†
pub fn fft(input: &[Complex<f64>]) -> Vec<Complex<f64>> {
    fn fft_inner(
        buf_a: &mut [Complex<f64>],
        buf_b: &mut [Complex<f64>],
        n: usize,    // total length of the input array
        step: usize, // precalculated values for t
    ) {
        if step >= n {
            return;
        }
¬†
        fft_inner(buf_b, buf_a, n, step * 2);
        fft_inner(&mut buf_b[step..], &mut buf_a[step..], n, step * 2);
        // create a slice for each half of buf_a:
        let (left, right) = buf_a.split_at_mut(n / 2);
¬†
        for i in (0..n).step_by(step * 2) {
            let t = (-I * PI * (i as f64) / (n as f64)).exp() * buf_b[i + step];
            left[i / 2] = buf_b[i] + t;
            right[i / 2] = buf_b[i] - t;
        }
    }
¬†
    // round n (length) up to a power of 2:
    let n_orig = input.len();
    let n = n_orig.next_power_of_two();
    // copy the input into a buffer:
    let mut buf_a = input.to_vec();
    // right pad with zeros to a power of two:
    buf_a.append(&mut vec![Complex { re: 0.0, im: 0.0 }; n - n_orig]);
    // alternate between buf_a and buf_b to avoid allocating a new vector each time:
    let mut buf_b = buf_a.clone();
    fft_inner(&mut buf_a, &mut buf_b, n, 1);
    buf_a
}
¬†
fn show(label: &str, buf: &[Complex<f64>]) {
    println!("{}", label);
    let string = buf
        .into_iter()
        .map(|x| format!("{:.4}{:+.4}i", x.re, x.im))
        .collect::<Vec<_>>()
        .join(", ");
    println!("{}", string);
}
¬†
fn main() {
    let input: Vec<_> = [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]
        .into_iter()
        .map(|x| Complex::from(x))
        .collect();
    show("input:", &input);
    let output = fft(&input);
    show("output:", &output);
}
```

Output:

```rust
input:
1.0000+0.0000i, 1.0000+0.0000i, 1.0000+0.0000i, 1.0000+0.0000i, 0.0000+0.0000i, 0.0000+0.0000i, 0.0000+0.0000i, 0.0000+0.0000i
output:
4.0000+0.0000i, 1.0000-2.4142i, 0.0000+0.0000i, 1.0000-0.4142i, 0.0000+0.0000i, 1.0000+0.4142i, 0.0000+0.0000i, 1.0000+2.4142i

```

# Compare a list of strings<a id="sec-257"></a>

Task

Given a ¬† list ¬† of arbitrarily many strings, show how to:

¬† test if they are all lexically equal ¬† test if every string is lexically less than the one after it (i.e. whether the list is in strict ascending order)

Each of those two tests should result in a single true or false value, which could be used as the condition of an ¬† if ¬† statement or similar.

If the input list has less than two elements, the tests should always return true.

There is no need to provide a complete program and output.

Assume that the strings are already stored in an array/list/sequence/tuple variable (whatever is most idiomatic) with the name ¬† strings, ¬† and just show the expressions for performing those two tests on it (plus of course any includes and custom functions etc. that it needs), ¬† with as little distractions as possible.

Try to write your solution in a way that does not modify the original list, ¬† but if it does then please add a note to make that clear to readers.

If you need further guidance/clarification, ¬† see #Perl and #Python for solutions that use implicit short-circuiting loops, ¬† and #Perl<sub>6</sub> for a solution that gets away with simply using a built-in language feature.

Related tasks

¬† String comparison

```rust
// Note that this solution uses the feature 'slice_patterns' which is available Rust nightly!
#![feature(slice_patterns)]
¬†
fn strings_are_equal(seq: &[&str]) -> bool {
    match seq {
        &[] | &[_] => true,
        &[x, y, ref tail..] if x == y => strings_are_equal(&[&[y], tail].concat()),
        _ => false
    }
}
¬†
fn asc_strings(seq: &[&str]) -> bool {
    match seq {
        &[] | &[_] => true,
        &[x, y, ref tail..] if x < y => asc_strings(&[&[y], tail].concat()),
        _ => false
    }
}
```

# CRC-32<a id="sec-258"></a>

Task

Demonstrate a method of deriving the Cyclic Redundancy Check from within the language.

The result should be in accordance with ISO 3309, ITU-T V.42, Gzip and PNG.

Algorithms are described on Computation of CRC in Wikipedia. This variant of CRC-32 uses LSB-first order, sets the initial CRC to FFFFFFFF16, and complements the final CRC.

For the purpose of this task, generate a CRC-32 checksum for the ASCII encoded string:

The quick brown fox jumps over the lazy dog

This does not perform any caching of the lookup table for simplicity.

```rust
¬†
fn crc32_compute_table() -> [u32; 256] {
    let mut crc32_table = [0; 256];
¬†
    for n in 0..256 {
        crc32_table[n as usize] = (0..8).fold(n as u32, |acc, _| {
            match acc & 1 {
                1 => 0xedb88320 ^ (acc >> 1),
                _ => acc >> 1,
            }
        });
    }
¬†
    crc32_table
}
¬†
fn crc32(buf: &str) -> u32 {
    let crc_table = crc32_compute_table();
¬†
   ¬†!buf.bytes().fold(!0, |acc, octet| {
        (acc >> 8) ^ crc_table[((acc & 0xff) ^ octet as u32) as usize]
    })
}
¬†
fn main() {
    println!("{:x}", crc32("The quick brown fox jumps over the lazy dog"));
}
¬†
```

Output:

```rust
414fa339

```

# Currying<a id="sec-259"></a>

This page uses content from Wikipedia. The original article was at Currying. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Task

Create a simple demonstrative example of Currying in a specific language.

Add any historic details as to how the feature made its way into the language.

This is a simple currying function written in Rust:

```rust
fn add_n(n¬†: i32) -> impl Fn(i32) -> i32 {
    move |x| n + x
}
¬†
fn main() {
    let adder = add_n(40);
    println!("The answer to life is {}.", adder(2));
}
```

# Pick random element<a id="sec-260"></a>

Demonstrate how to pick a random element from a list.

Library: rand

```rust
extern crate rand;
¬†
use rand::Rng;
¬†
fn main() {
    let array = [5,1,2,5,6,7,8,1,2,4,5];
    let mut rng = rand::thread_rng();
¬†
    println!("{}", rng.choose(&array).unwrap());
}
```

# Extreme floating point values<a id="sec-261"></a>

The IEEE floating point specification defines certain 'extreme' floating point values such as minus zero, -0.0, a value distinct from plus zero; not a number, NaN; and plus and minus infinity.

The task is to use expressions involving other 'normal' floating point values in your language to calculate these, (and maybe other), extreme floating point values in your language and assign them to variables.

Print the values of these variables if possible; and show some arithmetic with these values and variables.

If your language can directly enter these extreme floating point values then show it.

See also

¬† What Every Computer Scientist Should Know About Floating-Point Arithmetic

Related tasks

¬† Infinity ¬† Detect division by zero ¬† Literals/Floating point

Negative zero needs to printed using the Debug trait (rather than the "user-facing" Display trait) because 0 == -0 to most users. See <https://github.com/rust-lang/rfcs/issues/1074> and <https://github.com/rust-lang/rust/issues/24623> for further discussion about this.

```rust
fn main() {
    let inf: f64 = 1. / 0.;          // or std::f64::INFINITY
    let minus_inf: f64 = -1. / 0.;   // or std::f64::NEG_INFINITY
    let minus_zero: f64 = -1. / inf; // or -0.0
    let nan: f64 = 0. / 0.;          // or std::f64::NAN
                                     // or std::f32 for the above
    println!("positive infinity: {:+}", inf);
    println!("negative infinity: {:+}", minus_inf);
    println!("negative zero: {:+?}", minus_zero);
    println!("not a number: {:+}", nan);
    println!();
    println!("+inf + 2.0 = {:+}", inf + 2.);
    println!("+inf - 10.0 = {:+}", inf - 10.);
    println!("+inf + -inf = {:+}", inf + minus_inf);
    println!("0.0 * inf = {:+}", 0. * inf);
    println!("1.0 / -0.0 = {:+}", 1. / -0.);
    println!("NaN + 1.0 = {:+}", nan + 1.);
    println!("NaN + NaN = {:+}", nan + nan);
    println!();
    println!("NaN == NaN = {}", nan == nan);
    println!("0.0 == -0.0 = {}", 0. == -0.);
}
```

Output:

```rust
positive infinity: +inf
negative infinity: -inf
negative zero: -0
not a number: NaN

+inf + 2.0 = +inf
+inf - 10.0 = +inf
+inf + -inf = NaN
0.0 * inf = NaN
1.0 / -0.0 = -inf
NaN + 1.0 = NaN
NaN + NaN = NaN

NaN == NaN = false
0.0 == -0.0 = true

```

# Self-describing numbers<a id="sec-262"></a>

There are several so-called "self-describing" or "self-descriptive" integers.

An integer is said to be "self-describing" if it has the property that, when digit positions are labeled 0 to N-1, the digit in each position is equal to the number of times that that digit appears in the number.

For example, ¬† 2020 ¬† is a four-digit self describing number:

¬† position ¬† 0 ¬† has value ¬† 2 ¬† and there are two 0s in the number; ¬† position ¬† 1 ¬† has value ¬† 0 ¬† and there are no 1s in the number; ¬† position ¬† 2 ¬† has value ¬† 2 ¬† and there are two 2s; ¬† position ¬† 3 ¬† has value ¬† 0 ¬† and there are zero 3s.

Self-describing numbers < 100.000.000¬† are: ¬† ¬† 1210, ¬† 2020, ¬† 21200, ¬† 3211000, ¬† 42101000.

Task Description

Write a function/routine/method/&#x2026; that will check whether a given positive integer is self-describing. As an optional stretch goal - generate and display the set of self-describing numbers.

Related tasks

¬† Fours is the number of letters in the &#x2026; ¬† Look-and-say sequence ¬† Number names ¬† Self-referential sequence ¬† Spelling of ordinal numbers

```rust
¬†
fn is_self_desc(xx: u64) -> bool
{
    let s: String = xx.to_string();
    let mut count_vec = vec![0; 10];
    for c in s.chars() {
        count_vec[c.to_digit(10).unwrap() as usize] += 1;
    }
    for (i, c) in s.chars().enumerate() {
        if count_vec[i]¬†!= c.to_digit(10).unwrap() as usize {
            return false;
        }
    }
    return true;
}
¬†
fn main() {
    for i in 1..100000000 {
        if is_self_desc(i) {
            println!("{}", i)
        }
    }
}
¬†
```

# Convert seconds to compound duration<a id="sec-263"></a>

Task

Write a function or program which:

takes a positive integer representing a duration in seconds as input (e.g., 100), and returns a string which shows the same duration decomposed into weeks, days, hours, minutes, and seconds as detailed below (e.g., "1 min, 40 sec").

Demonstrate that it passes the following three test-cases:

Test Cases

input number output string 7259 2 hr, 59 sec 86400 1 d 6000000 9 wk, 6 d, 10 hr, 40 min

Details

The following five units should be used: unit suffix used in output conversion week wk 1 week = 7 days day d 1 day = 24 hours hour hr 1 hour = 60 minutes minute min 1 minutes = 60 seconds second sec However, only include quantities with non-zero values in the output (e.g., return "1 d" and not "0 wk, 1 d, 0 hr, 0 min, 0 sec"). Give larger units precedence over smaller ones as much as possible (e.g., return 2 min, 10 sec and not 1 min, 70 sec or 130 sec) Mimic the formatting shown in the test-cases (quantities sorted from largest unit to smallest and separated by comma+space; value and unit of each quantity separated by space).

This solution deviates from the prompt a bit in order to make it more general. The benefit of doing it this way is that any values can be filled in for days, hours, minutes and seconds and the \`balance\` method will do the balancing accordingly. Also, rather than converting the value into a String, it simply implements the \`Display\` trait.

```rust
use std::fmt;
¬†
¬†
struct CompoundTime {
    w: usize,
    d: usize,
    h: usize,
    m: usize,
    s: usize,
}
¬†
macro_rules! reduce {
    ($s: ident, $(($from: ident, $to: ident, $factor: expr)),+) => {{
        $(
            $s.$to += $s.$from / $factor;
            $s.$from¬†%= $factor;
        )+
    }}
}
¬†
impl CompoundTime {
    #[inline]
    fn new(w: usize, d: usize, h: usize, m: usize, s: usize) -> Self{
        CompoundTime { w: w, d: d, h: h, m: m, s: s, }
    }
¬†
    #[inline]
    fn balance(&mut self) {
        reduce!(self, (s, m, 60), (m, h, 60),
                      (h, d, 24), (d, w, 7));
    }
}
¬†
impl fmt::Display for CompoundTime {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}w {}d {}h {}m {}s", 
               self.w, self.d, self.h, self.m, self.s)
    }
}
¬†
fn main() {
    let mut ct = CompoundTime::new(0,3,182,345,2412);
    println!("Before: {}", ct);
    ct.balance();
    println!("After: {}", ct);
}
```

# Huffman coding<a id="sec-264"></a>

Huffman encoding is a way to assign binary codes to symbols that reduces the overall number of bits used to encode a typical string of those symbols.

For example, if you use letters as symbols and have details of the frequency of occurrence of those letters in typical strings, then you could just encode each letter with a fixed number of bits, such as in ASCII codes. You can do better than this by encoding more frequently occurring letters such as e and a, with smaller bit strings; and less frequently occurring letters such as q and x with longer bit strings.

Any string of letters will be encoded as a string of bits that are no-longer of the same length per letter. To successfully decode such as string, the smaller codes assigned to letters such as 'e' cannot occur as a prefix in the larger codes such as that for 'x'.

If you were to assign a code 01 for 'e' and code 011 for 'x', then if the bits to decode started as 011&#x2026; then you would not know if you should decode an 'e' or an 'x'.

The Huffman coding scheme takes each symbol and its weight (or frequency of occurrence), and generates proper encodings for each symbol taking account of the weights of each symbol, so that higher weighted symbols have fewer bits in their encoding. (See the WP article for more information).

A Huffman encoding can be computed by first creating a tree of nodes:

Create a leaf node for each symbol and add it to the priority queue. While there is more than one node in the queue: Remove the node of highest priority (lowest probability) twice to get two nodes. Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities. Add the new node to the queue. The remaining node is the root node and the tree is complete.

Traverse the constructed binary tree from root to leaves assigning and accumulating a '0' for one branch and a '1' for the other at each node. The accumulated zeros and ones at each leaf constitute a Huffman encoding for those symbols and weights:

Task

Using the characters and their frequency from the string:

¬† this is an example for huffman encoding

create a program to generate a Huffman encoding for each character as a table.

Adapted C++ solution.

```rust
¬†
use std::collections::BTreeMap;
use std::collections::binary_heap::BinaryHeap;
¬†
#[derive(Debug, Eq, PartialEq)]
enum NodeKind {
    Internal(Box<Node>, Box<Node>),
    Leaf(char),
}
¬†
#[derive(Debug, Eq, PartialEq)]
struct Node {
    frequency: usize,
    kind: NodeKind,
}
¬†
impl Ord for Node {
    fn cmp(&self, rhs: &Self) -> std::cmp::Ordering {
        rhs.frequency.cmp(&self.frequency)
    }
}
¬†
impl PartialOrd for Node {
    fn partial_cmp(&self, rhs: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(&rhs))
    }
}
¬†
type HuffmanCodeMap = BTreeMap<char, Vec<u8>>;
¬†
fn main() {
    let text = "this is an example for huffman encoding";
¬†
    let mut frequencies = BTreeMap::new();
    for ch in text.chars() {
        *frequencies.entry(ch).or_insert(0) += 1;
    }
¬†
    let mut prioritized_frequencies = BinaryHeap::new();
    for counted_char in frequencies {
        prioritized_frequencies.push(Node {
            frequency: counted_char.1,
            kind: NodeKind::Leaf(counted_char.0),
        });
    }
¬†
    while prioritized_frequencies.len() > 1 {
        let left_child = prioritized_frequencies.pop().unwrap();
        let right_child = prioritized_frequencies.pop().unwrap();
        prioritized_frequencies.push(Node {
            frequency: right_child.frequency + left_child.frequency,
            kind: NodeKind::Internal(Box::new(left_child), Box::new(right_child)),
        });
    }
¬†
    let mut codes = HuffmanCodeMap::new();
    generate_codes(
        prioritized_frequencies.peek().unwrap(),
        vec![0u8; 0],
        &mut codes,
    );
¬†
    for item in codes {
        print!("{}: ", item.0);
        for bit in item.1 {
            print!("{}", bit);
        }
        println!();
    }
}
¬†
fn generate_codes(node: &Node, prefix: Vec<u8>, out_codes: &mut HuffmanCodeMap) {
    match node.kind {
        NodeKind::Internal(ref left_child, ref right_child) => {
            let mut left_prefix = prefix.clone();
            left_prefix.push(0);
            generate_codes(&left_child, left_prefix, out_codes);
¬†
            let mut right_prefix = prefix;
            right_prefix.push(1);
            generate_codes(&right_child, right_prefix, out_codes);
        }
        NodeKind::Leaf(ch) => {
            out_codes.insert(ch, prefix);
        }
    }
}
¬†
```

Output:

```rust
 : 110
a: 1001
c: 101010
d: 10001
e: 1111
f: 1011
g: 101011
h: 0101
i: 1110
l: 01110
m: 0011
n: 000
o: 0010
p: 01000
r: 01001
s: 0110
t: 01111
u: 10100
x: 10000

```

# Knight's tour<a id="sec-265"></a>

Task

Problem: you have a standard 8x8 chessboard, empty but for a single knight on some square. Your task is to emit a series of legal knight moves that result in the knight visiting every square on the chessboard exactly once. Note that it is not a requirement that the tour be "closed"; that is, the knight need not end within a single move of its start position.

Input and output may be textual or graphical, according to the conventions of the programming environment. If textual, squares should be indicated in algebraic notation. The output should indicate the order in which the knight visits the squares, starting with the initial position. The form of the output may be a diagram of the board with the squares numbered according to visitation sequence, or a textual list of algebraic coordinates in order, or even an actual animation of the knight moving around the chessboard.

Input: starting square

Output: move sequence

Related tasks

A\* search algorithm N-queens problem Solve a Hidato puzzle Solve a Holy Knight's tour Solve a Hopido puzzle Solve a Numbrix puzzle Solve the no connection puzzle

```rust
¬†
use std::fmt;
¬†
const SIZE: usize = 8;
const MOVES: [(i32, i32); 8]  = [(2,1), (1,2), (-1,2), (-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1)];
¬†
#[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord)]
struct Point {
    x: i32,
    y: i32
}
¬†
impl Point {
    fn mov(&self, &(dx,dy): &(i32, i32)) -> Point {
        Point {
            x: self.x + dx,
            y: self.y + dy
        }
    }
}
¬†
struct Board {
    field: [[i32;SIZE];SIZE]
}
¬†
impl Board {
¬†
    fn new() -> Board {
        return Board {
            field: [[0; SIZE]; SIZE]
        };
    }
¬†
    fn available(&self, p: Point) -> bool {
        let valid = 0 <= p.x && p.x < SIZE as i32
                 && 0 <= p.y && p.y < SIZE as i32;
        return valid  && self.field[p.x as usize][p.y as usize] == 0;
    }
¬†
    // calculate the number of possible moves
    fn count_degree(&self, p: Point) -> i32 {
        let mut count = 0;
        for dir in MOVES.iter() {
            let next = p.mov(dir);
            if self.available(next) {
                count += 1;
            }
        }
        return count;
    }
}
¬†
impl fmt::Display for Board {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for row in self.field.iter() {
            for x in row.iter(){
                try!(write!(f, "{:3} ", x));
            }
            try!(write!(f, "\n"));
        }
        Ok(())
    }
}
¬†
fn knights_tour(x: i32, y: i32) -> Option<Board> {
    let mut board = Board::new();
    let mut p = Point {x: x, y: y};
    let mut step = 1;
    board.field[p.x as usize][p.y as usize] = step;
    step += 1;
¬†
    while step <= (SIZE * SIZE) as i32 {
        // choose next square by Warnsdorf's rule
        let mut candidates = vec![];
        for dir in MOVES.iter() {
            let adj = p.mov(dir);
            if board.available(adj) {
                let degree = board.count_degree(adj);
                candidates.push((degree, adj));
            }
        }
        match candidates.iter().min() {
            Some(&(_, adj)) => // move to next square
                p = adj,
            None =>            // can't move
                return None
        };
        board.field[p.x as usize][p.y as usize] = step;
        step += 1;
    }
    return Some(board);
}
¬†
fn main() {
    let (x, y) = (3, 1);
    println!("Board size: {}", SIZE);
    println!("Starting position: ({}, {})", x, y);
    match knights_tour(x, y) {
        Some(b) =>
            print!("{}", b),
        None =>
            println!("Fail!")
    }
}
¬†
¬†
```

Output:

```rust
Board size: 8
Starting position: (3, 1)
 23  20   3  32  25  10   5   8 
  2  33  24  21   4   7  26  11 
 19  22  51  34  31  28   9   6 
 50   1  40  29  54  35  12  27 
 41  18  55  52  61  30  57  36 
 46  49  44  39  56  53  62  13 
 17  42  47  60  15  64  37  58 
 48  45  16  43  38  59  14  63 

```

# Sorting algorithms/Heapsort<a id="sec-266"></a>

This page uses content from Wikipedia. The original article was at Heapsort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Heapsort is an in-place sorting algorithm with worst case and average complexity of ¬† O(n‚Äälogn).

The basic idea is to turn the array into a binary heap structure, which has the property that it allows efficient retrieval and removal of the maximal element.

We repeatedly "remove" the maximal element from the heap, thus building the sorted list from back to front.

Heapsort requires random access, so can only be used on an array-like data structure.

Pseudocode:

```
function heapSort(a, count) is
   input: an unordered array a of length count

   (first place a in max-heap order)
   heapify(a, count)

   end¬†:= count - 1
   while end > 0 do
      (swap the root(maximum value) of the heap with the
       last element of the heap)
      swap(a[end], a[0])
      (decrement the size of the heap so that the previous
       max value will stay in its proper place)
      end¬†:= end - 1
      (put the heap back in max-heap order)
      siftDown(a, 0, end)

```

```
function heapify(a,count) is
   (start is assigned the index in a of the last parent node)
   start¬†:= (count - 2) / 2

   while start ‚â• 0 do
      (sift down the node at index start to the proper place
       such that all nodes below the start index are in heap
       order)
      siftDown(a, start, count-1)
      start¬†:= start - 1
   (after sifting down the root all nodes/elements are in heap order)

function siftDown(a, start, end) is
   (end represents the limit of how far down the heap to sift)
   root¬†:= start

   while root * 2 + 1 ‚â§ end do       (While the root has at least one child)
      child¬†:= root * 2 + 1           (root*2+1 points to the left child)
      (If the child has a sibling and the child's value is less than its sibling's...)
      if child + 1 ‚â§ end and a[child] < a[child + 1] then
         child¬†:= child + 1           (... then point to the right child instead)
      if a[root] < a[child] then     (out of max-heap order)
         swap(a[root], a[child])
         root¬†:= child                (repeat to continue sifting down the child now)
      else
         return

```

Write a function to sort a collection of integers using heapsort.

Translation of: Python

This program allows the caller to specify an arbitrary function by which an order is determined.

```rust
fn main() {
    let mut v = [4, 6, 8, 1, 0, 3, 2, 2, 9, 5];
    heap_sort(&mut v, |x, y| x < y);
    println!("{:?}", v);
}
¬†
fn heap_sort<T, F>(array: &mut [T], order: F)
where
    F: Fn(&T, &T) -> bool,
{
    let len = array.len();
    // Create heap
    for start in (0..len / 2).rev() {
        shift_down(array, &order, start, len - 1)
    }
¬†
    for end in (1..len).rev() {
        array.swap(0, end);
        shift_down(array, &order, 0, end - 1)
    }
}
¬†
fn shift_down<T, F>(array: &mut [T], order: &F, start: usize, end: usize)
where
    F: Fn(&T, &T) -> bool,
{
    let mut root = start;
    loop {
        let mut child = root * 2 + 1;
        if child > end {
            break;
        }
        if child + 1 <= end && order(&array[child], &array[child + 1]) {
            child += 1;
        }
        if order(&array[root], &array[child]) {
            array.swap(root, child);
            root = child
        } else {
            break;
        }
    }
}
```

Of course, you could also simply use BinaryHeap in the standard library.

```rust
use std::collections::BinaryHeap;
¬†
fn main() {
    let src = vec![6, 2, 3, 6, 1, 2, 7, 8, 3, 2];
    let sorted = BinaryHeap::from(src).into_sorted_vec();
    println!("{:?}", sorted);
}
```

# Concurrent computing<a id="sec-267"></a>

Task

Using either native language concurrency syntax or freely available libraries, write a program to display the strings "Enjoy" "Rosetta" "Code", one string per line, in random order.

Concurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.

Library: rand

```rust
extern crate rand;
use std::thread;
use rand::thread_rng;
use rand::distributions::{Range, IndependentSample};
¬†
fn main() {
    let mut rng = thread_rng();
    let rng_range = Range::new(0u32, 100);
    for word in "Enjoy Rosetta Code".split_whitespace() {
        let snooze_time = rng_range.ind_sample(&mut rng);
        let local_word = word.to_owned();
        std::thread::spawn(move || {
            thread::sleep_ms(snooze_time);
            println!("{}", local_word);
        });
    }
    thread::sleep_ms(1000);
}
```

# Walk a directory/Non-recursively<a id="sec-268"></a>

Task

Walk a given directory and print the names of files matching a given pattern.

(How is "pattern" defined? substring match? DOS pattern? BASH pattern? ZSH pattern? Perl regular expression?)

Note: This task is for non-recursive methods. ¬† These tasks should read a single directory, not an entire directory tree.

Note: Please be careful when running any code presented here.

Related task

¬† Walk Directory Tree ¬† (read entire directory tree).

```rust
extern crate docopt;
extern crate regex;
extern crate rustc_serialize;
¬†
use docopt::Docopt;
use regex::Regex;
¬†
const USAGE: &'static str = "
Usage: rosetta <pattern>
¬†
Walks the directory tree starting with the current working directory and
print filenames matching <pattern>.
";
¬†
#[derive(Debug, RustcDecodable)]
struct Args {
    arg_pattern: String,
}
¬†
fn main() {
    let args: Args = Docopt::new(USAGE)
        .and_then(|d| d.decode())
        .unwrap_or_else(|e| e.exit());
¬†
    let re = Regex::new(&args.arg_pattern).unwrap();
    let paths = std::fs::read_dir(".").unwrap();
¬†
    for path in paths {
        let path = path.unwrap().path();
        let path = path.to_str().unwrap();
¬†
        if re.is_match(path) {
            println!("{}", path);
        }
    }
}
```

# Longest increasing subsequence<a id="sec-269"></a>

Calculate and show here a longest increasing subsequence of the list:

{\displaystyle \\{3,2,6,4,5,1\\}}

And of the list:

{\displaystyle \\{0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15\\}}

Note that a list may have more than one subsequence that is of the maximum length.

Ref

Dynamic Programming #1: Longest Increasing Subsequence on Youtube An efficient solution can be based on Patience sorting.

```rust
fn lower_bound<T: PartialOrd>(list: &Vec<T>, value: &T) -> usize {
    if list.is_empty() {
        return 0;
    }
    let mut lower = 0usize;
    let mut upper = list.len();
    while lower¬†!= upper {
        let middle = lower + upper >> 1;
        if list[middle] < *value {
            lower = middle + 1;
        } else {
            upper = middle;
        }
    }
    return lower;
}
¬†
fn lis<T: PartialOrd + Copy>(list: &Vec<T>) -> Vec<T> {
    if list.is_empty() {
        return Vec::new();
    }
    let mut subseq: Vec<T> = Vec::new();
    subseq.push(*list.first().unwrap());
    for i in list[1..].iter() {
        if *i <= *subseq.last().unwrap() {
            let index = lower_bound(&subseq, i);
            subseq[index] = *i;
        } else {
            subseq.push(*i);
        }
    }
    return subseq;
}
¬†
fn main() {
    let list = vec![3, 2, 6, 4, 5, 1];
    println!("{:?}", lis(&list));
    let list = vec![0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];
    println!("{:?}", lis(&list));
}
```

Output:

```rust
[1, 4, 5]
[0, 1, 3, 7, 11, 15]
```

# 9 billion names of God the integer<a id="sec-270"></a>

This task is a variation of the short story by Arthur C. Clarke.

(Solvers should be aware of the consequences of completing this task.)

In detail, to specify what is meant by a ¬† ‚Äúname‚Äù:

The integer 1 has 1 name ¬† ¬† ‚Äú1‚Äù. The integer 2 has 2 names ¬† ‚Äú1+1‚Äù, ¬† and ¬† ‚Äú2‚Äù. The integer 3 has 3 names ¬† ‚Äú1+1+1‚Äù, ¬† ‚Äú2+1‚Äù, ¬† and ¬† ‚Äú3‚Äù. The integer 4 has 5 names ¬† ‚Äú1+1+1+1‚Äù, ¬† ‚Äú2+1+1‚Äù, ¬† ‚Äú2+2‚Äù, ¬† ‚Äú3+1‚Äù, ¬† ‚Äú4‚Äù. The integer 5 has 7 names ¬† ‚Äú1+1+1+1+1‚Äù, ¬† ‚Äú2+1+1+1‚Äù, ¬† ‚Äú2+2+1‚Äù, ¬† ‚Äú3+1+1‚Äù, ¬† ‚Äú3+2‚Äù, ¬† ‚Äú4+1‚Äù, ¬† ‚Äú5‚Äù.

Task

Display the first 25 rows of a number triangle which begins:

```
          1
        1   1
      1   1   1 
    1   2   1   1
  1   2   2   1   1
1   3   3   2   1   1

```

Where row ¬† {\displaystyle n} ¬† corresponds to integer ¬† {\displaystyle n} , ¬† and each column ¬† {\displaystyle C} ¬† in row ¬† {\displaystyle m} ¬† from left to right corresponds to the number of names beginning with ¬† {\displaystyle C} .

A function ¬† {\displaystyle G(n)} ¬† should return the sum of the ¬† {\displaystyle n} -th ¬† row.

Demonstrate this function by displaying: ¬† {\displaystyle G(23)} , ¬† {\displaystyle G(123)} , ¬† {\displaystyle G(1234)} , ¬† and ¬† {\displaystyle G(12345)} .

Optionally note that the sum of the ¬† {\displaystyle n} -th ¬† row ¬† {\displaystyle P(n)} ¬† is the ¬† ¬† integer partition function.

Demonstrate this is equivalent to ¬† {\displaystyle G(n)} ¬† by displaying: ¬† {\displaystyle P(23)} , ¬† {\displaystyle P(123)} , ¬† {\displaystyle P(1234)} , ¬† and ¬† {\displaystyle P(12345)} .

Extra credit

If your environment is able, plot ¬† {\displaystyle P(n)} ¬† against ¬† {\displaystyle n} ¬† for ¬† {\displaystyle n=1\ldots 999} .

Translation of: Python

```rust
extern crate num;
¬†
use std::cmp;
use num::bigint::BigUint;
¬†
fn cumu(n: usize, cache: &mut Vec<Vec<BigUint>>) {
    for l in cache.len()..n+1 {
        let mut r = vec![BigUint::from(0u32)];
        for x in 1..l+1 {
            let prev = r[r.len() - 1].clone();
            r.push(prev + cache[l-x][cmp::min(x, l-x)].clone());
        }
        cache.push(r);
    }
}
¬†
fn row(n: usize, cache: &mut Vec<Vec<BigUint>>) -> Vec<BigUint> {
    cumu(n, cache);
    let r = &cache[n];
    let mut v: Vec<BigUint> = Vec::new();
¬†
    for i in 0..n {
        v.push(&r[i+1] - &r[i]);
    }
    v
}
¬†
fn main() {
    let mut cache = vec![vec![BigUint::from(1u32)]];
¬†
    println!("rows:");
    for x in 1..26 {
        let v: Vec<String> = row(x, &mut cache).iter().map(|e| e.to_string()).collect();
        let s: String = v.join(" ");
        println!("{}: {}", x, s);
    }
¬†
    println!("sums:");
    for x in vec![23, 123, 1234, 12345] {
        cumu(x, &mut cache);
        let v = &cache[x];
        let s = v[v.len() - 1].to_string();
        println!("{}: {}", x, s);
    }
}
```

Output:

```rust
rows:
1: 1
2: 1 1
3: 1 1 1
4: 1 2 1 1
5: 1 2 2 1 1
6: 1 3 3 2 1 1
7: 1 3 4 3 2 1 1
8: 1 4 5 5 3 2 1 1
9: 1 4 7 6 5 3 2 1 1
10: 1 5 8 9 7 5 3 2 1 1
11: 1 5 10 11 10 7 5 3 2 1 1
12: 1 6 12 15 13 11 7 5 3 2 1 1
13: 1 6 14 18 18 14 11 7 5 3 2 1 1
14: 1 7 16 23 23 20 15 11 7 5 3 2 1 1
15: 1 7 19 27 30 26 21 15 11 7 5 3 2 1 1
16: 1 8 21 34 37 35 28 22 15 11 7 5 3 2 1 1
17: 1 8 24 39 47 44 38 29 22 15 11 7 5 3 2 1 1
18: 1 9 27 47 57 58 49 40 30 22 15 11 7 5 3 2 1 1
19: 1 9 30 54 70 71 65 52 41 30 22 15 11 7 5 3 2 1 1
20: 1 10 33 64 84 90 82 70 54 42 30 22 15 11 7 5 3 2 1 1
21: 1 10 37 72 101 110 105 89 73 55 42 30 22 15 11 7 5 3 2 1 1
22: 1 11 40 84 119 136 131 116 94 75 56 42 30 22 15 11 7 5 3 2 1 1
23: 1 11 44 94 141 163 164 146 123 97 76 56 42 30 22 15 11 7 5 3 2 1 1
24: 1 12 48 108 164 199 201 186 157 128 99 77 56 42 30 22 15 11 7 5 3 2 1 1
25: 1 12 52 120 192 235 248 230 201 164 131 100 77 56 42 30 22 15 11 7 5 3 2 1 1
sums:
23: 1255
123: 2552338241
1234: 156978797223733228787865722354959930
12345: 69420357953926116819562977205209384460667673094671463620270321700806074195845953959951425306140971942519870679768681736

```

# Modular inverse<a id="sec-271"></a>

From Wikipedia:

In modular arithmetic, ¬† the modular multiplicative inverse of an integer ¬† a ¬† modulo ¬† m ¬† is an integer ¬† x ¬† such that

{\displaystyle a\\,x&equiv; 1{\pmod {m}}.}

Or in other words, such that:

{\displaystyle &exist; k&isin; \mathbb {Z} ,\qquad a\\,x=1+k\\,m}

It can be shown that such an inverse exists ¬† if and only if ¬† a ¬† and ¬† m ¬† are coprime, ¬† but we will ignore this for this task.

Task

Either by implementing the algorithm, by using a dedicated library or by using a built-in function in your language, ¬† compute the modular inverse of ¬† 42 modulo 2017.

```rust
fn mod_inv(a: isize, module: isize) -> isize {
  let mut mn = (module, a);
  let mut xy = (0, 1);
¬†
  while mn.1¬†!= 0 {
    xy = (xy.1, xy.0 - (mn.0 / mn.1) * xy.1);
    mn = (mn.1, mn.0¬†% mn.1);
  }
¬†
  while xy.0 < 0 {
    xy.0 += module;
  }
  xy.0
}
¬†
fn main() {
  println!("{}", mod_inv(42, 2017))
}
```

Output:

```rust
1969

```

# Enforced immutability<a id="sec-272"></a>

Task

Demonstrate any means your language has to prevent the modification of values, or to create objects that cannot be modified after they have been created.

Rust let bindings are immutable by default. This will raise a compiler error:

```rust
let x = 3;
x += 2;
```

You must declare a variable mutable explicitly:

```rust
let mut x = 3;
```

Similarly, references are immutable by default e.g.

```rust
let mut x = 4;
let y = &x;
*y += 2 // Raises compiler error. Even though x is mutable, y is an immutable reference.
let y = &mut x; 
*y += 2// Works
// Note that though y is now a mutable reference, y itself is still immutable e.g.
let mut z = 5;
let y = &mut z; // Raises compiler error because y is already assigned to '&mut x'
```

# Rename a file<a id="sec-273"></a>

Task

Rename:

¬† a file called ¬† ¬† input.txt ¬† ¬† into ¬† ¬† output.txt ¬† ¬† and ¬† a directory called ¬† ¬† docs ¬† ¬† into ¬† ¬† mydocs.

This should be done twice: ¬† once "here", i.e. in the current working directory and once in the filesystem root.

It can be assumed that the user has the rights to do so.

(In unix-type systems, only the user root would have sufficient permissions in the filesystem root.)

```rust
¬†
use std::fs;
¬†
fn main() {
    let err = "File move error";
    fs::rename("input.txt", "output.txt").ok().expect(err);
    fs::rename("docs", "mydocs").ok().expect(err);
    fs::rename("/input.txt", "/output.txt").ok().expect(err);
    fs::rename("/docs", "/mydocs").ok().expect(err);
}
¬†
```

# Extensible prime generator<a id="sec-274"></a>

Task

Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.

The routine should demonstrably rely on either:

Being based on an open-ended counter set to count without upper limit other than system or programming language limits. In this case, explain where this counter is in the code. Being based on a limit that is extended automatically. In this case, choose a small limit that ensures the limit will be passed when generating some of the values to be asked for below. If other methods of creating an extensible prime generator are used, the algorithm's means of extensibility/lack of limits should be stated.

The routine should be used to:

Show the first twenty primes. Show the primes between 100 and 150. Show the number of primes between 7,700 and 8,000. Show the 10,000th prime.

Show output on this page.

Note: You may reference code already on this site if it is written to be imported/included, then only the code necessary for import and the performance of this task need be shown. (It is also important to leave a forward link on the referenced tasks entry so that later editors know that the code is used for multiple tasks).

Note 2: If a languages in-built prime generator is extensible or is guaranteed to generate primes up to a system limit, (231 or memory overflow for example), then this may be used as long as an explanation of the limits of the prime generator is also given. (Which may include a link to/excerpt from, language documentation).

Related task

The task is written so it may be useful in solving the task ¬† Emirp primes ¬† as well as others (depending on its efficiency).

Uses the code from Sieve<sub>of</sub><sub>Eratosthenes</sub>#Unbounded<sub>Page</sub>-Segmented<sub>bit</sub>-packed<sub>odds</sub>-only<sub>version</sub><sub>with</sub><sub>Iterator</sub>; copy that code into a file named src/pagesieve.rs and prepend pub to all function declarations used in this code (count<sub>primes</sub><sub>paged</sub> and primes<sub>paged</sub>).

```rust
mod pagesieve;
¬†
use pagesieve::{count_primes_paged, primes_paged};
¬†
fn main() {
    println!("First 20 primes:\n {:?}",
             primes_paged().take(20).collect::<Vec<_>>());
    println!("Primes between 100 and 150:\n {:?}",
             primes_paged().skip_while(|&x| x < 100)
                           .take_while(|&x| x < 150)
                           .collect::<Vec<_>>());
    let diff = count_primes_paged(8000) - count_primes_paged(7700);
    println!("There are {} primes between 7,700 and 8,000", diff);
    println!("The 10,000th prime is {}", primes_paged().nth(10_000).unwrap());
}
```

Output:

```rust
First 20 primes:
 [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]
Primes between 100 and 150:
 [101, 103, 107, 109, 113, 127, 131, 137, 139, 149]
There are 30 primes between 7,700 and 8,000
The 10,000th prime is 104743

```

# The Twelve Days of Christmas<a id="sec-275"></a>

Task

Write a program that outputs the lyrics of the Christmas carol The Twelve Days of Christmas. The lyrics can be found here.

(You must reproduce the words in the correct order, but case, format, and punctuation are left to your discretion.)

Related tasks

¬† 99 Bottles of Beer ¬† Old<sub>lady</sub><sub>swallowed</sub><sub>a</sub><sub>fly</sub> ¬† Comma quibbling

Rust Playground

```rust
fn main() {
    let days = ["first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth",
                "ninth", "tenth", "eleventh", "twelfth"];
¬†
    let gifts = ["A Patridge in a Pear Tree",
                 "Two Turtle Doves and",
                 "Three French Hens",
                 "Four Calling Birds",
                 "Five Golden Rings",
                 "Six Geese a Laying",
                 "Seven Swans a Swimming",
                 "Eight Maids a Milking",
                 "Nine Ladies Dancing",
                 "Ten Lords a Leaping",
                 "Eleven Pipers Piping",
                 "Twelve Drummers Drumming"];
¬†
    for i in 0..12 {
        println!("On the {} day of Christmas,", days[i]);
        println!("My true love gave to me:");
¬†
        for j in (0..i + 1).rev() {
            println!("{}", gifts[j]);
        }
        println!()
    }
}
```

# Continued fraction<a id="sec-276"></a>

continued fraction

Mathworld

{\displaystyle a<sub>0</sub>+{\cfrac {b<sub>1</sub>}{a<sub>1</sub>+{\cfrac {b<sub>2</sub>}{a<sub>2</sub>+{\cfrac {b<sub>3</sub>}{a<sub>3</sub>+\ddots }}}}}}}

The task is to write a program which generates such a number and prints a real representation of it. The code should be tested by calculating and printing the square root of 2, Napier's Constant, and Pi, using the following coefficients:

For the square root of 2, use {\displaystyle a<sub>0</sub>=1} then {\displaystyle a<sub>N</sub>=2} . {\displaystyle b<sub>N</sub>} is always {\displaystyle 1} .

{\displaystyle {\sqrt {2}}=1+{\cfrac {1}{2+{\cfrac {1}{2+{\cfrac {1}{2+\ddots }}}}}}}

For Napier's Constant, use {\displaystyle a<sub>0</sub>=2} , then {\displaystyle a<sub>N</sub>=N} . {\displaystyle b<sub>1</sub>=1} then {\displaystyle b<sub>N</sub>=N-1} .

{\displaystyle e=2+{\cfrac {1}{1+{\cfrac {1}{2+{\cfrac {2}{3+{\cfrac {3}{4+\ddots }}}}}}}}}

For Pi, use {\displaystyle a<sub>0</sub>=3} then {\displaystyle a<sub>N</sub>=6} . {\displaystyle b<sub>N</sub>=(2N-1)<sup>2</sup>} .

{\displaystyle &pi; =3+{\cfrac {1}{6+{\cfrac {9}{6+{\cfrac {25}{6+\ddots }}}}}}}

See also:

Continued fraction/Arithmetic for tasks that do arithmetic over continued fractions.

```rust
¬†
use std::iter;
¬†
// Calculating a continued fraction is quite easy with iterators, however
// writing a proper iterator adapter is less so. We settle for a macro which
// for most purposes works well enough.
//
// One limitation with this iterator based approach is that we cannot reverse
// input iterators since they are not usually DoubleEnded. To circumvent this
// we can collect the elements and then reverse them, however this isn't ideal
// as we now have to store elements equal to the number of iterations.
//
// Another is that iterators cannot be resused once consumed, so it is often
// required to make many clones of iterators.
macro_rules! continued_fraction {
    ($a:expr, $b:expr¬†; $iterations:expr) => (
        ($a).zip($b)
            .take($iterations)
            .collect::<Vec<_>>().iter()
            .rev()
            .fold(0 as f64, |acc: f64, &(x, y)| {
                x as f64 + (y as f64 / acc)
            })
    );
¬†
    ($a:expr, $b:expr) => (continued_fraction!($a, $b¬†; 1000));
}
¬†
fn main() {
    // Sqrt(2)
    let sqrt2a = (1..2).chain(iter::repeat(2));
    let sqrt2b = iter::repeat(1);
    println!("{}", continued_fraction!(sqrt2a, sqrt2b));
¬†
¬†
    // Napier's Constant
    let napiera = (2..3).chain(1..);
    let napierb = (1..2).chain(1..);
    println!("{}", continued_fraction!(napiera, napierb));
¬†
¬†
    // Pi
    let pia = (3..4).chain(iter::repeat(6));
    let pib = (1i64..).map(|x| (2 * x - 1).pow(2));
    println!("{}", continued_fraction!(pia, pib));
}
¬†
```

Output:

```rust
1.4142135623730951
2.7182818284590455
3.141592653339042

```

# Runge-Kutta method<a id="sec-277"></a>

Given the example Differential equation:

{\displaystyle y'(t)=t&times; {\sqrt {y(t)}}}

With initial condition:

{\displaystyle t<sub>0</sub>=0} and {\displaystyle y<sub>0</sub>=y(t<sub>0</sub>)=y(0)=1}

This equation has an exact solution:

{\displaystyle y(t)={\tfrac {1}{16}}(t<sup>2</sup>+4)<sup>2</sup>} Task

Demonstrate the commonly used explicit ¬† fourth-order Runge‚ÄìKutta method ¬† to solve the above differential equation.

Solve the given differential equation over the range {\displaystyle t=0\ldots 10} with a step value of {\displaystyle &delta; t=0.1} (101 total points, the first being given) Print the calculated values of {\displaystyle y} at whole numbered {\displaystyle t} 's ( {\displaystyle 0.0,1.0,\ldots 10.0} ) along with error as compared to the exact solution.

Method summary

Starting with a given {\displaystyle y<sub>n</sub>} and {\displaystyle t<sub>n</sub>} calculate:

{\displaystyle &delta; y<sub>1</sub>=&delta; t&times; y'(t<sub>n</sub>,y<sub>n</sub>)\quad } {\displaystyle &delta; y<sub>2</sub>=&delta; t&times; y'(t<sub>n</sub>+{\tfrac {1}{2}}&delta; t,y<sub>n</sub>+{\tfrac {1}{2}}&delta; y<sub>1</sub>)} {\displaystyle &delta; y<sub>3</sub>=&delta; t&times; y'(t<sub>n</sub>+{\tfrac {1}{2}}&delta; t,y<sub>n</sub>+{\tfrac {1}{2}}&delta; y<sub>2</sub>)} {\displaystyle &delta; y<sub>4</sub>=&delta; t&times; y'(t<sub>n</sub>+&delta; t,y<sub>n</sub>+&delta; y<sub>3</sub>)\quad }

then:

{\displaystyle y<sub>n+1</sub>=y<sub>n</sub>+{\tfrac {1}{6}}(&delta; y<sub>1</sub>+2&delta; y<sub>2</sub>+2&delta; y<sub>3</sub>+&delta; y<sub>4</sub>)} {\displaystyle t<sub>n+1</sub>=t<sub>n</sub>+&delta; t\quad }

This is a translation of the javascript solution with some minor differences.

```rust
fn runge_kutta4(fx: &Fn(f64, f64) -> f64, x: f64, y: f64, dx: f64) -> f64 {
    let k1 = dx * fx(x, y);
    let k2 = dx * fx(x + dx / 2.0, y + k1 / 2.0);
    let k3 = dx * fx(x + dx / 2.0, y + k2 / 2.0);
    let k4 = dx * fx(x + dx, y + k3);
¬†
    y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0
}
¬†
fn f(x: f64, y: f64) -> f64 {
    x * y.sqrt()
}
¬†
fn actual(x: f64) -> f64 {
    (1.0 / 16.0) * (x * x + 4.0).powi(2)
}
¬†
fn main() {
    let mut y = 1.0;
    let mut x = 0.0;
    let step = 0.1;
    let max_steps = 101;
    let sample_every_n = 10;
¬†
    for steps in 0..max_steps {
        if steps¬†% sample_every_n == 0 {
            println!("y({}):\t{:.10}\t\t {:E}", x, y, actual(x) - y)
        }
¬†
        y = runge_kutta4(&f, x, y, step);
¬†
        x = ((x * 10.0) + (step * 10.0)) / 10.0;
    }
}
```

```rust
y(0):	1.0000000000		 0E0
y(1):	1.5624998543		 1.4572189210859676E-7
y(2):	3.9999990805		 9.194792007782837E-7
y(3):	10.5624970904		 2.9095624487496252E-6
y(4):	24.9999937651		 6.234909363911356E-6
y(5):	52.5624891803		 1.0819697415342944E-5
y(6):	99.9999834054		 1.659459641700778E-5
y(7):	175.5624764823		 2.3517728749311573E-5
y(8):	288.9999684348		 3.156520142510999E-5
y(9):	451.5624592768		 4.07231603389846E-5
y(10):	675.9999490167		 5.098329029351589E-5

```

# Unicode variable names<a id="sec-278"></a>

Describe, and give a pointer to documentation on your languages use of characters beyond those of the ASCII character set in the naming of variables. Show how to:

Set a variable with a name including the 'Œî', (delta character), to 1 Increment it Print its value.

Related task

Case-sensitivity of identifiers

Rust source encoding is specified to be UTF-8. Identifiers must begin with a character that has Unicode XID<sub>start</sub> property and remaining characters must have the XID<sub>Continue</sub> property. (Which means that ‚ïØ¬∞‚ñ°¬∞‚ïØÔ∏µ‚îª‚îÅ‚îª is not permitted under current specification)

Non-ASCII identifiers are feature gated since version 0.9

```rust
#![feature(non_ascii_idents)]
#![allow(non_snake_case)]
¬†
fn main() {
    let mut Œî: i32 = 1;
    Œî += 1;
    println!("{}", Œî);
}
```

# Probabilistic choice<a id="sec-279"></a>

Given a mapping between items and their required probability of occurrence, generate a million items randomly subject to the given probabilities and compare the target probability of occurrence versus the generated values.

The total of all the probabilities should equal one. (Because floating point arithmetic is involved, this is subject to rounding errors).

```
aleph   1/5.0
beth    1/6.0
gimel   1/7.0
daleth  1/8.0
he      1/9.0
waw     1/10.0
zayin   1/11.0
heth    1759/27720 # adjusted so that probabilities add to 1
```

Related task

Random number generator (device)

```rust
extern crate rand;
¬†
use rand::distributions::{IndependentSample, Sample, Weighted, WeightedChoice};
use rand::{weak_rng, Rng};
¬†
const DATA: [(&str, f64); 8] = [
    ("aleph", 1.0 / 5.0),
    ("beth", 1.0 / 6.0),
    ("gimel", 1.0 / 7.0),
    ("daleth", 1.0 / 8.0),
    ("he", 1.0 / 9.0),
    ("waw", 1.0 / 10.0),
    ("zayin", 1.0 / 11.0),
    ("heth", 1759.0 / 27720.0),
];
¬†
const SAMPLES: usize = 1_000_000;
¬†
/// Generate a mapping to be used by `WeightedChoice`
fn gen_mapping() -> Vec<Weighted<usize>> {
    DATA.iter()
        .enumerate()
        .map(|(i, &(_, p))| Weighted {
            // `WeightedChoice` requires `u32` weights rather than raw probabilities.  For each
            // probability, we convert it to a `u32` weight, and associate it with an index. We
            // multiply by a constant because small numbers such as 0.2 when casted to `u32`
            // become `0`.  This conversion decreases the accuracy of the mapping, which is why we
            // provide an implementation which uses `f64`s for the best accuracy.
            weight: (p * 1_000_000_000.0) as u32,
            item: i,
        })
        .collect()
}
¬†
/// Generate a mapping of the raw probabilities
fn gen_mapping_float() -> Vec<f64> {
    // This does the work of `WeightedChoice::new`, splitting a number into various ranges.  The
    // `item` of `Weighted` is represented here merely by the probability's position in the `Vec`.
    let mut running_total = 0.0;
    DATA.iter()
        .map(|&(_, p)| {
            running_total += p;
            running_total
        })
        .collect()
}
¬†
/// An implementation of `WeightedChoice` which uses probabilities rather than weights.  Refer to
/// the `WeightedChoice` source for serious usage.
struct WcFloat {
    mapping: Vec<f64>,
}
¬†
impl WcFloat {
    fn new(mapping: &[f64]) -> Self {
        Self {
            mapping: mapping.to_vec(),
        }
    }
¬†
    // This is roughly the same logic as `WeightedChoice::ind_sample` (though is likely slower)
    fn search(&self, sample_prob: f64) -> usize {
        let idx = self.mapping
            .binary_search_by(|p| p.partial_cmp(&sample_prob).unwrap());
        match idx {
            Ok(i) | Err(i) => i,
        }
    }
}
¬†
impl IndependentSample<usize> for WcFloat {
    fn ind_sample<R: Rng>(&self, rng: &mut R) -> usize {
        // Because we know the total is exactly 1.0, we can merely use a raw float value.
        // Otherwise caching `Range::new(0.0, running_total)` and sampling with
        // `range.ind_sample(&mut rng)` is recommended.
        let sample_prob = rng.next_f64();
        self.search(sample_prob)
    }
}
¬†
impl Sample<usize> for WcFloat {
    fn sample<R: Rng>(&mut self, rng: &mut R) -> usize {
        self.ind_sample(rng)
    }
}
¬†
fn take_samples<R: Rng, T>(rng: &mut R, wc: &T) -> [usize; 8]
where
    T: IndependentSample<usize>,
{
    let mut counts = [0; 8];
    for _ in 0..SAMPLES {
        let sample = wc.ind_sample(rng);
        counts[sample] += 1;
    }
    counts
}
¬†
fn print_mapping(counts: &[usize]) {
    println!("Item   | Expected | Actual   ");
    println!("-------|----------|----------");
    for (&(name, expected), &count) in DATA.iter().zip(counts.iter()) {
        let real = count as f64 / SAMPLES as f64;
        println!("{:6} | {:.6} | {:.6}", name, expected, real);
    }
}
¬†
fn main() {
    let mut rng = weak_rng();
¬†
    println!("    ~~~ U32 METHOD ~~~");
    let mut mapping = gen_mapping();
    let wc = WeightedChoice::new(&mut mapping);
¬†
    let counts = take_samples(&mut rng, &wc);
    print_mapping(&counts);
¬†
    println!();
¬†
    println!("   ~~~ FLOAT METHOD ~~~");
    // initialize the float version of `WeightedChoice`
    let mapping = gen_mapping_float();
    let wc = WcFloat::new(&mapping);
¬†
    let counts = take_samples(&mut rng, &wc);
    print_mapping(&counts);
}
```

Output:

```rust
    ~~~ U32 METHOD ~~~
Item   | Expected | Actual   
-------|----------|----------
aleph  | 0.200000 | 0.200195
beth   | 0.166667 | 0.166182
gimel  | 0.142857 | 0.142502
daleth | 0.125000 | 0.125503
he     | 0.111111 | 0.110820
waw    | 0.100000 | 0.100166
zayin  | 0.090909 | 0.090927
heth   | 0.063456 | 0.063705

   ~~~ FLOAT METHOD ~~~
Item   | Expected | Actual   
-------|----------|----------
aleph  | 0.200000 | 0.199984
beth   | 0.166667 | 0.166634
gimel  | 0.142857 | 0.143218
daleth | 0.125000 | 0.124956
he     | 0.111111 | 0.111047
waw    | 0.100000 | 0.099805
zayin  | 0.090909 | 0.090513
heth   | 0.063456 | 0.063843
```

# Brownian tree<a id="sec-280"></a>

This page uses content from Wikipedia. The original article was at Brownian<sub>tree</sub>. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Task

Generate and draw a ¬† Brownian Tree.

A Brownian Tree is generated as a result of an initial seed, followed by the interaction of two processes.

The initial "seed" is placed somewhere within the field. Where is not particularly important; it could be randomized, or it could be a fixed point. Particles are injected into the field, and are individually given a (typically random) motion pattern. When a particle collides with the seed or tree, its position is fixed, and it's considered to be part of the tree.

Because of the lax rules governing the random nature of the particle's placement and motion, no two resulting trees are really expected to be the same, or even necessarily have the same general shape.

Translation of: D

Library: rand

Library: image

```rust
¬†
extern crate image;
extern crate rand;
¬†
use image::ColorType;
use rand::distributions::{IndependentSample, Range};
use std::cmp::{min, max};
use std::env;
use std::path::Path;
use std::process;
¬†
fn help() {
    println!("Usage: brownian_tree <output_path> <mote_count> <edge_length>");
}
¬†
fn main() {
    let args: Vec<String> = env::args().collect();
    let mut output_path = Path::new("out.png");
    let mut mote_count: u32 = 10000;
    let mut width: usize = 512;
    let mut height: usize = 512;
¬†
    match args.len() {
        1 => {}
        4 => {
            output_path = Path::new(&args[1]);
            mote_count = args[2].parse::<u32>().unwrap();
            width = args[3].parse::<usize>().unwrap();
            height = width;
        }
        _ => {
            help();
            process::exit(0);
        }
    }
¬†
    assert!(width >= 2);
¬†
    // Base 1d array
    let mut field_raw = vec![0u8; width * height];
    populate_tree(&mut field_raw, width, height, mote_count);
¬†
    // Balance image for 8-bit grayscale
    let our_max = field_raw.iter().fold(0u8, |champ, e| max(champ, *e));
    let fudge = std::u8::MAX / our_max;
    let balanced: Vec<u8> = field_raw.iter().map(|e| e * fudge).collect();
¬†
    match image::save_buffer(output_path,
                             &balanced,
                             width as u32,
                             height as u32,
                             ColorType::Gray(8)) {
        Err(e) => println!("Error writing output image:\n{}", e),
        Ok(_) => println!("Output written to:\n{}", output_path.to_str().unwrap()),
    }
}
¬†
¬†
fn populate_tree(raw: &mut Vec<u8>, width: usize, height: usize, mc: u32) {
    // Vector of 'width' elements slices
    let mut field_base: Vec<_> = raw.as_mut_slice().chunks_mut(width).collect();
    // Addressable 2d vector
    let mut field: &mut [&mut [u8]] = field_base.as_mut_slice();
¬†
    // Seed mote
    field[width / 2][height / 2] = 1;
¬†
    let walk_range = Range::new(-1i32, 2i32);
    let x_spawn_range = Range::new(1usize, width - 1);
    let y_spawn_range = Range::new(1usize, height - 1);
    let mut rng = rand::thread_rng();
¬†
    for i in 0..mc {
        if i¬†% 100 == 0 {
            println!("{}", i)
        }
¬†
        // Spawn mote
        let mut x = x_spawn_range.ind_sample(&mut rng);
        let mut y = y_spawn_range.ind_sample(&mut rng);
¬†
        // Increment field value when motes spawn on top of the structure
        if field[x][y] > 0 {
            field[x][y] = min(field[x][y] as u32 + 1, std::u8::MAX as u32) as u8;
            continue;
        }
¬†
        loop {
            let contacts = field[x - 1][y - 1] + field[x][y - 1] + field[x + 1][y - 1] +
                           field[x - 1][y] + field[x + 1][y] +
                           field[x - 1][y + 1] + field[x][y + 1] +
                           field[x + 1][y + 1];
¬†
            if contacts > 0 {
                field[x][y] = 1;
                break;
            } else {
                let xw = walk_range.ind_sample(&mut rng) + x as i32;
                let yw = walk_range.ind_sample(&mut rng) + y as i32;
                if xw < 1 || xw >= (width as i32 - 1) || yw < 1 || yw >= (height as i32 - 1) {
                    break;
                }
                x = xw as usize;
                y = yw as usize;
            }
        }
    }
}
```

For a 512 x 512 field and 65k motes, run time is 25 s on ~2011 hardware (Phenom II X4).

![img](Rust-Brownian-512-20k.png)

# Literals/Floating point<a id="sec-281"></a>

Programming languages have different ways of expressing floating-point literals.

Task

Show how floating-point literals can be expressed in your language: decimal or other bases, exponential notation, and any other special features.

You may want to include a regular expression or BNF/ABNF/EBNF defining allowable formats for your language.

Related tasks

¬† Literals/Integer ¬† Extreme floating point values

```rust
2.3         // Normal floating point literal
3.          // Equivalent to 3.0 (3 would be interpreted as an integer)
2f64        // The type (in this case f64, a 64-bit floating point number) may be appended to the value
1_000.2_f32 // Underscores may appear anywhere in the number for clarity.
```

# Catalan numbers/Pascal's triangle<a id="sec-282"></a>

Task

Print out the first ¬† 15 ¬† Catalan numbers by extracting them from Pascal's triangle.

See

¬† Catalan Numbers and the Pascal Triangle. ¬† ¬† This method enables calculation of Catalan Numbers using only addition and subtraction. ¬† Catalan's Triangle for a Number Triangle that generates Catalan Numbers using only addition. ¬† Sequence A000108 on OEIS has a lot of information on Catalan Numbers.

Related Tasks

Pascal's triangle

```rust
¬†
¬†
fn main()
{let n=15usize;
 let mut t= [0; 17];
 t[1]=1;
 let mut j:usize;
 for i in 1..n+1
 {
  j=i;
  loop{
      if j==1{
          break; 
    }
    t[j]=t[j] + t[j-1];
    j=j-1;
  }
  t[i+1]= t[i];
  j=i+1;
  loop{
    if j==1{
    break;
    }
    t[j]=t[j] + t[j-1];
    j=j-1;
  }
  print!("{} ", t[i+1]-t[i]);
 }
}
¬†
```

Output:

```rust
1 2 5 14 42 132 429 1430 4862 16796 58786 208012 742900 2674440 9694845 
```

# Sorting algorithms/Bogosort<a id="sec-283"></a>

Task

Bogosort a list of numbers.

Bogosort simply shuffles a collection randomly until it is sorted.

"Bogosort" is a perversely inefficient algorithm only used as an in-joke.

Its average run-time is ¬† O(n!) ¬† because the chance that any given shuffle of a set will end up in sorted order is about one in ¬† n ¬† factorial, ¬† and the worst case is infinite since there's no guarantee that a random shuffling will ever produce a sorted sequence.

Its best case is ¬† O(n) ¬† since a single pass through the elements may suffice to order them.

Pseudocode:

```
while not InOrder(list) do
   Shuffle(list)
done

```

The Knuth shuffle may be used to implement the shuffle part of this algorithm.

Works with Rust 1.11+, requires rand module

Library: rand

```rust
extern crate rand;
use rand::Rng;
¬†
fn bogosort_by<T,F>(order: F, coll: &mut [T])
    where F: Fn(&T, &T) -> bool
{
    let mut rng = rand::thread_rng();
    while¬†!is_sorted_by(&order, coll) {
        rng.shuffle(coll);
    }
}
¬†
#[inline]
fn is_sorted_by<T,F>(order: F, coll: &[T]) -> bool
    where F: Fn(&T,&T) -> bool,
{
    coll[..].iter().zip(&coll[1..]).all(|(x,y)| order(x,y))
}
¬†
¬†
fn main() {
    let mut testlist = [1,55,88,24,990876,312,67,0,854,13,4,7];
    bogosort_by(|x,y| x < y, &mut testlist);
    println!("{:?}", testlist);
    bogosort_by(|x,y| x > y, &mut testlist);
    println!("{:?}", testlist);
}
¬†
```

# Bulls and cows<a id="sec-284"></a>

Bulls and Cows

Task

Create a four digit random number from the digits ¬† 1 ¬† to ¬† 9, ¬† without duplication.

The program should:

¬† ask for guesses to this number ¬† reject guesses that are malformed ¬† print the score for the guess

The score is computed as:

The player wins if the guess is the same as the randomly chosen number, and the program ends. A score of one bull is accumulated for each digit in the guess that equals the corresponding digit in the randomly chosen initial number. A score of one cow is accumulated for each digit in the guess that also appears in the randomly chosen number, but in the wrong position.

Related tasks

¬† Bulls and cows/Player ¬† Guess the number ¬† Guess the number/With Feedback ¬† Mastermind

Library: rand

```rust
use std::io;
use rand::{Rng,thread_rng};
¬†
extern crate rand;
¬†
const NUMBER_OF_DIGITS: usize = 4;
¬†
static DIGITS: [char; 9] = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
¬†
fn generate_digits() -> Vec<char> {
    let mut temp_digits: Vec<_> = (&DIGITS[..]).into();
    thread_rng().shuffle(&mut temp_digits);
    return temp_digits.iter().take(NUMBER_OF_DIGITS).map(|&a| a).collect();
}
¬†
fn parse_guess_string(guess: &str) -> Result<Vec<char>, String> {
    let chars: Vec<char> = (&guess).chars().collect();
¬†
    if¬†!chars.iter().all(|c| DIGITS.contains(c)) {
        return Err("only digits, please".to_string());
    }
¬†
    if chars.len()¬†!= NUMBER_OF_DIGITS {
        return Err(format!("you need to guess with {} digits", NUMBER_OF_DIGITS));
    }
¬†
    let mut uniques: Vec<char> = chars.clone();
    uniques.dedup();
    if uniques.len()¬†!= chars.len() {
        return Err("no duplicates, please".to_string());
    }
¬†
    return Ok(chars);
}
¬†
fn calculate_score(given_digits: &[char], guessed_digits: &[char]) -> (usize, usize) {
    let mut bulls = 0;
    let mut cows = 0;
    for i in 0..NUMBER_OF_DIGITS {
        let pos: Option<usize> = guessed_digits.iter().position(|&a| -> bool {a == given_digits[i]});
        match pos {
            None              => (),
            Some(p) if p == i => bulls += 1,
            Some(_)           => cows += 1
        }
    }
    return (bulls, cows);
}
¬†
fn main() {
    let reader = io::stdin();
¬†
    loop {
        let given_digits = generate_digits();
        println!("I have chosen my {} digits. Please guess what they are", NUMBER_OF_DIGITS);
¬†
        loop {
            let guess_string: String = {
                let mut buf = String::new();
                reader.read_line(&mut buf).unwrap();
                buf.trim().into()
            };
¬†
            let digits_maybe = parse_guess_string(&guess_string);
            match digits_maybe {
                Err(msg) => {
                    println!("{}", msg);
                    continue;
                },
                Ok(guess_digits) => {
                    match calculate_score(&given_digits, &guess_digits) {
                        (NUMBER_OF_DIGITS, _) => {
                            println!("you win!");
                            break;
                        },
                        (bulls, cows) => println!("bulls: {}, cows: {}", bulls, cows)
                    }
                }
            }
        }
    }
}
```

# Sorting algorithms/Counting sort<a id="sec-285"></a>

This page uses content from Wikipedia. The original article was at Counting sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Task

Implement the Counting sort. This is a way of sorting integers when the minimum and maximum value are known.

Pseudocode:

```
function countingSort(array, min, max):
    count: array of (max - min + 1) elements
    initialize count with 0
    for each number in array do
        count[number - min]¬†:= count[number - min] + 1
    done
    z¬†:= 0
    for i from min to max do
        while ( count[i - min] > 0 ) do
            array[z]¬†:= i
            z¬†:= z+1
            count[i - min]¬†:= count[i - min] - 1
        done
    done

```

The min and max can be computed apart, or be known a priori.

Note: ¬† we know that, given an array of integers, ¬† its maximum and minimum values can be always found; ¬† but if we imagine the worst case for an array that can hold up to 32 bit integers, ¬† we see that in order to hold the counts, ¬† an array of up to 232 elements may be needed. ¬† I.E.: ¬† we need to hold a count value up to 232-1, ¬† which is a little over 4.2 Gbytes. ¬† So the counting sort is more practical when the range is (very) limited, ¬† and minimum and maximum values are known ¬† a priori. ¬† (The use of ¬† sparse arrays ¬† minimizes the impact of the memory usage, ¬† as well as removing the need of having to know the minimum and maximum values ¬† a priori.)

```rust
fn counting_sort(
    mut data: Vec<usize>,
    min: usize,
    max: usize,
) -> Vec<usize> {
    // create and fill counting bucket with 0
    let mut count: Vec<usize> = Vec::with_capacity(data.len());
    count.resize(data.len(), 0);
¬†
    for num in &data {
        count[num - min] = count[num - min] + 1;
    }
    let mut z: usize = 0;
    for i in min..max+1 {
        while count[i - min] > 0 {
            data[z] = i;
            z += 1;
            count[i - min] = count[i - min] - 1;
        }
    }
¬†
    data
}
¬†
fn main() {
    let arr1 = vec![1, 0, 2, 9, 3, 8, 4, 7, 5, 6];
    println!("{:?}", counting_sort(arr1, 0, 9));
¬†
    let arr2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    println!("{:?}", counting_sort(arr2, 0, 9));
¬†
    let arr3 = vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
    println!("{:?}", counting_sort(arr3, 0, 10));
}
```

Output:

```rust
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

```

# Bernoulli numbers<a id="sec-286"></a>

Bernoulli numbers are used in some series expansions of several functions ¬† (trigonometric, hyperbolic, gamma, etc.), ¬† and are extremely important in number theory and analysis.

Note that there are two definitions of Bernoulli numbers; ¬† this task will be using the modern usage ¬† (as per ¬† The National Institute of Standards and Technology convention).

The ¬† nth ¬† Bernoulli number is expressed as ¬† Bn.

Task

¬† show the Bernoulli numbers ¬† B0 ¬† through ¬† B60. ¬† suppress the output of values which are equal to zero. ¬† (Other than ¬† B1¬†, all odd Bernoulli numbers have a value of zero.) ¬† express the Bernoulli numbers as fractions ¬†(most are improper fractions). ¬† the fractions should be reduced. ¬† index each number in some way so that it can be discerned which Bernoulli number is being displayed. ¬† align the solidi ¬† (/) ¬† if used (extra credit).

An algorithm

The Akiyama‚ÄìTanigawa algorithm for the "second Bernoulli numbers" as taken from wikipedia is as follows:

```
for m from 0 by 1 to n do
   A[m] ‚Üê 1/(m+1)
   for j from m by -1 to 1 do
     A[j-1] ‚Üê j√ó(A[j-1] - A[j])
 return A[0] (which is Bn)

```

See also

Sequence A027641 Numerator of Bernoulli number B<sub>n</sub> on The On-Line Encyclopedia of Integer Sequences. Sequence A027642 Denominator of Bernoulli number B<sub>n</sub> on The On-Line Encyclopedia of Integer Sequences. Entry Bernoulli number on The Eric Weisstein's World of Mathematics (TM). Luschny's The Bernoulli Manifesto for a discussion on ¬† B1 ¬† = ¬† -¬Ω ¬† versus ¬† +¬Ω.

```rust
// 2.5 implementations presented here:  naive, optimized, and an iterator using
// the optimized function. The speeds vary significantly: relative
// speeds of optimized:iterator:naive implementations is 625:25:1.
¬†
#![feature(test)]
¬†
extern crate num;
extern crate test;
¬†
use num::bigint::{BigInt, ToBigInt};
use num::rational::{BigRational};
use std::cmp::max;
use std::env;
use std::ops::{Mul, Sub};
use std::process;
¬†
struct Bn {
    value: BigRational,
    index: i32
}
¬†
struct Context {
    bigone_const: BigInt,
    a: Vec<BigRational>,
    index: i32              // Counter for iterator implementation
}
¬†
impl Context {
    pub fn new() -> Context {
        let bigone = 1.to_bigint().unwrap();
        let a_vec: Vec<BigRational> = vec![];
        Context {
            bigone_const: bigone,
            a: a_vec,
            index: -1
        }
    }
}
¬†
impl Iterator for Context {
    type Item = Bn;
¬†
    fn next(&mut self) -> Option<Bn> {
        self.index += 1;
        Some(Bn { value: bernoulli(self.index as usize, self), index: self.index })
    }
}
¬†
fn help() {
    println!("Usage: bernoulli_numbers <up_to>");
}
¬†
fn main() {
    let args: Vec<String> = env::args().collect();
    let mut up_to: usize = 60;
¬†
    match args.len() {
        1 => {},
        2 => {
            up_to = args[1].parse::<usize>().unwrap();
        },
        _ => {
            help();
            process::exit(0);
        }
    }
¬†
    let context = Context::new();
    // Collect the solutions by using the Context iterator
    // (this is not as fast as calling the optimized function directly).
    let res = context.take(up_to + 1).collect::<Vec<_>>();
    let width = res.iter().fold(0, |a, r| max(a, r.value.numer().to_string().len()));
¬†
    for r in res.iter().filter(|r| r.index¬†% 2 == 0) {
        println!("B({:>2}) = {:>2$} / {denom}", r.index, r.value.numer(), width,
            denom = r.value.denom());
    }
}
¬†
// Implementation with no reused calculations.
fn _bernoulli_naive(n: usize, c: &mut Context) -> BigRational {
    for m in 0..n + 1 {
        c.a.push(BigRational::new(c.bigone_const.clone(), (m + 1).to_bigint().unwrap()));
        for j in (1..m + 1).rev() {
            c.a[j - 1] = (c.a[j - 1].clone().sub(c.a[j].clone())).mul(
                BigRational::new(j.to_bigint().unwrap(), c.bigone_const.clone())
            );
        }
    }
    c.a[0].reduced()
}
¬†
// Implementation with reused calculations (does not require sequential calls).
fn bernoulli(n: usize, c: &mut Context) -> BigRational {
    for i in 0..n + 1 {
        if i >= c.a.len() {
            c.a.push(BigRational::new(c.bigone_const.clone(), (i + 1).to_bigint().unwrap()));
            for j in (1..i + 1).rev() {
                c.a[j - 1] = (c.a[j - 1].clone().sub(c.a[j].clone())).mul(
                    BigRational::new(j.to_bigint().unwrap(), c.bigone_const.clone())
                );
            }
        }
    }
    c.a[0].reduced()
}
¬†
¬†
#[cfg(test)]
mod tests {
    use super::{Bn, Context, bernoulli, _bernoulli_naive};
    use num::rational::{BigRational};
    use std::str::FromStr;
    use test::Bencher;
¬†
    // [tests elided]
¬†
    #[bench]
    fn bench_bernoulli_naive(b: &mut Bencher) {
        let mut context = Context::new();
        b.iter(|| {
            let mut res: Vec<Bn> = vec![];
            for n in 0..30 + 1 {
                let b = _bernoulli_naive(n, &mut context);
                res.push(Bn { value:b.clone(), index: n as i32});
            }
        });
    }
¬†
    #[bench]
    fn bench_bernoulli(b: &mut Bencher) {
        let mut context = Context::new();
        b.iter(|| {
            let mut res: Vec<Bn> = vec![];
            for n in 0..30 + 1 {
                let b = bernoulli(n, &mut context);
                res.push(Bn { value:b.clone(), index: n as i32});
            }
        });
    }
¬†
    #[bench]
    fn bench_bernoulli_iter(b: &mut Bencher) {
        b.iter(|| {
            let context = Context::new();
            let _res = context.take(30 + 1).collect::<Vec<_>>();
        });
    }
}
¬†
```

Output:

```rust
B( 0) =                                            1 / 1
B( 2) =                                            1 / 6
B( 4) =                                           -1 / 30
B( 6) =                                            1 / 42
B( 8) =                                           -1 / 30
B(10) =                                            5 / 66
B(12) =                                         -691 / 2730
B(14) =                                            7 / 6
B(16) =                                        -3617 / 510
B(18) =                                        43867 / 798
B(20) =                                      -174611 / 330
B(22) =                                       854513 / 138
B(24) =                                   -236364091 / 2730
B(26) =                                      8553103 / 6
B(28) =                                 -23749461029 / 870
B(30) =                                8615841276005 / 14322
B(32) =                               -7709321041217 / 510
B(34) =                                2577687858367 / 6
B(36) =                        -26315271553053477373 / 1919190
B(38) =                             2929993913841559 / 6
B(40) =                       -261082718496449122051 / 13530
B(42) =                       1520097643918070802691 / 1806
B(44) =                     -27833269579301024235023 / 690
B(46) =                     596451111593912163277961 / 282
B(48) =                -5609403368997817686249127547 / 46410
B(50) =                  495057205241079648212477525 / 66
B(52) =              -801165718135489957347924991853 / 1590
B(54) =             29149963634884862421418123812691 / 798
B(56) =          -2479392929313226753685415739663229 / 870
B(58) =          84483613348880041862046775994036021 / 354
B(60) = -1215233140483755572040304994079820246041491 / 56786730

```

# Compile-time calculation<a id="sec-287"></a>

Some programming languages allow calculation of values at compile time.

Task

Calculate ¬† 10! ¬† (ten factorial) ¬† at compile time.

Print the result when the program is run.

Discuss what limitations apply to compile-time calculations in your language.

The Rust compiler can automatically do optimizations in the code to calculate the factorial.

```rust
fn factorial(n: i64) -> i64 {
    let mut total = 1;
    for i in 1..n+1 {
        total *= i;
    }
    return total;
}
¬†
fn main() {
    println!("Factorial of 10 is {}.", factorial(10));
}
```

If we compile this with rustc factorial.rs -O &#x2013;emit asm and inspect the outputted assembly, we can see movq $3628800, (%rsp). This means the result of 3628800 was calculated in compile-time rather than run-time.

# Benford's law<a id="sec-288"></a>

This page uses content from Wikipedia. The original article was at Benford's<sub>law</sub>. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Benford's law, also called the first-digit law, refers to the frequency distribution of digits in many (but not all) real-life sources of data.

In this distribution, the number 1 occurs as the first digit about 30% of the time, while larger numbers occur in that position less frequently: 9 as the first digit less than 5% of the time. This distribution of first digits is the same as the widths of gridlines on a logarithmic scale.

Benford's law also concerns the expected distribution for digits beyond the first, which approach a uniform distribution.

This result has been found to apply to a wide variety of data sets, including electricity bills, street addresses, stock prices, population numbers, death rates, lengths of rivers, physical and mathematical constants, and processes described by power laws (which are very common in nature). It tends to be most accurate when values are distributed across multiple orders of magnitude.

A set of numbers is said to satisfy Benford's law if the leading digit {\displaystyle d} ¬†¬†( {\displaystyle d&isin; \\{1,\ldots ,9\\}} ) occurs with probability

{\displaystyle P(d)=log \_{10}(d+1)-log \_{10}(d)=log \_{10}\left(1+{\frac {1}{d}}\right)}

For this task, write (a) routine(s) to calculate the distribution of first significant (non-zero) digits in a collection of numbers, then display the actual vs. expected distribution in the way most convenient for your language (table / graph / histogram / whatever).

Use the first 1000 numbers from the Fibonacci sequence as your data set. No need to show how the Fibonacci numbers are obtained.

You can generate them or load them from a file; whichever is easiest.

Display your actual vs expected distribution.

For extra credit: Show the distribution for one other set of numbers from a page on Wikipedia. State which Wikipedia page it can be obtained from and what the set enumerates. Again, no need to display the actual list of numbers or the code to load them.

See also:

numberphile.com. A starting page on Wolfram Mathworld is Benfords Law .

Works with: rustc version 1.12 stable

This solution uses the num create for arbitrary-precision integers and the num<sub>traits</sub> create for the zero and one implementations. It computes the Fibonacci numbers from scratch via the fib function.

```rust
¬†
extern crate num_traits;
extern crate num;
¬†
use num::bigint::{BigInt, ToBigInt};
use num_traits::{Zero, One};
use std::collections::HashMap;
¬†
// Return a vector of all fibonacci results from fib(1) to fib(n)
fn fib(n: usize) -> Vec<BigInt> {
    let mut result = Vec::with_capacity(n);
    let mut a = BigInt::zero();
    let mut b = BigInt::one();
¬†
    result.push(b.clone());
¬†
    for i in 1..n {
        let t = b.clone();
        b = a+b;
        a = t;
        result.push(b.clone());
    }
¬†
    result
}
¬†
// Return the first digit of a `BigInt`
fn first_digit(x: &BigInt) -> u8 {
    let zero = BigInt::zero();
    assert!(x > &zero);
¬†
    let s = x.to_str_radix(10);
¬†
    // parse the first digit of the stringified integer
    *&s[..1].parse::<u8>().unwrap()
}
¬†
fn main() {
    const N: usize = 1000;
    let mut counter: HashMap<u8, u32> = HashMap::new();
    for x in fib(N) {
        let d = first_digit(&x);
        *counter.entry(d).or_insert(0) += 1;
    }
¬†
    println!("{:>13}    {:>10}", "real", "predicted");
    for y in 1..10 {
        println!("{}: {:10.3} v. {:10.3}", y, *counter.get(&y).unwrap_or(&0) as f32 / N as f32,
        (1.0 + 1.0 / (y as f32)).log10());
    }
¬†
}
¬†
```

Output:

```rust
         real     predicted
1:      0.301 v.      0.301
2:      0.177 v.      0.176
3:      0.125 v.      0.125
4:      0.096 v.      0.097
5:      0.080 v.      0.079
6:      0.067 v.      0.067
7:      0.056 v.      0.058
8:      0.053 v.      0.051
9:      0.045 v.      0.046

```

# Hash join<a id="sec-289"></a>

An inner join is an operation that combines two data tables into one table, based on matching column values. The simplest way of implementing this operation is the nested loop join algorithm, but a more scalable alternative is the hash join algorithm.

Task[edit]

Implement the "hash join" algorithm, and demonstrate that it passes the test-case listed below.

You should represent the tables as data structures that feel natural in your programming language.

Guidance

The "hash join" algorithm consists of two steps:

Hash phase: Create a multimap from one of the two tables, mapping from each join column value to all the rows that contain it.

The multimap must support hash-based lookup which scales better than a simple linear search, because that's the whole point of this algorithm. Ideally we should create the multimap for the smaller table, thus minimizing its creation time and memory size. Join phase: Scan the other table, and find matching rows by looking in the multimap created before.

In pseudo-code, the algorithm could be expressed as follows:

```
let A = the first input table (or ideally, the larger one)
let B = the second input table (or ideally, the smaller one)
let jA = the join column ID of table A
let jB = the join column ID of table B
let MB = a multimap for mapping from single values to multiple rows of table B (starts out empty)
let C = the output table (starts out empty)

for each row b in table B:
   place b in multimap MB under key b(jB)

for each row a in table A:
   for each row b in multimap MB under key a(jA):
      let c = the concatenation of row a and row b
      place row c in table C

```

Test-case

Input Output

A = Age Name 27 Jonah 18 Alan 28 Glory 18 Popeye 28 Alan B = Character Nemesis Jonah Whales Jonah Spiders Alan Ghosts Alan Zombies Glory Buffy

jA = Name (i.e. column 1) jB = Character (i.e. column 0)

A.Age A.Name B.Character B.Nemesis 27 Jonah Jonah Whales 27 Jonah Jonah Spiders 18 Alan Alan Ghosts 18 Alan Alan Zombies 28 Glory Glory Buffy 28 Alan Alan Ghosts 28 Alan Alan Zombies

The order of the rows in the output table is not significant. If you're using numerically indexed arrays to represent table rows (rather than referring to columns by name), you could represent the output rows in the form [[27, "Jonah"], ["Jonah", "Whales"]].

```rust
use std::collections::HashMap;
use std::hash::Hash;
¬†
// If you know one of the tables is smaller, it is best to make it the second parameter.
fn hash_join<A, B, K>(first: &[(K, A)], second: &[(K, B)]) -> Vec<(A, K, B)>
where
    K: Hash + Eq + Copy,
    A: Copy,
    B: Copy,
{
    let mut hash_map = HashMap::new();
¬†
    // hash phase
    for &(key, val_a) in second {
        // collect all values by their keys, appending new ones to each existing entry
        hash_map.entry(key).or_insert_with(Vec::new).push(val_a);
    }
¬†
    let mut result = Vec::new();
    // join phase
    for &(key, val_b) in first {
        if let Some(vals) = hash_map.get(&key) {
            let tuples = vals.iter().map(|&val_a| (val_b, key, val_a));
            result.extend(tuples);
        }
    }
¬†
    result
}
¬†
fn main() {
    let table1 = [("Jonah", 27), ("Alan", 18), ("Glory", 28), ("Popeye", 18), ("Alan", 28)];
    let table2 = [
        ("Jonah", "Whales"), ("Jonah", "Spiders"), ("Alan", "Ghosts"),
        ("Alan", "Zombies"), ("Glory", "Buffy")
    ];
    let result = hash_join(&table1, &table2);
    println!("Age | Character Name | Nemesis");
    println!("----|----------------|--------");
    for (age, name, nemesis) in result {
        println!("{:<3} | {:^14} | {}", age, name, nemesis);
    }
}
```

Output:

```rust
Age | Character Name | Nemesis
----|----------------|--------
27  |     Jonah      | Whales
27  |     Jonah      | Spiders
18  |      Alan      | Ghosts
18  |      Alan      | Zombies
28  |     Glory      | Buffy
28  |      Alan      | Ghosts
28  |      Alan      | Zombies
```

# Ulam spiral (for primes)<a id="sec-290"></a>

An Ulam spiral (of primes numbers) is a method of visualizing prime numbers when expressed in a (normally counter-clockwise) outward spiral (usually starting at 1), ¬† constructed on a square grid, starting at the "center".

An Ulam spiral is also known as a ¬† prime spiral.

The first grid (green) is shown with sequential integers, ¬† starting at ¬† 1.

In an Ulam spiral of primes, only the primes are shown (usually indicated by some glyph such as a dot or asterisk), ¬† and all non-primes as shown as a blank ¬† (or some other whitespace).

Of course, the grid and border are not to be displayed (but they are displayed here when using these Wiki HTML tables).

Normally, the spiral starts in the "center", ¬† and the ¬† 2nd ¬† number is to the viewer's right and the number spiral starts from there in a counter-clockwise direction.

There are other geometric shapes that are used as well, including clock-wise spirals.

Also, some spirals (for the ¬† 2nd ¬† number) ¬† is viewed upwards from the ¬† 1st ¬† number instead of to the right, but that is just a matter of orientation.

Sometimes, the starting number can be specified to show more visual striking patterns (of prime densities).

[A larger than necessary grid (numbers wise) is shown here to illustrate the pattern of numbers on the diagonals ¬† (which may be used by the method to orientate the direction of spiral-construction algorithm within the example computer programs)].

Then, in the next phase in the transformation of the Ulam prime spiral, ¬† the non-primes are translated to blanks.

In the orange grid below, ¬† the primes are left intact, ¬† and all non-primes are changed to blanks.

Then, in the final transformation of the Ulam spiral (the yellow grid), ¬† translate the primes to a glyph such as a ¬† ‚àô ¬† or some other suitable glyph.

65 64 63 62 61 60 59 58 57 66 37 36 35 34 33 32 31 56 67 38 17 16 15 14 13 30 55 68 39 18 5 4 3 12 29 54 69 40 19 6 1 2 11 28 53 70 41 20 7 8 9 10 27 52 71 42 21 22 23 24 25 26 51 72 43 44 45 46 47 48 49 50 73 74 75 76 77 78 79 80 81

61 59 37 31 67 17 13 5 3 29 19 2 11 53 41 7 71 23 43 47 73 79

‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô ‚àô

The Ulam spiral becomes more visually obvious as the grid increases in size.

Task

For any sized ¬† N x N ¬† grid, ¬† construct and show an Ulam spiral (counter-clockwise) of primes starting at some specified initial number ¬† (the default would be 1), ¬† with some suitably ¬† dotty ¬† (glyph) representation to indicate primes, ¬† and the absence of dots to indicate non-primes.

You should demonstrate the generator by showing at Ulam prime spiral large enough to (almost) fill your terminal screen.

Related tasks

¬† Spiral matrix ¬† Zig-zag matrix ¬† Identity matrix ¬† Sequence of primes by Trial Division

See also

Wikipedia entry: ¬† Ulam spiral MathWorld‚Ñ¢ entry: ¬† Prime Spiral

Translation of: Kotlin

Works with: Rust version 1.11.0

```rust
use std::fmt;
¬†
enum Direction { RIGHT, UP, LEFT, DOWN }
use ulam::Direction::*;
¬†
/// Indicates whether an integer is a prime number or not.
fn is_prime(a: u32) -> bool {
    match a {
        2 => true,
        x if x <= 1 || x¬†% 2 == 0 => false,
        _ => {
            let max = f64::sqrt(a as f64) as u32;
            let mut x =  3;
            while x <= max {
                if a¬†% x == 0 { return false; }
                x += 2;
            }
            true
        }
    }
}
¬†
pub struct Ulam { u¬†: Vec<Vec<String>> }
¬†
impl Ulam {
    /// Generates one `Ulam` object.
    pub fn new(n: u32, s: u32, c: char) -> Ulam {
        let mut spiral = vec![vec![String::new(); n as usize]; n as usize];
        let mut dir = RIGHT;
        let mut y = (n / 2) as usize;
        let mut x = if n¬†% 2 == 0 { y - 1 } else { y }; // shift left for even n's
        for j in s..n * n + s {
            spiral[y][x] = if is_prime(j) {
                if c == '\0' { format!("{:4}", j) } else { format!("  {} ", c) }
            }
            else { String::from(" ---") };
¬†
            match dir {
                RIGHT => if x as u32 <= n - 1 && spiral[y - 1][x].is_empty() && j > s { dir = UP; },
                UP => if spiral[y][x - 1].is_empty() { dir = LEFT; },
                LEFT => if x == 0 || spiral[y + 1][x].is_empty() { dir = DOWN; },
                DOWN => if spiral[y][x + 1].is_empty() { dir = RIGHT; }
            };
¬†
            match dir { RIGHT => x += 1, UP => y -= 1, LEFT => x -= 1, DOWN => y += 1 };
        }
        Ulam { u: spiral }
    }
}
¬†
impl fmt::Display for Ulam {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for row in &self.u {
            writeln!(f, "{}", format!("{:?}", row).replace("\"", "").replace(", ", ""));
        };
        writeln!(f, "")
    }
}
```

main.rs¬†:

```rust
mod ulam;
use ulam::*;
¬†
// Program entry point.
fn main() {
    print!("{}", Ulam::new(9, 1, '\0'));
    print!("{}", Ulam::new(9, 1, '*'));
}
```

Output:

```rust
[ --- --- --- ---  61 ---  59 --- ---]
[ ---  37 --- --- --- --- ---  31 ---]
[  67 ---  17 --- --- ---  13 --- ---]
[ --- --- ---   5 ---   3 ---  29 ---]
[ --- ---  19 --- ---   2  11 ---  53]
[ ---  41 ---   7 --- --- --- --- ---]
[  71 --- --- ---  23 --- --- --- ---]
[ ---  43 --- --- ---  47 --- --- ---]
[  73 --- --- --- --- ---  79 --- ---]

[ --- --- --- ---  *  ---  *  --- ---]
[ ---  *  --- --- --- --- ---  *  ---]
[  *  ---  *  --- --- ---  *  --- ---]
[ --- --- ---  *  ---  *  ---  *  ---]
[ --- ---  *  --- ---  *   *  ---  * ]
[ ---  *  ---  *  --- --- --- --- ---]
[  *  --- --- ---  *  --- --- --- ---]
[ ---  *  --- --- ---  *  --- --- ---]
[  *  --- --- --- --- ---  *  --- ---]
```

# Semiprime<a id="sec-291"></a>

Semiprime numbers are natural numbers that are products of exactly two (possibly equal) prime numbers.

Semiprimes ¬† are also known as:

¬† semi-primes ¬† biprimes ¬† bi-primes ¬† 2-almost ¬† primes ¬† or simply: ¬† P2

Example

```
1679  =  23 √ó 73  

```

(This particular number was chosen as the length of the Arecibo message).

Task;

Write a function determining whether a given number is semiprime.

See also

The Wikipedia article: ¬† semiprime. The Wikipedia article: ¬† almost prime. The OEIS article: ¬† semiprimes ¬† which has a shorter definition: the product of two primes.

```rust
extern crate primal;
¬†
fn isqrt(n: usize) -> usize {
    (n as f64).sqrt() as usize
}
¬†
fn is_semiprime(mut n: usize) -> bool {
    let root = isqrt(n) + 1;
    let primes1 = primal::Sieve::new(root);
    let mut count = 0;
¬†
    for i in primes1.primes_from(2).take_while(|&x| x < root) {
        while n¬†% i == 0 {
            n /= i;
            count += 1;
        }
        if n == 1 {
            break;
        }
    }
¬†
    if n¬†!= 1 {
        count += 1;
    }
    count == 2
}
¬†
#[test]
fn test1() {
    assert_eq!((2..10).filter(|&n| is_semiprime(n)).count(), 3);
}
¬†
#[test]
fn test2() {
    assert_eq!((2..100).filter(|&n| is_semiprime(n)).count(), 34);
}
¬†
#[test]
fn test3() {
    assert_eq!((2..1_000).filter(|&n| is_semiprime(n)).count(), 299);
}
¬†
#[test]
fn test4() {
    assert_eq!((2..10_000).filter(|&n| is_semiprime(n)).count(), 2_625);
}
¬†
#[test]
fn test5() {
    assert_eq!((2..100_000).filter(|&n| is_semiprime(n)).count(), 23_378);
}
¬†
#[test]
fn test6() {
    assert_eq!((2..1_000_000).filter(|&n| is_semiprime(n)).count(), 210_035);
}
```

Output:

```rust
running 6 tests
test test1 ... ok
test test2 ... ok
test test3 ... ok
test test4 ... ok
test test5 ... ok
test test6 ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```

# IBAN<a id="sec-292"></a>

This page uses content from Wikipedia. The original article was at IBAN. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

The ¬† International Bank Account Number (IBAN) ¬† is an internationally agreed means of identifying bank accounts across national borders with a reduced risk of propagating transcription errors.

The IBAN consists of up to 34 alphanumeric characters:

¬† first the two-letter ISO 3166-1 alpha-2 country code, ¬† then two check digits, and ¬† finally a country-specific Basic Bank Account Number (BBAN).

The check digits enable a sanity check of the bank account number to confirm its integrity even before submitting a transaction.

Task

Validate the following fictitious IBAN: ¬† GB82 WEST 1234 5698 7654 32

Details of the algorithm can be found on the Wikipedia page.

```rust
¬†
fn main() {
    for iban in [
        "",
        "x",
        "QQ82",
        "QQ82W",
        "GB82 TEST 1234 5698 7654 322",
        "gb82 WEST 1234 5698 7654 32",
        "GB82 WEST 1234 5698 7654 32",
        "GB82 TEST 1234 5698 7654 32",
        "GB81 WEST 1234 5698 7654 32",
        "SA03 8000 0000 6080 1016 7519",
        "CH93 0076 2011 6238 5295 7",
    ].iter()
    {
        println!(
            "'{}' is {}valid",
            iban,
            if validate_iban(iban) { "" } else { "NOT " }
        );
    }
}
¬†
fn validate_iban(iban: &str) -> bool {
    let iso_len = [
        ("AL", 28), ("AD", 24), ("AT", 20), ("AZ", 28), ("BE", 16), ("BH", 22),
        ("BA", 20), ("BR", 29), ("BG", 22), ("HR", 21), ("CY", 28), ("CZ", 24),
        ("DK", 18), ("DO", 28), ("EE", 20), ("FO", 18), ("FI", 18), ("FR", 27),
        ("GE", 22), ("DE", 22), ("GI", 23), ("GL", 18), ("GT", 28), ("HU", 28),
        ("IS", 26), ("IE", 22), ("IL", 23), ("IT", 27), ("KZ", 20), ("KW", 30),
        ("LV", 21), ("LB", 28), ("LI", 21), ("LT", 20), ("LU", 20), ("MK", 19),
        ("MT", 31), ("MR", 27), ("MU", 30), ("MC", 27), ("MD", 24), ("ME", 22),
        ("NL", 18), ("NO", 15), ("PK", 24), ("PS", 29), ("PL", 28), ("PT", 25),
        ("RO", 24), ("SM", 27), ("SA", 24), ("RS", 22), ("SK", 24), ("SI", 19),
        ("ES", 24), ("SE", 24), ("CH", 21), ("TN", 24), ("TR", 26), ("AE", 23),
        ("GB", 22), ("VG", 24), ("GR", 27), ("CR", 21),
    ];
    let trimmed_iban = iban.chars()
        .filter(|&ch| ch¬†!= ' ')
        .collect::<String>()
        .to_uppercase();
    if trimmed_iban.len() < 4 {
        return false;
    }
    let prefix = &trimmed_iban[0..2];
    if let Some(pair) = iso_len.iter().find(|&&(code, _)| code == prefix) {
        if pair.1¬†!= trimmed_iban.len() {
            return false;
        }
    } else {
        return false;
    }
    let reversed_iban = format!("{}{}", &trimmed_iban[4..], &trimmed_iban[0..4]);
    let mut expanded_iban = String::new();
    for ch in reversed_iban.chars() {
        expanded_iban.push_str(&if ch.is_numeric() {
            format!("{}", ch)
        } else {
            format!("{}", ch as u8 - 'A' as u8 + 10u8)
        });
    }
    expanded_iban.bytes().fold(0, |acc, ch| {
        (acc * 10 + ch as u32 - '0' as u32)¬†% 97
    }) == 1
}
¬†
```

# Singly-linked list/Traversal<a id="sec-293"></a>

Traverse from the beginning of a singly-linked list to the end.

See also

Array Associative array: Creation, Iteration Collections Compound data type Doubly-linked list: Definition, Element definition, Element insertion, Traversal Linked list Queue: Definition, Usage Set Singly-linked list: Element definition, Element insertion, Traversal Stack

Extending Singly-Linked List (element)#Rust. Please see that page for the Linked List struct declarations.

In Rust, there are three ways to pass something: by value (which forfeits ownership), by reference (there can be infinitely many immutable references to an object), or by mutable reference (there may only be one mutable reference and no other immutable ones).

The following will demonstrate iteration all three ways.

```rust
// 
//
// Iteration by value (simply empties the list as the caller now owns all values)
//
//
pub struct IntoIter<T>(List<T>);
¬†
impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        self.0.head.take().map(|node| { 
            let node = *node;
            self.0.head = node.next;
            node.elem
        })
    }
}
¬†
//
//
// Iteration by immutable reference
//
//
¬†
pub struct Iter<'a, T: 'a> {
    next: Option<&'a Node<T>>,
}
¬†
impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
    fn next(&mut self) -> Option<Self::Item> {
        self.next.take().map(|node| {
            self.next = node.next.as_ref().map(|node| &**node);
            &node.elem
        })
    }
}
¬†
//
//
// Iteration by mutable reference
//
//
¬†
pub struct IterMut<'a, T: 'a> {
    next: Option<&'a mut Node<T>>,
}
¬†
impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;
    fn next(&mut self) -> Option<Self::Item> {
        self.next.take().map(|node| {
            self.next = node.next.as_mut().map(|node| &mut **node);
            &mut node.elem
        })
    }
}
¬†
//
//
// Methods implemented for List<T>
//
//
¬†
impl<T> List<T> {
    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }
¬†
    pub fn iter<'a>(&'a self) -> Iter<'a,T> {
        Iter { next: self.head.as_ref().map(|node| &**node) }
    }
¬†
    pub fn iter_mut(&mut self) -> IterMut<T> {
        IterMut { next: self.head.as_mut().map(|node| &mut **node) }
    }
¬†
}
```

# Chinese remainder theorem<a id="sec-294"></a>

Suppose ¬† {\displaystyle n<sub>1</sub>} , ¬† {\displaystyle n<sub>2</sub>} , ¬† {\displaystyle \ldots } , ¬† {\displaystyle n<sub>k</sub>} ¬† are positive integers that are pairwise co-prime. ¬†

Then, for any given sequence of integers ¬† {\displaystyle a<sub>1</sub>} , ¬† {\displaystyle a<sub>2</sub>} , ¬† {\displaystyle &hellip; } , ¬† {\displaystyle a<sub>k</sub>} , ¬† there exists an integer ¬† {\displaystyle x} ¬† solving the following system of simultaneous congruences:

{\displaystyle {\begin{aligned}x&&equiv; a<sub>1</sub>{\pmod {n<sub>1</sub>}}\\\x&&equiv; a<sub>2</sub>{\pmod {n<sub>2</sub>}}\\\\&{}\\ \\ \vdots \\\x&&equiv; a<sub>k</sub>{\pmod {n<sub>k</sub>}}\end{aligned}}}

Furthermore, all solutions ¬† {\displaystyle x} ¬† of this system are congruent modulo the product, ¬† {\displaystyle N=n<sub>1</sub>n<sub>2</sub>\ldots n<sub>k</sub>} .

Task

Write a program to solve a system of linear congruences by applying the ¬† Chinese Remainder Theorem.

If the system of equations cannot be solved, your program must somehow indicate this.

(It may throw an exception or return a special false value.)

Since there are infinitely many solutions, the program should return the unique solution ¬† {\displaystyle s} ¬† where ¬† {\displaystyle 0&le; s&le; n<sub>1</sub>n<sub>2</sub>\ldots n<sub>k</sub>} .

Show the functionality of this program by printing the result such that the ¬† {\displaystyle n} 's ¬† are ¬† {\displaystyle [3,5,7]} ¬† and the ¬† {\displaystyle a} 's ¬† are ¬† {\displaystyle [2,3,2]} .

Algorithm: ¬† The following algorithm only applies if the ¬† {\displaystyle n<sub>i</sub>} 's ¬† are pairwise co-prime.

Suppose, as above, that a solution is required for the system of congruences:

{\displaystyle x&equiv; a<sub>i</sub>{\pmod {n<sub>i</sub>}}\quad \mathrm {for} \\;i=1,\ldots ,k}

Again, to begin, the product ¬† {\displaystyle N=n<sub>1</sub>n<sub>2</sub>\ldots n<sub>k</sub>} ¬† is defined.

Then a solution ¬† {\displaystyle x} ¬† can be found as follows:

For each ¬† {\displaystyle i} , ¬† the integers ¬† {\displaystyle n<sub>i</sub>} ¬† and ¬† {\displaystyle N/n<sub>i</sub>} ¬† are co-prime.

Using the ¬† Extended Euclidean algorithm, ¬† we can find integers ¬† {\displaystyle r<sub>i</sub>} ¬† and ¬† {\displaystyle s<sub>i</sub>} ¬† such that ¬† {\displaystyle r<sub>i</sub>n<sub>i</sub>+s<sub>i</sub>N/n<sub>i</sub>=1} .

Then, one solution to the system of simultaneous congruences is:

{\displaystyle x=&sum; \_{i=1}<sup>k</sup>a<sub>i</sub>s<sub>i</sub>N/n<sub>i</sub>}

and the minimal solution,

{\displaystyle x{\pmod {N}}} .

```rust
fn mul_inv(mut a: i32,mut b: i32)-> i32
  { let b0=b;let mut t;let mut q;
    let mut x0=0;let mut x1=1;
    if b==1
    {return 1;
    }
    while a>1
    { q=a/b;
      t=b;
      b=a%b;
      a=t;
      t=x0;
      x0=x1-q*x0;
      x1=t;
    }
    if x1<0
    {x1+=b0;
    }
    x1
  }
¬†
fn chinese_remainder(n: &mut[i32],a: &mut[i32],len: usize)->i32
  {
    let mut p=0;let mut prod=1;let mut sum=0;
    for i in 0..len
     { prod*=n[i];
     }
    for i in 0..len
     { p=prod/n[i];
       sum += a[i]*mul_inv(p, n[i])*p;
     }
    sum%prod
  }
¬†
¬†
fn main() {
¬†
    let mut n = [3,5,7];
  let mut a = [2,3,2];
  let s = a.len(); 
    println!("{}",chinese_remainder(&mut n,&mut a,s));
¬†
}
```

# Call an object method<a id="sec-295"></a>

In object-oriented programming a method is a function associated with a particular class or object. In most forms of object oriented implementations methods can be static, associated with the class itself; or instance, associated with an instance of a class.

Show how to call a static or class method, and an instance method of a class.

```rust
struct Foo;
¬†
impl Foo {
    // implementation of an instance method for struct Foo
    // returning the answer to life
    fn get_the_answer_to_life(&self) -> i32 {
        42
    }
¬†
    // implementation of a static method for struct Foo
    // returning a new instance object
    fn new() -> Foo {
        println!("Hello, world!");
        Foo // returning the new Foo object
    }
}
¬†
fn main() {
    // create the instance object foo,
    // by calling the static method new of struct Foo
    let foo = Foo::new();
¬†
    // get the answer to life 
    // by calling the instance method of object foo
    println!("The answer to life is {}.", foo.get_the_answer_to_life());
¬†
    // Note that in Rust, methods still work on references to the object.
    // Rust will automatically do the appropriate dereferencing to get the method to work:
    let lots_of_references = &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&foo;
    println!("The answer to life is still {}." lots_of_references.get_the_answer_to_life());
}
```

# Metaprogramming<a id="sec-296"></a>

Name and briefly demonstrate any support your language has for metaprogramming. Your demonstration may take the form of cross-references to other tasks on Rosetta Code. When possible, provide links to relevant documentation.

For the purposes of this task, "support for metaprogramming" means any way the user can effectively modify the language's syntax that's built into the language (like Lisp macros) or that's conventionally used with the language (like the C preprocessor). Such facilities need not be very powerful: even user-defined infix operators count. On the other hand, in general, neither operator overloading nor eval count. The task author acknowledges that what qualifies as metaprogramming is largely a judgment call.

Rust supports extensive metaprogramming via macros. Note that rust macros differ from, say, C preprocessor macros in that they are not mere text substitution (so operator precedence is preserved and name shadowing is not an issue). Here is an example from rustbyexample.com that implements and tests the +=, -`, and *` operators for Vectors.

```rust
// dry.rs
use std::ops::{Add, Mul, Sub};
¬†
macro_rules! assert_equal_len {
    // The `tt` (token tree) designator is used for
    // operators and tokens.
    ($a:ident, $b: ident, $func:ident, $op:tt) => (
        assert!($a.len() == $b.len(),
                "{:?}: dimension mismatch: {:?} {:?} {:?}",
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    )
}
¬†
macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) => (
        fn $func<T: $bound<T, Output=T> + Copy>(xs: &mut Vec<T>, ys: &Vec<T>) {
            assert_equal_len!(xs, ys, $func, $op);
¬†
            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    )
}
¬†
// Implement `add_assign`, `mul_assign`, and `sub_assign` functions.
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);
¬†
mod test {
    use std::iter;
    macro_rules! test {
        ($func: ident, $x:expr, $y:expr, $z:expr) => {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec<_> = iter::repeat($x).take(size).collect();
                    let y: Vec<_> = iter::repeat($y).take(size).collect();
                    let z: Vec<_> = iter::repeat($z).take(size).collect();
¬†
                    super::$func(&mut x, &y);
¬†
                    assert_eq!(x, z);
                }
            }
        }
    }
¬†
    // Test `add_assign`, `mul_assign` and `sub_assign`
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}
```

Output:

```rust
$ rustc --test dry.rs && ./dry
running 3 tests
test test::mul_assign ... ok
test test::add_assign ... ok
test test::sub_assign ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
```

# Forest fire<a id="sec-297"></a>

This page uses content from Wikipedia. The original article was at Forest-fire model. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Task

Implement the Drossel and Schwabl definition of the forest-fire model.

It is basically a 2D ¬† cellular automaton ¬† where each cell can be in three distinct states (empty, tree and burning) and evolves according to the following rules (as given by Wikipedia)

A burning cell turns into an empty cell A tree will burn if at least one neighbor is burning A tree ignites with probability ¬† f ¬† even if no neighbor is burning An empty space fills with a tree with probability ¬† p

Neighborhood is the ¬† Moore neighborhood; ¬† boundary conditions are so that on the boundary the cells are always empty ("fixed" boundary condition).

At the beginning, populate the lattice with empty and tree cells according to a specific probability (e.g. a cell has the probability 0.5 to be a tree). Then, let the system evolve.

Task's requirements do not include graphical display or the ability to change parameters (probabilities ¬† p ¬† and ¬† f ) ¬† through a graphical or command line interface.

Related tasks

¬† See ¬† Conway's Game of Life ¬† See ¬† Wireworld.

Inspired by the perl6 implementation, this runs in the terminal, printing a colored ASCII rendition of the forest (and it's fires!). You can configure the size of the forest, frame delay, and various probabilities.

Library: rand

Library: ansi<sub>term</sub>

```rust
extern crate rand;
extern crate ansi_term;
¬†
#[derive(Copy, Clone, PartialEq)]
enum Tile {
    Empty,
    Tree,
    Burning,
    Heating,
}
¬†
impl fmt::Display for Tile {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let output = match *self {
            Empty => Black.paint(" "),
            Tree => Green.bold().paint("T"),
            Burning => Red.bold().paint("B"),
            Heating => Yellow.bold().paint("T"),
        };
        write!(f, "{}", output)
    }
}
¬†
// This has been added to the nightly rust build as of March 24, 2016
// Remove when in stable branch!
trait Contains<T> {
    fn contains(&self, T) -> bool;
}
¬†
impl<T: PartialOrd> Contains<T> for std::ops::Range<T> {
    fn contains(&self, elt: T) -> bool {
        self.start <= elt && elt < self.end
    }
}
¬†
const NEW_TREE_PROB: f32 = 0.01;
const INITIAL_TREE_PROB: f32 = 0.5;
const FIRE_PROB: f32 = 0.001;
¬†
const FOREST_WIDTH: usize = 60;
const FOREST_HEIGHT: usize = 30;
¬†
const SLEEP_MILLIS: u64 = 25;
¬†
use std::fmt;
use std::io;
use std::io::prelude::*;
use std::io::BufWriter;
use std::io::Stdout;
use std::process::Command;
use std::time::Duration;
use rand::Rng;
use ansi_term::Colour::*;
¬†
use Tile::{Empty, Tree, Burning, Heating};
¬†
fn main() {
    let sleep_duration = Duration::from_millis(SLEEP_MILLIS);
    let mut forest = [[Tile::Empty; FOREST_WIDTH]; FOREST_HEIGHT];
¬†
    prepopulate_forest(&mut forest);
    print_forest(forest, 0);
¬†
    std::thread::sleep(sleep_duration);
¬†
    for generation in 1.. {
¬†
        for row in forest.iter_mut() {
            for tile in row.iter_mut() {
                update_tile(tile);
            }
        }
¬†
        for y in 0..FOREST_HEIGHT {
            for x in 0..FOREST_WIDTH {
                if forest[y][x] == Burning {
                    heat_neighbors(&mut forest, y, x);
                }
            }
        }
¬†
        print_forest(forest, generation);
¬†
        std::thread::sleep(sleep_duration);
    }
}
¬†
fn prepopulate_forest(forest: &mut [[Tile; FOREST_WIDTH]; FOREST_HEIGHT]) {
    for row in forest.iter_mut() {
        for tile in row.iter_mut() {
            *tile = if prob_check(INITIAL_TREE_PROB) {
                Tree
            } else {
                Empty
            };
        }
    }
}
¬†
fn update_tile(tile: &mut Tile) {
    *tile = match *tile {
        Empty => {
            if prob_check(NEW_TREE_PROB) == true {
                Tree
            } else {
                Empty
            }
        }
        Tree => {
            if prob_check(FIRE_PROB) == true {
                Burning
            } else {
                Tree
            }
        }
        Burning => Empty,
        Heating => Burning,
    }
}
¬†
fn heat_neighbors(forest: &mut [[Tile; FOREST_WIDTH]; FOREST_HEIGHT], y: usize, x: usize) {
    let neighbors = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)];
¬†
    for &(xoff, yoff) in neighbors.iter() {
        let nx: i32 = (x as i32) + xoff;
        let ny: i32 = (y as i32) + yoff;
        if (0..FOREST_WIDTH as i32).contains(nx) && (0..FOREST_HEIGHT as i32).contains(ny) &&
           forest[ny as usize][nx as usize] == Tree {
            forest[ny as usize][nx as usize] = Heating
        }
    }
}
¬†
fn prob_check(chance: f32) -> bool {
    let roll = rand::thread_rng().gen::<f32>();
    if chance - roll > 0.0 {
        true
    } else {
        false
    }
}
¬†
fn print_forest(forest: [[Tile; FOREST_WIDTH]; FOREST_HEIGHT], generation: u32) {
    let mut writer = BufWriter::new(io::stdout());
    clear_screen(&mut writer);
    writeln!(writer, "Generation: {}", generation + 1).unwrap();
    for row in forest.iter() {
        for tree in row.iter() {
            write!(writer, "{}", tree).unwrap();
        }
        writer.write(b"\n").unwrap();
    }
}
¬†
fn clear_screen(writer: &mut BufWriter<Stdout>) {
    let output = Command::new("clear").output().unwrap();
    write!(writer, "{}", String::from_utf8_lossy(&output.stdout)).unwrap();
}
¬†
```

# Constrained random points on a circle<a id="sec-298"></a>

Task

Generate 100 <x,y> coordinate pairs such that x and y are integers sampled from the uniform distribution with the condition that

{\displaystyle 10&le; {\sqrt {x<sup>2</sup>+y<sup>2</sup>}}&le; 15} . Then display/plot them. The outcome should be a "fuzzy" circle. The actual number of points plotted may be less than 100, given that some pairs may be generated more than once.

There are several possible approaches to accomplish this. Here are two possible algorithms.

1.  Generate random pairs of integers and filter out those that don't satisfy this condition:

{\displaystyle 10&le; {\sqrt {x<sup>2</sup>+y<sup>2</sup>}}&le; 15} .

1.  Precalculate the set of all possible points (there are 404 of them) and select randomly from this set.

```rust
#![feature(inclusive_range_syntax)]
¬†
extern crate rand;
¬†
use rand::Rng;
¬†
const POINTS_N: usize = 100;
¬†
fn generate_point<R: Rng>(rng: &mut R) -> (i32, i32) {
    loop {
        let x = rng.gen_range(-15, 16); // exclusive
        let y = rng.gen_range(-15, 16);
¬†
        let r2 = x * x + y * y;
        if r2 >= 100 && r2 <= 225 {
            return (x, y);
        }
    }
}
¬†
fn filtering_method<R: Rng>(rng: &mut R) {
    let mut rows = [[" "; 62]; 31];
¬†
    // Generate points
    for _ in 0..POINTS_N {
        let (x, y) = generate_point(rng);
        rows[(y + 15) as usize][(x + 15) as usize * 2] = "*";
    }
¬†
    // draw the points
    for row in &rows {
        println!("{}", row.concat());
    }
}
¬†
fn precalculating_method<R: Rng>(rng: &mut R) {
    // Generate all possible points
    let mut possible_points = Vec::with_capacity(404);
    for y in -15..=15 {
        for x in -15..=15 {
            let r2 = x * x + y * y;
            if r2 >= 100 && r2 <= 225 {
                possible_points.push((x, y));
            }
        }
    }
¬†
    // A truncated Fisher-Yates shuffle
    let len = possible_points.len();
    for i in (len - POINTS_N..len).rev() {
        let j = rng.gen_range(0, i + 1);
        possible_points.swap(i, j);
    }
¬†
    // turn the selected points into "pixels"
    let mut rows = [[" "; 62]; 31];
    for &(x, y) in &possible_points[len - POINTS_N..] {
        rows[(y + 15) as usize][(x + 15) as usize * 2] = "*";
    }
¬†
    // draw the "pixels"
    for row in &rows {
        println!("{}", row.concat());
    }
}
¬†
fn main() {
    let mut rng = rand::weak_rng();
¬†
    filtering_method(&mut rng);
¬†
    precalculating_method(&mut rng);
}
```

# Department Numbers<a id="sec-299"></a>

There is a highly organized city that has decided to assign a number to each of their departments:

¬† police department ¬† sanitation department ¬† fire department

Each department can have a number between 1 and 7 ¬† (inclusive).

The three department numbers are to be unique (different from each other) and must add up to the number 12.

The Chief of the Police doesn't like odd numbers and wants to have an even number for his department.

Task

Write a program which outputs all valid combinations.

Possible output:

1 2 9 5 3 4

Translation of: C

```rust
¬†
extern crate num_iter;
¬†
fn main()
{
  println!("Police Sanitation Fire");
  println!("----------------------");
¬†
  for police in num_iter::range_step(2,7,2){
    for sanitation in 1..8 {
      for fire in 1..8 {
        if police!=sanitation && sanitation!=fire && fire!=police && police+fire+sanitation==12 {
          println!("{:6}{:11}{:4}",police,sanitation,fire);
        }
      }
    }
  }
¬†
}
¬†
```

# Read a specific line from a file<a id="sec-300"></a>

Some languages have special semantics for obtaining a known line number from a file.

Task

Demonstrate how to obtain the contents of a specific line within a file.

For the purpose of this task demonstrate how the contents of the seventh line of a file can be obtained, and store it in a variable or in memory (for potential future use within the program if the code were to become embedded). If the file does not contain seven lines, or the seventh line is empty, or too big to be retrieved, output an appropriate message. If no special semantics are available for obtaining the required line, it is permissible to read line by line. Note that empty lines are considered and should still be counted. Note that for functional languages or languages without variables or storage, it is permissible to output the extracted data to standard output.

```rust
use std::fs::File;
use std::io::BufRead;
use std::io::BufReader;
use std::io::Error;
use std::path::Path;
¬†
fn main() {
    let path = Path::new("file.txt");
    let line_num = 7usize;
    let line = get_line_at(&path, line_num - 1);
    println!("{}", line.unwrap());
}
¬†
fn get_line_at(path: &Path, line_num: usize) -> Result<String, Error> {
    let file = File::open(path).expect("File not found or cannot be opened");
    let content = BufReader::new(&file);
    let mut lines = content.lines();
    lines.nth(line_num).expect("No line found at that position")
}
```

Alternate implementation with argument parsing. First argument is the path to the file and is required. Second argument is the line number and is optional. By default the first line will be printed.

```rust
use std::env;
use std::fs::File;
use std::io::BufRead;
use std::io::BufReader;
use std::path::Path;
¬†
fn main() {
    if env::args().len() <= 1 {
        println!("At least a path to a file is needed: No file path given");
        return;
    } else {
        let path = &env::args().nth(1).expect("could not parse the path");
        let path = Path::new(&path);
        let mut line_num = 1usize;
        if let Some(arg) = env::args().nth(2) {
            line_num = arg.parse::<usize>().expect("Parsing line number failed");
        }
        print_line_at(&path, line_num);
    }
}
¬†
fn print_line_at(path: &Path, line_num: usize) {
    if line_num < 1 {
        panic!("Line number has to be > 0");
    }
    let line_num = line_num - 1;
    let file = File::open(path).expect("File not found or cannot be opened");
    let content = BufReader::new(&file);
    let mut lines = content.lines();
    let line = lines.nth(line_num).expect("No line found at given position");
    println!("{}", line.expect("None line"));
}
```

# Dutch national flag problem<a id="sec-301"></a>

The Dutch national flag is composed of three coloured bands in the order red then white and lastly blue. The problem posed by Edsger Dijkstra is:

Given a number of red, blue and white balls in random order, arrange them in the order of the colours Dutch national flag.

When the problem was first posed, Dijkstra then went on to successively refine a solution, minimising the number of swaps and the number of times the colour of a ball needed to determined and restricting the balls to end in an array, &#x2026;

Task

Generate a randomized order of balls ensuring that they are not in the order of the Dutch national flag. Sort the balls in a way idiomatic to your language. Check the sorted balls are in the order of the Dutch national flag.

C.f.

Dutch national flag problem Probabilistic analysis of algorithms for the Dutch national flag problem by Wei-Mei Chen. (pdf)

Library: rand

```rust
extern crate rand;
¬†
use rand::Rng;
¬†
// Color enums will be sorted by their top-to-bottom declaration order
#[derive(Eq,Ord,PartialOrd,PartialEq,Debug)]
enum Color {
    Red,
    White,
    Blue
}
¬†
fn is_sorted(list: &Vec<Color>) -> bool {
    let mut state = &Color::Red;
    for current in list.iter() {
        if current < state { return false; }
        if current > state { state = current; }
    }
    true
}
¬†
¬†
fn main() {
    let mut rng = rand::thread_rng();
    let mut colors: Vec<Color> = Vec::new();
¬†
    for _ in 1..10 {
        let r = rng.gen_range(0, 3);
        if      r == 0 { colors.push(Color::Red); }
        else if r == 1 { colors.push(Color::White); }
        else if r == 2 { colors.push(Color::Blue); }
    }
¬†
    while is_sorted(&colors) {
        rng.shuffle(&mut colors);
    }
¬†
    println!("Before: {:?}", colors);
    colors.sort();
    println!("After:  {:?}", colors);
    if¬†!is_sorted(&colors) {
        println!("Oops, did not sort colors correctly!");
    }
}
```

# Two Sum<a id="sec-302"></a>

Task

Given a sorted array of integers (with possibly duplicates), is it possible to find a pair of integers from that array that sum up to a given sum? If so, return indices of the two integers or an empty array if not. The solution is not necessarily unique.

Example

Given numbers = [0, 2, 11, 19, 90], sum = 21, Because numbers[1] + numbers[3] = 2 + 19 = 21, return [1, 3].

Source

Stack Overflow: Find pair of numbers in array that add to given sum

```rust
use std::cmp::Ordering;
use std::ops::Add;
¬†
fn two_sum<T>(arr: &[T], sum: T) -> Option<(usize, usize)>
where
    T: Add<Output = T> + Ord + Copy,
{
    if arr.len() == 0 {
        return None;
    }
¬†
    let mut i = 0;
    let mut j = arr.len() - 1;
¬†
    while i < j {
        match (arr[i] + arr[j]).cmp(&sum) {
            Ordering::Equal => return Some((i, j)),
            Ordering::Less => i += 1,
            Ordering::Greater => j -= 1,
        }
    }
¬†
    None
}
¬†
fn main() {
    let arr = [0, 2, 11, 19, 90];
    let sum = 21;
¬†
    println!("{:?}", two_sum(&arr, sum));
}
```

Output:

```rust
Some((1, 3))

```

# Execute Brain\*\*\*\*<a id="sec-303"></a>

RCBF is a set of Brainf\*\*\* compilers and interpreters written for Rosetta Code in a variety of languages.

Below are links to each of the versions of RCBF.

An implementation need only properly implement the following instructions:

Command Description > Move the pointer to the right < Move the pointer to the left

-   Increment the memory cell under the pointer
-   Decrement the memory cell under the pointer

. Output the character signified by the cell at the pointer , Input a character and store it in the cell at the pointer [ Jump past the matching ] if the cell under the pointer is 0 ] Jump back to the matching [ if the cell under the pointer is nonzero

Any cell size is allowed, ¬† EOF ¬† (End-O-File) ¬† support is optional, as is whether you have bounded or unbounded memory.

```rust
use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::io::prelude::*;
use std::io::stdin;
use std::num::Wrapping;
¬†
fn main() {
    let args: Vec<_> = env::args().collect();
    if args.len() < 2 {
        println!("Usage: {} [path] (--debug)", args[0]);
        return;
    }
¬†
    let src: Vec<char> = {
        let mut buf = String::new();
        match File::open(&args[1])
        {
            Ok(mut f) => { f.read_to_string(&mut buf).unwrap(); }
            Err(e)    => {
                println!("Error opening '{}': {}", args[1], e);
                return;
            }
        }
¬†
        buf.chars().collect()
    };
¬†
    // Launch options
    let debug = args.contains(&"--debug".to_owned());
¬†
    // One pass to find bracket pairs.
    let brackets: HashMap<usize, usize> = {
        let mut m = HashMap::new();
        let mut scope_stack = Vec::new();
        for (idx, ch) in src.iter().enumerate() {
            match ch {
                &'[' => { scope_stack.push(idx); }
                &']' => { m.insert(scope_stack.pop().unwrap(), idx); }
                _    => { /* ignore */ }
            }
        }
¬†
        m
    };
¬†
    let mut pc: usize = 0;                                  // Program counter
    let mut mem: [Wrapping<u8>;5000] = [Wrapping(0);5000];  // Program cemory
    let mut ptr: usize = 0;                                 // Pointer
    let mut stack: Vec<usize> = Vec::new();                 // Bracket stack
¬†
    let stdin_ = stdin();
    let mut reader = stdin_.lock().bytes();
    while pc < src.len() {
        let Wrapping(val) = mem[ptr];
¬†
        if debug {
            println!("(BFDB) PC: {:04} \tPTR: {:04} \t$PTR: {:03} \tSTACK_DEPTH: {} \tSYMBOL: {}", pc, ptr, val, stack.len(), src[pc]);
        }
¬†
        const ONE: Wrapping<u8> = Wrapping(1);
        match src[pc] {
            '>' => { ptr += 1; }
            '<' => { ptr -= 1; }
¬†
            '+' => { mem[ptr] = mem[ptr] + ONE; }
            '-' => { mem[ptr] = mem[ptr] - ONE; }
¬†
            '[' => {
                if val == 0 {
                    pc = brackets[&pc];
                } else {
                    stack.push(pc);
                }
            }
            ']' => {
                let matching_bracket = stack.pop().unwrap();
                if val¬†!= 0 {
                    pc = matching_bracket - 1;
                }
            }
¬†
            '.' => {
                if debug {
                    println!("(BFDB) STDOUT: '{}'", val as char);  // Intercept output
                } else {
                    print!("{}", val as char);
                }
            }
            ',' => {
                mem[ptr] = Wrapping(reader.next().unwrap().unwrap());
            }
¬†
            _   => { /* ignore */ }
        }
¬†
        pc += 1;
    }
}
```

# Statistics/Basic<a id="sec-304"></a>

Statistics is all about large groups of numbers. When talking about a set of sampled data, most frequently used is their mean value and standard deviation (stddev). If you have set of data {\displaystyle x<sub>i</sub>} where {\displaystyle i=1,2,\ldots ,n\\,\\!} , the mean is {\displaystyle {\bar {x}}&equiv; {1 \over n}&sum; \_{i}x<sub>i</sub>} , while the stddev is {\displaystyle &sigma; &equiv; {\sqrt {{1 \over n}&sum; \_{i}\left(x<sub>i</sub>-{\bar {x}}\right)<sup>2</sup>}}} .

When examining a large quantity of data, one often uses a histogram, which shows the counts of data samples falling into a prechosen set of intervals (or bins). When plotted, often as bar graphs, it visually indicates how often each data value occurs.

Task Using your language's random number routine, generate real numbers in the range of [0, 1]. It doesn't matter if you chose to use open or closed range. Create 100 of such numbers (i.e. sample size 100) and calculate their mean and stddev. Do so for sample size of 1,000 and 10,000, maybe even higher if you feel like. Show a histogram of any of these sets. Do you notice some patterns about the standard deviation?

Extra Sometimes so much data need to be processed that it's impossible to keep all of them at once. Can you calculate the mean, stddev and histogram of a trillion numbers? (You don't really need to do a trillion numbers, just show how it can be done.)

Hint

For a finite population with equal probabilities at all points, one can derive:

{\displaystyle {\overline {(x-{\overline {x}})<sup>2</sup>}}={\overline {x<sup>2</sup>}}-{\overline {x}}<sup>2</sup>}

Or, more verbosely:

{\displaystyle {\frac {1}{N}}&sum; \_{i=1}<sup>N</sup>(x<sub>i</sub>-{\overline {x}})<sup>2</sup>={\frac {1}{N}}\left(&sum; \_{i=1}<sup>N</sup>x<sub>i</sub><sup>2</sup>\right)-{\overline {x}}<sup>2</sup>.}

See also

Statistics/Normal distribution

Tasks for calculating statistical measures

in one go moving (sliding window) moving (cumulative) Mean Arithmetic Statistics/Basic Averages/Arithmetic mean Averages/Pythagorean means

Averages/Simple moving average

Geometric Averages/Pythagorean means

Harmonic Averages/Pythagorean means

Quadratic Averages/Root mean square

Circular Averages/Mean angle Averages/Mean time of day

Median Averages/Median

Mode Averages/Mode

Standard deviation Statistics/Basic

Cumulative standard deviation

Library: rand

```rust
#![feature(iter_arith)]
extern crate rand;
¬†
use rand::distributions::{IndependentSample, Range};
¬†
pub fn mean(data: &[f32]) -> Option<f32> {
    if data.is_empty() {
        None
    } else {
        let sum: f32 = data.iter().sum();
        Some(sum / data.len() as f32)
    }
}
¬†
pub fn variance(data: &[f32]) -> Option<f32> {
    if data.is_empty() {
        None
    } else {
        let mean = mean(data).unwrap();
        let mut sum = 0f32;
        for &x in data {
            sum += (x - mean).powi(2);
        }
        Some(sum / data.len() as f32)
    }
}
¬†
pub fn standard_deviation(data: &[f32]) -> Option<f32> {
    if data.is_empty() {
        None
    } else {
        let variance = variance(data).unwrap();
        Some(variance.sqrt())
    }
}
¬†
fn print_histogram(width: u32, data: &[f32]) {
    let mut histogram = [0; 10];
    let len = histogram.len() as f32;
    for &x in data {
        histogram[(x * len) as usize] += 1;
    }
    let max_frequency = *histogram.iter().max().unwrap() as f32;
    for (i, &frequency) in histogram.iter().enumerate() {
        let bar_width = frequency as f32 * width as f32 / max_frequency;
        print!("{:3.1}: ", i as f32 / len);
        for _ in 0..bar_width as usize {
            print!("*");
        }
        println!("");
    }
}
¬†
fn main() {
    let range = Range::new(0f32, 1f32);
    let mut rng = rand::thread_rng();
¬†
    for &number_of_samples in [1000, 10_000, 1_000_000].iter() {
        let mut data = vec![];
        for _ in 0..number_of_samples {
            let x = range.ind_sample(&mut rng);
            data.push(x);
        }
        println!("  Statistics for sample size {}", number_of_samples);
        println!("Mean:               {:?}", mean(&data));
        println!("Variance:           {:?}", variance(&data));
        println!("Standard deviation: {:?}", standard_deviation(&data));
        print_histogram(40, &data);
    }
}
```

Output:

```rust
  Statistics for sample size 1000
Mean:               Some(0.50145197)
Variance:           Some(0.08201705)
Standard deviation: Some(0.2863862)
0.0: *********************************
0.1: ****************************
0.2: **********************************
0.3: ************************************
0.4: **************************************
0.5: *********************************
0.6: ******************************
0.7: ******************************
0.8: ****************************************
0.9: ******************************
  Statistics for sample size 10000
Mean:               Some(0.49700406)
Variance:           Some(0.08357173)
Standard deviation: Some(0.28908777)
0.0: **************************************
0.1: ***************************************
0.2: ***************************************
0.3: ***************************************
0.4: ***********************************
0.5: ***************************************
0.6: *************************************
0.7: ****************************************
0.8: **************************************
0.9: *************************************
  Statistics for sample size 1000000
Mean:               Some(0.50038373)
Variance:           Some(0.08325759)
Standard deviation: Some(0.2885439)
0.0: ***************************************
0.1: ***************************************
0.2: ***************************************
0.3: ****************************************
0.4: ***************************************
0.5: ***************************************
0.6: ***************************************
0.7: ***************************************
0.8: ***************************************
0.9: ***************************************
```

# Remove lines from a file<a id="sec-305"></a>

Task

Remove a specific line or a number of lines from a file.

This should be implemented as a routine that takes three parameters (filename, starting line, and the number of lines to be removed).

For the purpose of this task, line numbers and the number of lines start at one, so to remove the first two lines from the file foobar.txt, the parameters should be: foobar.txt, 1, 2

Empty lines are considered and should still be counted, and if the specified line is empty, it should still be removed.

An appropriate message should appear if an attempt is made to remove lines beyond the end of the file.

```rust
extern crate rustc_serialize;
extern crate docopt;
¬†
use docopt::Docopt;
¬†
use std::io::{BufReader,BufRead};
use std::fs::File;
¬†
const USAGE: &'static str = "
Usage: rosetta <start> <count> <file>
";
¬†
#[derive(Debug, RustcDecodable)]
struct Args {
    arg_start: usize,
    arg_count: usize,
    arg_file: String,
}
¬†
fn main() {
    let args: Args = Docopt::new(USAGE)
        .and_then(|d| d.decode())
        .unwrap_or_else(|e| e.exit());
¬†
    let file = BufReader::new(File::open(args.arg_file).unwrap());
¬†
    for (i, line) in file.lines().enumerate() {
        let cur = i + 1;
¬†
        if cur < args.arg_start || cur >= (args.arg_start + args.arg_count) {
            println!("{}", line.unwrap());
        }
    }
}
```

# Left factorials<a id="sec-306"></a>

Left factorials, ¬† !n, ¬† may refer to either ¬† subfactorials ¬† or to ¬† factorial sums; the same notation can be confusingly seen used for the two different definitions.

Sometimes, ¬† subfactorials ¬† (also known as derangements) ¬† may use any of the notations:

¬† !n\` ¬† !n ¬† n¬°

(It may not be visually obvious, but the last example uses an upside-down exclamation mark.)

This Rosetta Code task will be using this formula for left factorial:

¬† {\displaystyle !n=&sum; \_{k=0}<sup>n-1</sup>k!}

where

¬† {\displaystyle !0=0}

Task

Display the left factorials for:

zero through ten (inclusive) 20 through 110 (inclusive) by tens

Display the length (in decimal digits) of the left factorials for:

1,000, ¬† 2,000 ¬† through ¬† 10,000 ¬† (inclusive), by thousands.

Also see

¬† The OEIS entry: A003422 left factorials ¬† The MathWorld entry: left factorial ¬† The MathWorld entry: factorial sums ¬† The MathWorld entry: subfactorial

Related task

¬† permutations/derangements (subfactorials)

```rust
¬†
#[cfg(target_pointer_width = "64")]
type USingle = u32;
#[cfg(target_pointer_width = "64")]
type UDouble = u64;
#[cfg(target_pointer_width = "64")]
const WORD_LEN: i32 = 32;
¬†
#[cfg(not(target_pointer_width = "64"))]
type USingle = u16;
#[cfg(not(target_pointer_width = "64"))]
type UDouble = u32;
#[cfg(not(target_pointer_width = "64"))]
const WORD_LEN: i32 = 16;
¬†
use std::cmp;
¬†
#[derive(Debug,Clone)]
struct BigNum {
    // rep_.size() == 0 if and only if the value is zero.
    // Otherwise, the word rep_[0] keeps the least significant bits.
    rep_: Vec<USingle>,
}
¬†
impl BigNum {
    pub fn new(n: USingle) -> BigNum {
        let mut result = BigNum { rep_: vec![] };
        if n > 0 { result.rep_.push(n); }
        result
    }
    pub fn equals(&self, n: USingle) -> bool {
        if n == 0 { return self.rep_.is_empty() }
        if self.rep_.len() > 1 { return false }
        self.rep_[0] == n
    }
    pub fn add_big(&self, addend: &BigNum) -> BigNum {
        let mut result = BigNum::new(0);
        let mut sum = 0 as UDouble;
        let sz1 = self.rep_.len();
        let sz2 = addend.rep_.len();
        for i in 0..cmp::max(sz1, sz2) {
            if i < sz1 { sum += self.rep_[i] as UDouble }
            if i < sz2 { sum += addend.rep_[i] as UDouble }
            result.rep_.push(sum as USingle);
            sum >>= WORD_LEN;
        }
        if sum > 0 { result.rep_.push(sum as USingle) }
        result
    }
    pub fn multiply(&self, factor: USingle) -> BigNum {
        let mut result = BigNum::new(0);
        let mut product = 0 as UDouble;
        for i in 0..self.rep_.len() {
            product += self.rep_[i] as UDouble * factor as UDouble;
            result.rep_.push(product as USingle);
            product >>= WORD_LEN;
        }
        if product > 0 {
            result.rep_.push(product as USingle);
        }
        result
    }
    pub fn divide(&self, divisor: USingle, quotient: &mut BigNum,
        remainder: &mut USingle) {
        quotient.rep_.truncate(0);
        let mut dividend: UDouble;
        *remainder = 0;
        for i in 0..self.rep_.len() {
            let j = self.rep_.len() - 1 - i;
            dividend = ((*remainder as UDouble) << WORD_LEN)
                + self.rep_[j] as UDouble;
            let quo = (dividend / divisor as UDouble) as USingle;
            *remainder = (dividend¬†% divisor as UDouble) as USingle;
            if quo > 0 || j < self.rep_.len() - 1 {
                quotient.rep_.push(quo);
            }
        }
        quotient.rep_.reverse();
    }
    fn to_string(&self) -> String {
        let mut rep = String::new();
        let mut dividend = (*self).clone();
        let mut remainder = 0 as USingle;
        let mut quotient = BigNum::new(0);
        loop {
            dividend.divide(10, &mut quotient, &mut remainder);
            rep.push(('0' as USingle + remainder) as u8 as char);
            if quotient.equals(0) { break; }
            dividend = quotient.clone();
        }
        rep.chars().rev().collect::<String>()
    }
}
¬†
use std::fmt;
impl fmt::Display for BigNum {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.to_string())
    }
}
¬†
fn lfact(n: USingle) -> BigNum {
    let mut result = BigNum::new(0);
    let mut f = BigNum::new(1);
    for k in 1 as USingle..n + 1 {
        result = result.add_big(&f);
        f = f.multiply(k);
    }
    result
}
¬†
fn main() {
    for i in 0..11 {
        println!("!{} = {}", i, lfact(i));
    }
    for i in 2..12 {
        let j = i * 10;
        println!("!{} = {}", j, lfact(j));
    }
    for i in 1..11 {
        let j = i * 1000;
        println!("!{} has {} digits.", j, lfact(j).to_string().len());
    }
}
¬†
```

Output:

```rust
!0 = 0
!1 = 1
!2 = 2
!3 = 4
!4 = 10
!5 = 34
!6 = 154
!7 = 874
!8 = 5914
!9 = 46234
!10 = 409114
!20 = 128425485935180314
!30 = 9157958657951075573395300940314
!40 = 20935051082417771847631371547939998232420940314
!50 = 620960027832821612639424806694551108812720525606160920420940314
!60 = 141074930726669571000530822087000522211656242116439949000980378746128920420940314
!70 = 173639511802987526699717162409282876065556519849603157850853034644815111221599509216528920420940314
!80 = 906089587987695346534516804650290637694024830011956365184327674619752094289696314882008531991840922336528920420940314
!90 = 16695570072624210767034167688394623360733515163575864136345910335924039962404869510225723072235842668787507993136908442336528920420940314
!100 = 942786239765826579160595268206839381354754349601050974345395410407078230249590414458830117442618180732911203520208889371641659121356556442336528920420940314
!110 = 145722981061585297004706728001906071948635199234860720988658042536179281328615541936083296163475394237524337422204397431927131629058103519228197429698252556442336528920420940314
!1000 has 2565 digits.
!2000 has 5733 digits.
!3000 has 9128 digits.
!4000 has 12670 digits.
!5000 has 16322 digits.
!6000 has 20062 digits.
!7000 has 23875 digits.
!8000 has 27749 digits.
!9000 has 31678 digits.
!10000 has 35656 digits.

```

# Rock-paper-scissors<a id="sec-307"></a>

Task

Implement the classic children's game Rock-paper-scissors, as well as a simple predictive ¬† AI ¬† (artificial intelligence) ¬† player.

Rock Paper Scissors is a two player game.

Each player chooses one of rock, paper or scissors, without knowing the other player's choice.

The winner is decided by a set of rules:

¬† Rock beats scissors ¬† Scissors beat paper ¬† Paper beats rock

If both players choose the same thing, there is no winner for that round.

For this task, the computer will be one of the players.

The operator will select Rock, Paper or Scissors and the computer will keep a record of the choice frequency, and use that information to make a weighted random choice in an attempt to defeat its opponent.

Extra credit

Support additional choices ¬† additional weapons.

```rust
extern crate rand;
#[macro_use]
extern crate rand_derive;
¬†
use std::io;
use rand::Rng;
use Choice::*;
¬†
#[derive(PartialEq, Clone, Copy, Rand, Debug)]
enum Choice {
    Rock,
    Paper,
    Scissors,
}
¬†
fn beats(c1: Choice, c2: Choice) -> bool {
    (c1 == Rock && c2 == Scissors) || (c1 == Scissors && c2 == Paper) || (c1 == Paper && c2 == Rock)
}
¬†
fn ai_move<R: Rng>(rng: &mut R, v: [usize; 3]) -> Choice {
    // weighted random choice, a dynamic version of `rand::distributions::WeightedChoice`
    let rand = rng.gen_range(0, v[0] + v[1] + v[2]);
    if rand < v[0] {
        Paper
    } else if rand < v[0] + v[1] {
        Scissors
    } else {
        Rock
    }
}
¬†
fn main() {
    let mut rng = rand::thread_rng();
¬†
    println!("Rock, paper, scissors!");
    let mut ai_choice: Choice = rng.gen();
    let mut ucf = [0, 0, 0]; // user choice frequency
    let mut score = [0, 0];
¬†
    loop {
        println!("Please input your move: 'r', 'p' or 's'. Type 'q' to quit");
¬†
        let mut input = String::new();
        io::stdin()
            .read_line(&mut input)
            .expect("failed to read line");
        let u_choice = match input.to_lowercase().trim() {
            s if s.starts_with('r') => {
                ucf[0] += 1;
                Rock
            }
            s if s.starts_with('p') => {
                ucf[1] += 1;
                Paper
            }
            s if s.starts_with('s') => {
                ucf[2] += 1;
                Scissors
            }
            s if s.starts_with('q') => break,
            _ => {
                println!("Please enter a correct choice!");
                continue;
            }
        };
        println!("You chose {:?}, I chose {:?}.", u_choice, ai_choice);
        if beats(u_choice, ai_choice) {
            score[0] += 1;
            println!("You win!");
        } else if u_choice == ai_choice {
            println!("It's a tie!");
        } else {
            score[1] += 1;
            println!("I win!");
        }
        println!("-Score: You {}, Me {}", score[0], score[1]);
¬†
        // only after the 1st iteration the AI knows the stats and can make
        // its weighted random move
        ai_choice = ai_move(&mut rng, ucf);
    }
    println!("Thank you for the game!");
}
```

# Circles of given radius through two points<a id="sec-308"></a>

Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points.

Exceptions

r==0.0 should be treated as never describing circles (except in the case where the points are coincident). If the points are coincident then an infinite number of circles with the point on their circumference can be drawn, unless r==0.0 as well which then collapses the circles to a point. If the points form a diameter then return two identical circles or return a single circle, according to which is the most natural mechanism for the implementation language. If the points are too far apart then no circles can be drawn.

Task detail

Write a function/subroutine/method/&#x2026; that takes two points and a radius and returns the two circles through those points, or some indication of special cases where two, possibly equal, circles cannot be returned. Show here the output for the following inputs:

```
      p1                p2           r
0.1234, 0.9876    0.8765, 0.2345    2.0
0.0000, 2.0000    0.0000, 0.0000    1.0
0.1234, 0.9876    0.1234, 0.9876    2.0
0.1234, 0.9876    0.8765, 0.2345    0.5
0.1234, 0.9876    0.1234, 0.9876    0.0

```

Related task

¬† Total circles area.

See also

¬† Finding the Center of a Circle from 2 Points and Radius from Math forum @ Drexel

Translation of: C

```rust
use std::fmt;
¬†
#[derive(Clone,Copy)]
struct Point {
    x: f64,
    y: f64
}
¬†
fn distance (p1: Point, p2: Point) -> f64 {
    ((p1.x - p2.x).powi(2) + (p1.y - p2.y).powi(2)).sqrt()
}
¬†
impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({:.4}, {:.4})", self.x, self.y)
    }
}
¬†
fn describe_circle(p1: Point, p2: Point, r: f64) {
    let sep = distance(p1, p2);
¬†
    if sep == 0. {
        if r == 0. {
            println!("No circles can be drawn through {}", p1);
        } else {
            println!("Infinitely many circles can be drawn through {}", p1);
        }
    } else if sep == 2.0 * r {
        println!("Given points are opposite ends of a diameter of the circle with center ({:.4},{:.4}) and r {:.4}",
                (p1.x+p2.x) / 2.0, (p1.y+p2.y) / 2.0, r);
    } else if sep > 2.0 * r {
        println!("Given points are farther away from each other than a diameter of a circle with r {:.4}", r);
    } else {
        let mirror_dist = (r.powi(2) - (sep / 2.0).powi(2)).sqrt();
¬†
        println!("Two circles are possible.");
        println!("Circle C1 with center ({:.4}, {:.4}), r {:.4} and Circle C2 with center ({:.4}, {:.4}), r {:.4}",
                ((p1.x + p2.x) / 2.0) + mirror_dist * (p1.y-p2.y)/sep, (p1.y+p2.y) / 2.0 + mirror_dist*(p2.x-p1.x)/sep,
                r,
                (p1.x+p2.x) / 2.0 - mirror_dist*(p1.y-p2.y)/sep, (p1.y+p2.y) / 2.0 - mirror_dist*(p2.x-p1.x)/sep, r);
    }
}
¬†
fn main() {
    let points: Vec<(Point, Point)> = vec![
        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.8765, y: 0.2345 }),
        (Point { x: 0.0000, y: 2.0000 }, Point { x: 0.0000, y: 0.0000 }),
        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.1234, y: 0.9876 }),
        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.8765, y: 0.2345 }),
        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.1234, y: 0.9876 })
    ];
    let radii: Vec<f64> = vec![2.0, 1.0, 2.0, 0.5, 0.0];
¬†
    for (p, r) in points.into_iter().zip(radii.into_iter()) {
        println!("\nPoints: ({}, {}), Radius: {:.4}", p.0, p.1, r);
        describe_circle(p.0, p.1, r);
    }
}
```

Output:

```rust
Points: ((0.1234, 0.9876), (0.8765, 0.2345)), Radius: 2.0000
Two circles are possible.
Circle C1 with center (1.8631, 1.9742), r 2.0000 and Circle C2 with center (-0.8632, -0.7521), r 2.0000

Points: ((0.0000, 2.0000), (0.0000, 0.0000)), Radius: 1.0000
Given points are opposite ends of a diameter of the circle with center (0.0000,1.0000) and r 1.0000

Points: ((0.1234, 0.9876), (0.1234, 0.9876)), Radius: 2.0000
Infinitely many circles can be drawn through (0.1234, 0.9876)

Points: ((0.1234, 0.9876), (0.8765, 0.2345)), Radius: 0.5000
Given points are farther away from each other than a diameter of a circle with r 0.5000

Points: ((0.1234, 0.9876), (0.1234, 0.9876)), Radius: 0.0000
No circles can be drawn through (0.1234, 0.9876)
```

# Call a function in a shared library<a id="sec-309"></a>

Show how to call a function in a shared library (without dynamically linking to it at compile-time). In particular, show how to call the shared library function if the library is available, otherwise use an internal equivalent function.

This is a special case of calling a foreign language function where the focus is close to the ABI level and not at the normal API level.

Related task

OpenGL &#x2013; OpenGL is usually maintained as a shared library.

The standard library does not provide a way to load dynamic libraries. Without using third-party libraries, we must use the FFI to call the relevant C functions directly.

Unix[edit]

```rust
#![allow(unused_unsafe)]
extern crate libc;
¬†
use std::io::{self,Write};
use std::{mem,ffi,process};
¬†
use libc::{c_double, RTLD_NOW};
¬†
// Small macro which wraps turning a string-literal into a c-string.
// This is always safe to call, and the resulting pointer has 'static lifetime
macro_rules! to_cstr {
    ($s:expr) => {unsafe {ffi::CStr::from_bytes_with_nul_unchecked(concat!($s, "\0").as_bytes()).as_ptr()}}
}
¬†
macro_rules! from_cstr {
    ($p:expr) => {ffi::CStr::from_ptr($p).to_string_lossy().as_ref() }
}
¬†
fn main() {
    unsafe {
        let handle = libc::dlopen(to_cstr!("libm.so.6"), RTLD_NOW);
¬†
        if handle.is_null() {
            writeln!(&mut io::stderr(), "{}", from_cstr!(libc::dlerror())).unwrap();
            process::exit(1);
        }
¬†
        let extern_cos = libc::dlsym(handle, to_cstr!("cos"))
                .as_ref()
                .map(mem::transmute::<_,fn (c_double) -> c_double)
                .unwrap_or(builtin_cos);
        println!("{}", extern_cos(4.0));
    }
}
¬†
fn builtin_cos(x: c_double) -> c_double {
    x.cos()
}
```

# First-class functions/Use numbers analogously<a id="sec-310"></a>

In First-class functions, a language is showing how its manipulation of functions is similar to its manipulation of other types.

This tasks aim is to compare and contrast a language's implementation of first class functions, with its normal handling of numbers.

Write a program to create an ordered collection of a mixture of literally typed and expressions producing a real number, together with another ordered collection of their multiplicative inverses. Try and use the following pseudo-code to generate the numbers for the ordered collections:

```
x  = 2.0
xi = 0.5
y  = 4.0
yi = 0.25
z  = x + y
zi = 1.0 / ( x + y )

```

Create a function multiplier, that given two numbers as arguments returns a function that when called with one argument, returns the result of multiplying the two arguments to the call to multiplier that created it and the argument in the call:

```
new_function = multiplier(n1,n2)
# where new_function(m) returns the result of n1 * n2 * m

```

Applying the multiplier of a number and its inverse from the two ordered collections of numbers in pairs, show that the result in each case is one. Compare and contrast the resultant program with the corresponding entry in First-class functions. They should be close.

To paraphrase the task description: Do what was done before, but with numbers rather than functions

```rust
#![feature(conservative_impl_trait)]
fn main() {
    let (x, xi) = (2.0, 0.5);
    let (y, yi) = (4.0, 0.25);
    let z = x + y;
    let zi = 1.0/z;
¬†
    let numlist = [x,y,z];
    let invlist = [xi,yi,zi];
¬†
    let result = numlist.iter()
                        .zip(&invlist)
                        .map(|(x,y)| multiplier(*x,*y)(0.5))
                        .collect::<Vec<_>>();
    println!("{:?}", result);
}
¬†
fn multiplier(x: f64, y: f64) -> impl Fn(f64) -> f64 {
    move |m| x*y*m
}
¬†
```

This is very similar to the first-class functions implementation save that the type inference works a little bit better here (e.g. when declaring numlist and invlist) and multiplier's declaration is substantially simpler than compose's. Both of these boil down to the fact that closures and regular functions are actually different types in Rust so we have to be generic over them but here we are only dealing with 64-bit floats.

# Split a character string based on change of character<a id="sec-311"></a>

Task

Split a (character) string into comma (plus a blank) delimited strings based on a change of character ¬† (left to right).

Show the output here ¬† (use the 1st example below).

Blanks should be treated as any other character ¬† (except they are problematic to display clearly). ¬† The same applies to commas.

For instance, the string:

```
gHHH5YY++///\ 

```

should be split and show:

```
g, HHH, 5, YY, ++, ///, \ 

```

```rust
fn splitter(string: &str) -> String {
    let chars: Vec<_> = string.chars().collect();
    let mut result = Vec::new();
    let mut last_mismatch = 0;
    for i in 0..chars.len() {
        if chars.len() == 1 {
            return chars[0..1].iter().collect();
        }
        if i > 0 && chars[i-1]¬†!= chars[i] {
            let temp_result: String = chars[last_mismatch..i].iter().collect();
            result.push(temp_result);
            last_mismatch = i;
        }
        if i == chars.len() - 1 {
            let temp_result: String = chars[last_mismatch..chars.len()].iter().collect();
            result.push(temp_result);
        }
    }
    result.join(", ")
}
¬†
fn main() {
    let test_string = "g";
    println!("input string: {}", test_string);
    println!("output string: {}", splitter(test_string));
¬†
    let test_string = "";
    println!("input string: {}", test_string);
    println!("output string: {}", splitter(test_string));
¬†
    let test_string = "gHHH5YY++///\\";
    println!("input string: {}", test_string);
    println!("output string: {}", splitter(test_string));
}
```

Output:

```rust
input string: g
output string: g
input string: 
output string: 
input string: gHHH5YY++///\
output string: g, HHH, 5, YY, ++, ///, \

```

# Guess the number/With feedback (player)<a id="sec-312"></a>

Task:

Write a player for the game that follows the following rules:

The scorer will choose a number between set limits. The computer player will print a guess of the target number. The computer asks for a score of whether its guess is higher than, lower than, or equal to the target. The computer guesses, and the scorer scores, in turn, until the computer correctly guesses the target number.

The computer should guess intelligently based on the accumulated scores given. One way is to use a Binary search based algorithm.

Related tasks

¬† Guess the number/With Feedback ¬† Bulls and cows/Player

Works with: rustc version 1.0.0-nightly

```rust
use std::io::stdin;
¬†
const MIN: isize = 1;
const MAX: isize = 100;
¬†
fn main() {
    loop {
        let mut min = MIN;
        let mut max = MAX;
        let mut num_guesses = 1;
        println!("Please think of a number between {} and {}", min, max);
        loop {
            let guess = (min + max) / 2;
            println!("Is it {}?", guess);
            println!("(type h if my guess is too high, l if too low, e if equal and q to quit)");
¬†
            let mut line = String::new();
            stdin().read_line(&mut line).unwrap();
            match Some(line.chars().next().unwrap().to_uppercase().next().unwrap()) {
                Some('H') => {
                    max = guess - 1;
                    num_guesses += 1;
                },
                Some('L')=> {
                    min = guess + 1;
                    num_guesses += 1;
                },
                Some('E') => {
                    if num_guesses == 1 {
                        println!("\n*** That was easy! Got it in one guess! ***\n");
                    } else {
                        println!("\n*** I knew it! Got it in only {} guesses! ***\n", num_guesses);
                    }
                    break;
                },
                Some('Q') => return,
                _ => println!("Sorry, I didn't quite get that. Please try again.")
            }
        }
    }
}
```

# Menu<a id="sec-313"></a>

Task

Given a prompt and a list containing a number of strings of which one is to be selected, create a function that:

prints a textual menu formatted as an index value followed by its corresponding string for each item in the list; prompts the user to enter a number; returns the string corresponding to the selected index number.

The function should reject input that is not an integer or is out of range by redisplaying the whole menu before asking again for a number. The function should return an empty string if called with an empty list.

For test purposes use the following four phrases in a list:

```
fee fie
huff and puff
mirror mirror
tick tock

```

Note

This task is fashioned after the action of the Bash select statement.

```rust
¬†
fn menu_select<'a>(items: &'a [&'a str]) -> &'a str {
    if items.len() == 0 {
        return "";
    }
¬†
    let stdin = std::io::stdin();
    let mut buffer = String::new();
¬†
    loop {
        for (i, item) in items.iter().enumerate() {
            println!("{}) {}", i + 1, item);
        }
        print!("Pick a number from 1 to {}: ", items.len());
¬†
        // Read the user input:
        stdin.read_line(&mut buffer).unwrap();
        println!();
¬†
        if let Ok(selected_index) = buffer.trim().parse::<usize>() {
            if 0 < selected_index {
                if let Some(selected_item) = items.get(selected_index - 1) {
                    return selected_item;
                }
            }
        }
¬†
        // The buffer will contain the old input, so we need to clear it before we can reuse it.
        buffer.clear();
    }
}
¬†
fn main() {
    // Empty list:
    let selection = menu_select(&[]);
    println!("No choice: {:?}", selection);
¬†
    // List with items:
    let items = [
        "fee fie",
        "huff and puff",
        "mirror mirror",
        "tick tock",
    ];
¬†
    let selection = menu_select(&items);
    println!("You chose: {}", selection);
}
¬†
```

# Munchausen numbers<a id="sec-314"></a>

A Munchausen number is a natural number n the sum of whose digits (in base 10), each raised to the power of itself, equals n.

(Munchausen is also spelled: M√ºnchhausen.)

For instance: 3435 = 33 + 44 + 33 + 55

Task

Find all Munchausen numbers between 1 and 5000

Also see The OEIS entry: A046253 The Wikipedia entry: Perfect digit-to-digit invariant, redirected from Munchausen Number

```rust
fn main() {
    let mut solutions = Vec::new();
¬†
    for num in 1..5_000 {
        let power_sum = num.to_string()
            .chars()
            .map(|c| {
                let digit = c.to_digit(10).unwrap();
                (digit as f64).powi(digit as i32) as usize
            })
            .sum::<usize>();
¬†
        if power_sum == num {
            solutions.push(num);
        }
    }
¬†
    println!("Munchausen numbers below 5_000¬†: {:?}", solutions);
}
```

Output:

```rust
Munchausen numbers below 5_000¬†: [1, 3435]

```

# Sort stability<a id="sec-315"></a>

When sorting records in a table by a particular column or field, a stable sort will always retain the relative order of records that have the same key.

For example, in this table of countries and cities, a stable sort on the second column, the cities, would keep the US Birmingham above the UK Birmingham. (Although an unstable sort might, in this case, place the US Birmingham above the UK Birmingham, a stable sort routine would guarantee it).

```
UK  London
US  New York
US  Birmingham
UK  Birmingham
```

Similarly, stable sorting on just the first column would generate ‚ÄúUK London‚Äù as the first item and ‚ÄúUS Birmingham‚Äù as the last item (since the order of the elements having the same first word ‚Äì ‚ÄúUK‚Äù or ‚ÄúUS‚Äù ‚Äì would be maintained).

Examine the documentation on any in-built sort routines supplied by a language. Indicate if an in-built routine is supplied If supplied, indicate whether or not the in-built routine is stable.

(This Wikipedia table shows the stability of some common sort routines).

Rust's builtin sorts (.sort(), .sort<sub>by</sub>(&#x2026;), .sort<sub>by</sub><sub>key</sub>(&#x2026;)) are all stable

```rust
fn main() {
    let country_city = [("UK", "London"),
                        ("US", "New York"),
                        ("US", "Birmingham"),
                        ("UK", "Birmingham")];
¬†
    let mut city_sorted = country_city.clone();
    city_sorted.sort_by_key(|k| k.1);
¬†
    let mut country_sorted = country_city.clone();
    country_sorted.sort_by_key(|k| k.0);
¬†
¬†
    println!("Original:");
    for x in &country_city {
        println!("{} {}", x.0, x.1);
    }
¬†
    println!("\nWhen sorted by city:");
    for x in &city_sorted {
        println!("{} {}", x.0, x.1);
    }
¬†
    println!("\nWhen sorted by county:");
    for x in &country_sorted {
        println!("{} {}", x.0, x.1);
    }
}
```

```rust
Original:
UK London
US New York
US Birmingham
UK Birmingham

When sorted by city:
US Birmingham
UK Birmingham
UK London
US New York

When sorted by county:
UK London
UK Birmingham
US New York
US Birmingham
```

# Sorting algorithms/Pancake sort<a id="sec-316"></a>

Task

Sort an array of integers (of any convenient size) into ascending order using Pancake sorting.

In short, instead of individual elements being sorted, the only operation allowed is to "flip" one end of the list, like so:

```
Before:
6 7 8 9 2 5 3 4 1
After:
9 8 7 6 2 5 3 4 1

```

Only one end of the list can be flipped; this should be the low end, but the high end is okay if it's easier to code or works better, but it must be the same end for the entire solution. (The end flipped can't be arbitrarily changed.)

Show both the initial, unsorted list and the final sorted list. (Intermediate steps during sorting are optional.) Optimizations are optional (but recommended).

For more information on pancake sorting, see the Wikipedia entry.

See also:

Number reversal game Topswops

```rust
fn pancake_sort<T: Ord>(v: &mut [T]) {
    let len = v.len();
    // trivial case -- no flips
    if len < 2 {
        return;
    }
    for i in (0..len).rev() {
        // find index of the maximum element within `v[0..i]` (inclusive)
        let max_index = v.iter()
            .take(i + 1)
            .enumerate()
            .max_by_key(|&(_, elem)| elem)
            .map(|(idx, _)| idx)
            // safe because we already checked if `v` is empty
            .unwrap();
        // if `max_index` is not where it's supposed to be
        // do two flips to move it to `i`
        if max_index¬†!= i {
            flip(v, max_index);
            flip(v, i);
        }
    }
}
¬†
// function to flip a section of a mutable collection from 0..num (inclusive)
fn flip<E: PartialOrd>(v: &mut [E], num: usize) {
    v[0..num + 1].reverse();
}
¬†
fn main() {
    // Sort numbers
    let mut numbers = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1];
    println!("Before: {:?}", numbers);
    pancake_sort(&mut numbers);
    println!("After: {:?}", numbers);
¬†
    // Sort strings
    let mut strings = ["beach", "hotel", "airplane", "car", "house", "art"];
    println!("Before: {:?}", strings);
    pancake_sort(&mut strings);
    println!("After: {:?}", strings);
}
```

# One of n lines in a file<a id="sec-317"></a>

A method of choosing a line randomly from a file:

Without reading the file more than once When substantial parts of the file cannot be held in memory Without knowing how many lines are in the file

Is to:

keep the first line of the file as a possible choice, then Read the second line of the file if possible and make it the possible choice if a uniform random value between zero and one is less than 1/2. Read the third line of the file if possible and make it the possible choice if a uniform random value between zero and one is less than 1/3. &#x2026; Read the Nth line of the file if possible and make it the possible choice if a uniform random value between zero and one is less than 1/N

Return the computed possible choice when no further lines exist in the file.

Task

Create a function/method/routine called one<sub>of</sub><sub>n</sub> that given n, the number of actual lines in a file, follows the algorithm above to return an integer - the line number of the line chosen from the file. The number returned can vary, randomly, in each run. Use one<sub>of</sub><sub>n</sub> in a simulation to find what woud be the chosen line of a 10 line file simulated 1,000,000 times. Print and show how many times each of the 10 lines is chosen as a rough measure of how well the algorithm works.

Note: You may choose a smaller number of repetitions if necessary, but mention this up-front.

Note: This is a specific version of a Reservoir Sampling algorithm: <https://en.wikipedia.org/wiki/Reservoir_sampling>

Library: rand

You could also use \`rand::seq::sample<sub>iter</sub>\` which uses a more general version of this problem, Reservoir Sampling: <https://en.wikipedia.org/wiki/Reservoir_sampling>.

```rust
extern crate rand;
¬†
use rand::{Rng, thread_rng};
¬†
fn one_of_n<R: Rng>(rng: &mut R, n: usize) -> usize {
    (1..n).fold(0, |keep, cand| {
        // Note that this will break if n is larger than u32::MAX
        if rng.gen_weighted_bool(cand as u32 + 1) {
            cand
        } else {
            keep
        }
    })
}
¬†
fn main() {
    const LINES: usize = 10;
¬†
    let mut dist = [0; LINES];
    let mut rng = thread_rng();
¬†
    for _ in 0..1_000_000 {
        let num = one_of_n(&mut rng, LINES);
        dist[num] += 1;
    }
¬†
    println!("{:?}", dist);
}
¬†
```

Output:

```rust
[100203, 100012, 99854, 99686, 99888, 99899, 99559, 100584, 100208, 100107]

```

# SHA-256<a id="sec-318"></a>

SHA-256 is the recommended stronger alternative to SHA-1. See FIPS PUB 180-4 for implementation details.

Either by using a dedicated library or implementing the algorithm in your language, show that the SHA-256 digest of the string "Rosetta code" is: 764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf

```rust
extern crate ring;
¬†
use ring::digest::{digest, SHA256};
¬†
fn main() {
    println!("{}", sha_256("Rosetta code"));
}
¬†
fn sha_256(input: &str) -> String {
    let result = digest(&SHA256, input.as_bytes());
    result.as_ref().iter().map(|b| format!("{:x}", b)).collect()
}
```

# Fractal tree<a id="sec-319"></a>

Generate and draw a fractal tree.

Draw the trunk At the end of the trunk, split by some angle and draw two branches Repeat at the end of each branch until a sufficient level of branching is reached

Related tasks

Pythagoras Tree

Library: Piston

```rust
//Cargo deps¬†:
//  piston = "0.35.0"
//  piston2d-graphics = "0.23.0"
//  piston2d-opengl_graphics = "0.49.0"
//  pistoncore-glutin_window = "0.42.0"
¬†
extern crate piston;
extern crate graphics;
extern crate opengl_graphics;
extern crate glutin_window;
¬†
use piston::window::WindowSettings;
use piston::event_loop::{Events, EventSettings};
use piston::input::RenderEvent;
use glutin_window::GlutinWindow as Window;
use opengl_graphics::{GlGraphics, OpenGL};
use graphics::{clear, line, Context};
¬†
const ANG: f64 = 20.0;
const COLOR: [f32; 4] = [1.0, 0.0, 0.5, 1.0];
const LINE_THICKNESS: f64 = 5.0;
const DEPTH: u32 = 11;
¬†
fn main() {
    let mut window: Window = WindowSettings::new("Fractal Tree", [1024, 768])
        .opengl(OpenGL::V3_2)
        .exit_on_esc(true)
        .build()
        .unwrap();
    let mut gl = GlGraphics::new(OpenGL::V3_2);
¬†
    let mut events = Events::new(EventSettings::new());
    while let Some(e) = events.next(&mut window) {
        if let Some(args) = e.render_args() {
            gl.draw(args.viewport(), |c, g| {
                clear([1.0, 1.0, 1.0, 1.0], g);
                draw_fractal_tree(512.0, 700.0, 0.0, DEPTH, c, g);
            });
        }
    }
}
¬†
fn draw_fractal_tree(x1: f64, y1: f64, angle: f64, depth: u32, c: Context, g: &mut GlGraphics) {
    let x2 = x1 + angle.to_radians().sin() * depth as f64 * 10.0;
    let y2 = y1 - angle.to_radians().cos() * depth as f64 * 10.0;
    line(
        COLOR,
        LINE_THICKNESS * depth as f64 * 0.2,
        [x1, y1, x2, y2],
        c.transform,
        g,
    );
    if depth > 0 {
        draw_fractal_tree(x2, y2, angle - ANG, depth - 1, c, g);
        draw_fractal_tree(x2, y2, angle + ANG, depth - 1, c, g);
    }
}
¬†
```

# Singly-linked list/Element insertion<a id="sec-320"></a>

Singly-Linked List (element)

singly-linked list

Using this method, insert an element C into a list comprised of elements A->B, following element A.

See also

Array Associative array: Creation, Iteration Collections Compound data type Doubly-linked list: Definition, Element definition, Element insertion, Traversal Linked list Queue: Definition, Usage Set Singly-linked list: Element definition, Element insertion, Traversal Stack

Extending Singly-Linked List (element)#Rust. Please see that page for the Linked List struct declarations.

```rust
impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None }
    }
¬†
    pub fn push(&mut self, elem: T) {
    let new_node = Box::new(Node {
        elem: elem,
        next: self.head.take(),
    });
    self.head = Some(new_node);
}
```

# Maximum triangle path sum<a id="sec-321"></a>

Starting from the top of a pyramid of numbers like this, you can walk down going one step on the right or on the left, until you reach the bottom row:

```
     55
   94 48
  95 30 96
77 71 26 67

```

One of such walks is 55 - 94 - 30 - 26. You can compute the total of the numbers you have seen in such walk, in this case it's 205.

Your problem is to find the maximum total among all possible paths from the top to the bottom row of the triangle. In the little example above it's 321.

Task

Find the maximum total in the triangle below:

```
                          55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93

```

Such numbers can be included in the solution code, or read from a "triangle.txt" file.

This task is derived from the Euler Problem #18.

Works with: Rust version 1.3

```rust
use std::cmp::max;
¬†
fn max_path(vector: &mut Vec<Vec<u32>>) -> u32 {
¬†
    while vector.len() > 1 {
¬†
        let last = vector.pop().unwrap();
        let ante = vector.pop().unwrap();
¬†
        let mut new: Vec<u32> = Vec::new();
¬†
        for (i, value) in ante.iter().enumerate() {
            new.push(max(last[i], last[i+1]) + value);
        };
¬†
        vector.push(new);
    };
¬†
    vector[0][0]
}
¬†
fn main() {
    let mut data = "55
94 48
95 30 96
77 71 26 67
97 13 76 38 45
07 36 79 16 37 68
48 07 09 18 70 26 06
18 72 79 46 59 79 29 90
20 76 87 11 32 07 07 49 18
27 83 58 35 71 11 25 57 29 85
14 64 36 96 27 11 58 56 92 18 55
02 90 03 60 48 49 41 46 33 36 47 23
92 50 48 02 36 59 42 79 72 20 82 77 42
56 78 38 80 39 75 02 71 66 66 01 03 55 72
44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93";
¬†
    let mut vector = data.split("\n").map(|x| x.split(" ").map(|s: &str| s.parse::<u32>().unwrap())
        .collect::<Vec<u32>>()).collect::<Vec<Vec<u32>>>();
¬†
    let max_value = max_path(&mut vector);
¬†
    println!("{}", max_value);
    //=> 7273
}
```

# General FizzBuzz<a id="sec-322"></a>

Task

Write a generalized version of FizzBuzz that works for any list of factors, along with their words.

This is basically a "fizzbuzz" implementation where the user supplies the parameters.

The user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.

For simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.

For example, given:

```
>20      #This is the maximum number, supplied by the user
>3 Fizz  #The user now enters the starting factor (3) and the word they want associated with it (Fizz)
>5 Buzz  #The user now enters the next factor (5) and the word they want associated with it (Buzz)
>7 Baxx  #The user now enters the next factor (7) and the word they want associated with it (Baxx)

```

In other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with "Fizz", every multiple of 5 with "Buzz", and every multiple of 7 with "Baxx".

In the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.

For instance, the number 15 is a multiple of both 3 and 5; print "FizzBuzz".

If the max number was 105 instead of 20, you would print "FizzBuzzBaxx" because it's a multiple of 3, 5, and 7.

Output:

```
1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz

```

```rust
use std::io;
use std::io::BufRead;
¬†
fn parse_entry(l: &str) -> (i32, String) {
    let params: Vec<&str> = l.split(' ').collect();
¬†
    let divisor = params[0].parse::<i32>().unwrap();
    let word = params[1].to_string();
    (divisor, word)
}
¬†
fn main() {
    let stdin = io::stdin();
    let mut lines = stdin.lock().lines().map(|l| l.unwrap());
¬†
    let l = lines.next().unwrap();
    let high = l.parse::<i32>().unwrap();
¬†
    let mut entries = Vec::new();
    for l in lines {
        if &l == "" { break }
        let entry = parse_entry(&l);
        entries.push(entry);
    }
¬†
    for i in 1..(high + 1) {
        let mut line = String::new();
        for &(divisor, ref word) in &entries {
            if i¬†% divisor == 0 {
                line = line + &word;
            }
        }
        if line == "" {
            println!("{}", i);
        } else {
            println!("{}", line);
        }
    }
}
```

# Sorting algorithms/Sleep sort<a id="sec-323"></a>

In general, sleep sort works by starting a separate task for each item to be sorted, where each task sleeps for an interval corresponding to the item's sort key, then emits the item. Items are then collected sequentially in time.

Task: Write a program that implements sleep sort. Have it accept non-negative integers on the command line and print the integers in sorted order. If this is not idomatic in your language or environment, input and output may be done differently. Enhancements for optimization, generalization, practicality, robustness, and so on are not required.

Sleep sort was presented anonymously on 4chan and has been discussed on Hacker News.

```rust
use std::thread;
¬†
fn sleepsort<I: Iterator<Item=u32>>(nums: I) {
    let threads: Vec<_> = nums.map(|n|
        thread::spawn(move || {
            thread::sleep_ms(n);
            println!("{}", n); })).collect();
    for t in threads { t.join(); }
}
¬†
fn main() {
    sleepsort(std::env::args().skip(1).map(|s| s.parse().unwrap()));
}
```

Output:

```rust
$ ./sleepsort 50 34 43 3 2
2
3
34
43
50

```

# Keyboard input/Obtain a Y or N response<a id="sec-324"></a>

Task

Obtain a valid ¬† Y ¬† or ¬† N ¬† response from the keyboard.

The keyboard should be flushed, so that any outstanding key-presses are removed, preventing any existing ¬† Y ¬† or ¬† N ¬† key-press from being evaluated.

The response should be obtained as soon as ¬† Y ¬† or ¬† N ¬† are pressed, and there should be no need to press an ¬† enter ¬† key.

Library: Ncurses

```rust
//cargo-deps: ncurses
¬†
extern crate ncurses;
use ncurses::*;
¬†
fn main() {
    initscr();
    loop {
        printw("Yes or no? ");
        refresh();
¬†
        match getch() as u8 as char {
            'Y'|'y' => {printw("You said yes!");},
            'N'|'n' => {printw("You said no!");},
            _ => {printw("Try again!\n"); continue;},
        }
        break
    }
    refresh();
    endwin();
}
```

# Sorting algorithms/Stooge sort<a id="sec-325"></a>

This page uses content from Wikipedia. The original article was at Stooge sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Task

Show the ¬† Stooge Sort ¬† for an array of integers.

The Stooge Sort algorithm is as follows:

```
algorithm stoogesort(array L, i = 0, j = length(L)-1)
     if L[j] < L[i] then
         L[i] ‚Üî L[j]
     if j - i > 1 then
         t := (j - i + 1)/3
         stoogesort(L, i  , j-t)
         stoogesort(L, i+t, j  )
         stoogesort(L, i  , j-t)
     return L

```

```rust
fn stoogesort<E>(a: &mut [E])
    where E: PartialOrd
{
    let len = a.len();
¬†
    if a.first().unwrap() > a.last().unwrap() {
        a.swap(0, len - 1);
    }
    if len - 1 > 1 {
        let t = len / 3;
        stoogesort(&mut a[..len - 1]);
        stoogesort(&mut a[t..]);
        stoogesort(&mut a[..len - 1]);
    }
}
¬†
fn main() {
    let mut numbers = vec![1_i32, 9, 4, 7, 6, 5, 3, 2, 8];
    println!("Before: {:?}", &numbers);
    stoogesort(&mut numbers);
    println!("After: {:?}", &numbers);
}
```

# Fibonacci word<a id="sec-326"></a>

The ¬† Fibonacci Word ¬† may be created in a manner analogous to the ¬† Fibonacci Sequence ¬† as described here:

```
Define ¬† F_Word1 ¬† as ¬† 1
Define ¬† F_Word2 ¬† as ¬† 0
Form ¬† ¬† F_Word3 ¬† as ¬† F_Word2 ¬† ¬† concatenated with ¬† F_Word1 ¬†  i.e.: ¬† 01
Form ¬† ¬† F_Wordn ¬† as ¬† F_Wordn-1 ¬† concatenated with ¬† F_wordn-2

```

Task

Perform the above steps for ¬† ¬† n = 37.

You may display the first few but not the larger values of ¬† n. {Doing so will get the task's author into trouble with them what be (again!).}

Instead, create a table for ¬† F<sub>Words</sub> ¬† 1 ¬† to ¬† 37 ¬† which shows:

¬† The number of characters in the word ¬† The word's Entropy

Related tasks

¬† Fibonacci word/fractal ¬† Entropy ¬† Entropy/Narcissist

This is not implemented in any sort of generic way and is probably fairly inefficient.

```rust
struct Fib<T> {
    curr: T,
    next: T,
}
¬†
impl<T> Fib<T> {
    fn new(curr: T, next: T) -> Self {
        Fib { curr: curr, next: next, }
    }
}
¬†
impl Iterator for Fib<String>  {
    type Item = String;
    fn next(&mut self) -> Option<Self::Item> {
        let ret = self.curr.clone();
        self.curr = self.next.clone();
        self.next = format!("{}{}", ret, self.next);
        Some(ret)
    }
}
¬†
fn get_entropy(s: &[u8]) -> f64 {
    let mut entropy = 0.0;
    let mut histogram = [0.0; 256];
¬†
    for i in 0..s.len() {
        histogram.get_mut(s[i] as usize).map(|v| *v += 1.0);
    }
¬†
    for i in 0..256 {
        if histogram[i] > 0.0 {
            let ratio = histogram[i] / s.len() as f64;
            entropy -= ratio * ratio.log2();
        }
    }
    entropy
}
¬†
fn main() {
    let f = Fib::new("1".to_string(), "0".to_string());
        println!("{:10} {:10} {:10} {:60}", "N", "Length", "Entropy", "Word");
    for (i, s) in f.take(37).enumerate() {
        let word = if s.len() > 60 {"Too long"} else {&*s};
        println!("{:10} {:10} {:.10} {:60}", i + 1, s.len(), get_entropy(&s.bytes().collect::<Vec<_>>()), word);
    }
}
```

Output:

```rust
N          Length     Entropy    Word                                                        
         1          1 0.0000000000 1                                                           
         2          1 0.0000000000 0                                                           
         3          2 1.0000000000 10                                                          
         4          3 0.9182958341 010                                                         
         5          5 0.9709505945 10010                                                       
         6          8 0.9544340029 01010010                                                    
         7         13 0.9612366047 1001001010010                                               
         8         21 0.9587118830 010100101001001010010                                       
         9         34 0.9596868938 1001001010010010100101001001010010                          
        10         55 0.9593160321 0101001010010010100101001001010010010100101001001010010     
        11         89 0.9594579158 Too long                                                    
        12        144 0.9594037542 Too long                                                    
        13        233 0.9594244470 Too long                                                    
        14        377 0.9594165437 Too long                                                    
        15        610 0.9594195626 Too long                                                    
        16        987 0.9594184095 Too long                                                    
        17       1597 0.9594188500 Too long                                                    
        18       2584 0.9594186817 Too long                                                    
        19       4181 0.9594187460 Too long                                                    
        20       6765 0.9594187214 Too long                                                    
        21      10946 0.9594187308 Too long          t                                          
        22      17711 0.9594187272 Too long                                                    
        23      28657 0.9594187286 Too long                                                    
        24      46368 0.9594187281 Too long                                                    
        25      75025 0.9594187283 Too long                                                    
        26     121393 0.9594187282 Too long                                                    
        27     196418 0.9594187282 Too long                                                    
        28     317811 0.9594187282 Too long                                                    
        29     514229 0.9594187282 Too long                                                    
        30     832040 0.9594187282 Too long                                                    
        31    1346269 0.9594187282 Too long                                                    
        32    2178309 0.9594187282 Too long                                                    
        33    3524578 0.9594187282 Too long                                                    
        34    5702887 0.9594187282 Too long                                                    
        35    9227465 0.9594187282 Too long                                                    
        36   14930352 0.9594187282 Too long                                                    
        37   24157817 0.9594187282 Too long                                                    


```

# Hello world/Web server<a id="sec-327"></a>

The browser is the new GUI¬†!

Task

Serve our standard text ¬† Goodbye, World! ¬† to ¬† <http://localhost:8080/> ¬† so that it can be viewed with a web browser.

The provided solution must start or implement a server that accepts multiple client connections and serves text as requested.

Note that starting a web browser or opening a new window with this URL is not part of the task.

Additionally, it is permissible to serve the provided page as a plain text file (there is no requirement to serve properly formatted HTML here).

The browser will generally do the right thing with simple text like this.

Basically no error handling. This web server will simply panic if there is any sort of error.

```rust
use std::net::{Shutdown, TcpListener};
use std::thread;
use std::io::Write;
¬†
const RESPONSE: &'static [u8] = b"HTTP/1.1 200 OK\r
Content-Type: text/html; charset=UTF-8\r\n\r
<!DOCTYPE html><html><head><title>Bye-bye baby bye-bye</title>
<style>body { background-color: #111 }
h1 { font-size:4cm; text-align: center; color: black;
text-shadow: 0 0 2mm red}</style></head>
<body><h1>Goodbye, world!</h1></body></html>\r";
¬†
¬†
fn main() {
    let listener = TcpListener::bind("127.0.0.1:8080").unwrap();
¬†
    for stream in listener.incoming() {
        thread::spawn(move || {
            let mut stream = stream.unwrap();
            match stream.write(RESPONSE) {
                Ok(_) => println!("Response sent!"),
                Err(e) => println!("Failed sending response: {}!", e),
            }
            stream.shutdown(Shutdown::Write).unwrap();
        });
    }
}
¬†
```

# Deepcopy<a id="sec-328"></a>

Task

Demonstrate how to copy data structures containing complex heterogeneous and cyclic semantics.

This is often referred to as deep copying, and is normally required where structures are mutable and to ensure that independent copies can be manipulated without side-effects.

If this facility is not built into the language, it is permissible to use functions from a common library, or a coded procedure.

The task should show:

Relevant semantics of structures, such as their homogeneous or heterogeneous properties, or containment of (self- or mutual-reference) cycles.

Any limitations of the method.

That the structure and its copy are different.

Suitable links to external documentation for common libraries.

This is what the Clone trait exists for although the depth of the copy is arbitrary and up to the type that implements the trait.

```rust
// The compiler can automatically implement Clone on structs (assuming all members have implemented Clone).
#[derive(Clone)]
struct Tree<T> {
    left: Leaf<T>,
    data: T,
    right: Leaf<T>,
}
¬†
type Leaf<T> = Option<Box<Tree<T>>>;
¬†
impl<T> Tree<T> {
    fn root(data: T) -> Self {
        Self { left: None, data, right: None }
    }
¬†
    fn leaf(d: T) -> Leaf<T> {
        Some(Box::new(Self::root(d)))
    }
}
¬†
fn main() {
    let mut tree = Tree::root([4, 5, 6]);
    tree.right = Tree::leaf([1, 2, 3]);
    tree.left = Tree::leaf([7, 8, 9]);
¬†
    let newtree = tree.clone();
}
```

# Population count<a id="sec-329"></a>

The population count ¬† is the number of ¬† 1s ¬† (ones) ¬† in the binary representation of a non-negative integer.

Population count is also known as ¬† pop count, ¬† popcount, ¬† sideways sum, ¬† and ¬† Hamming weight.

For example, ¬† 5 ¬† (which is ¬† 101 ¬† in binary) ¬† has a population count of ¬† 2.

Evil numbers ¬† are non-negative integers that have an ¬† even ¬† population count.

Odious numbers ¬† are positive integers that have an ¬† odd ¬† population count.

Task

write a function (or routine) to return the population count of a non-negative integer. all computation of the lists below should start with ¬† 0 ¬† (zero indexed).

display the ¬† pop count ¬† of the ¬† 1st ¬† thirty powers of ¬† 3 ¬† ¬† ¬† (30, ¬† 31, ¬† 32, ¬† 33, ¬† 34, ¬† ‚àô‚àô‚àô ¬† 329). display the ¬† 1st ¬† thirty ¬† ¬† evil ¬† ¬† numbers. display the ¬† 1st ¬† thirty ¬† odious ¬† numbers.

display each list of integers on one line ¬† (which may or may not include a title), ¬† each set of integers being shown should be properly identified.

See also

The On-Line Encyclopedia of Integer Sequences: ¬† A000069 odious numbers. The On-Line Encyclopedia of Integer Sequences: ¬† A001969 evil numbers.

```rust
¬†
fn main() {
    let mut num = 1u64;
    let mut vec = Vec::new();
    for _ in 0..30 {
        vec.push(num.count_ones());
        num *= 3;
    }
    println!("pop count of 3^0, 3^1 ... 3^29:\n{:?}",vec);
    let mut even = Vec::new();
    let mut odd  = Vec::new();
    num = 1;
    while even.len() < 30 || odd.len() < 30 {
        match 0 == num.count_ones()%2 {
            true if even.len() < 30 => even.push(num),
            false if odd.len() < 30 => odd.push(num),
            _                       => {}
        }
        num += 1;
    }
    println!("\nFirst 30 even pop count:\n{:?}",even);
    println!("\nFirst 30 odd pop count:\n{:?}",odd);
}
¬†
```

Output:

```rust
pop count of 3^0, 3^1 ... 3^29:
[1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22, 16, 18, 24, 30, 25, 25]

First 30 even pop count:
[3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58, 60]

First 30 odd pop count:
[1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59]

```

# Generate Chess960 starting position<a id="sec-330"></a>

Chess960 is a variant of chess created by world champion Bobby Fischer. Unlike other variants of the game, Chess960 does not require a different material, but instead relies on a random initial position, with a few constraints:

as in the standard chess game, all eight white pawns must be placed on the second rank. White pieces must stand on the first rank as in the standard game, in random column order but with the two following constraints: the bishops must be placed on opposite color squares (i.e. they must be an odd number of spaces apart or there must be an even number of spaces between them) the King must be between two rooks (with any number of other pieces between them all) Black pawns and pieces must be placed respectively on the seventh and eighth ranks, mirroring the white pawns and pieces, just as in the standard game. (That is, their positions are not independently randomized.)

With those constraints there are 960 possible starting positions, thus the name of the variant.

Task

The purpose of this task is to write a program that can randomly generate any one of the 960 Chess960 initial positions. You will show the result as the first rank displayed with Chess symbols in Unicode: ‚ôî‚ôï‚ôñ‚ôó‚ôò or with the letters King Queen Rook Bishop kNight.

Translation of: Kotlin

```rust
use std::collections::BTreeSet;
¬†
struct Chess960 ( BTreeSet<String> );
¬†
impl Chess960 {
    fn invoke(&mut self, b: &str, e: &str) {
        if e.len() <= 1 {
            let s = b.to_string() + e;
            if Chess960::is_valid(&s) { self.0.insert(s); }
        } else {
            for (i, c) in e.char_indices() {
                let mut b = b.to_string();
                b.push(c);
                let mut e = e.to_string();
                e.remove(i);
                self.invoke(&b, &e);
            }
        }
    }
¬†
    fn is_valid(s: &str) -> bool {
        let k = s.find('K').unwrap();
        k > s.find('R').unwrap() && k < s.rfind('R').unwrap() && s.find('B').unwrap()¬†% 2¬†!= s.rfind('B').unwrap()¬†% 2
    }
}
¬†
// Program entry point.
fn main() {
    let mut chess960 = Chess960(BTreeSet::new());
    chess960.invoke("", "KQRRNNBB");
¬†
    for (i, p) in chess960.0.iter().enumerate() {
        println!("{}: {}", i, p);
    }
}
```

# Substring<a id="sec-331"></a>

In this task display a substring:

starting from n characters in and of m length; starting from n characters in, up to the end of the string; whole string minus last character; starting from a known character within the string and of m length; starting from a known substring within the string and of m length.

If the program uses UTF-8 or UTF-16, it must work on any valid Unicode code point, whether in the Basic Multilingual Plane or above it.

The program must reference logical characters (code points), not 8-bit code units for UTF-8 or 16-bit code units for UTF-16.

Programs for other encodings (such as 8-bit ASCII, or EUC-JP) are not required to handle all Unicode characters.

# Synchronous concurrency<a id="sec-332"></a>

The goal of this task is to create two concurrent activities ("Threads" or "Tasks", not processes.) that share data synchronously. Your language may provide syntax or libraries to perform concurrency. Different languages provide different implementations of concurrency, often with different names. Some languages use the term threads, others use the term tasks, while others use co-processes. This task should not be implemented using fork, spawn, or the Linux/UNIX/Win32 pipe command, as communication should be between threads, not processes.

One of the concurrent units will read from a file named "input.txt" and send the contents of that file, one line at a time, to the other concurrent unit, which will print the line it receives to standard output. The printing unit must count the number of lines it prints. After the concurrent unit reading the file sends its last line to the printing unit, the reading unit will request the number of lines printed by the printing unit. The reading unit will then print the number of lines printed by the printing unit.

This task requires two-way communication between the concurrent units. All concurrent units must cleanly terminate at the end of the program.

Works with: rustc 1.4.0-nightly version f84d53ca0 2015-09-06

```rust
use std::fs::File;
use std::io::BufReader;
use std::io::BufRead;
¬†
use std::thread::spawn;
use std::sync::mpsc::{SyncSender, Receiver, sync_channel};
¬†
fn main() {
    let (tx, rx): (SyncSender<String>, Receiver<String>) = sync_channel::<String>(0);
¬†
    // Reader thread.
    spawn(move || {
        let file = File::open("input.txt").unwrap();
        let reader = BufReader::new(file);
¬†
        for line in reader.lines() {
            match line {
                Ok(msg) => tx.send(msg).unwrap(),
                Err(e) => println!("{}", e)
            }
        }
¬†
        drop(tx);
    });
¬†
    // Writer thread.
    spawn(move || {
        let mut loop_count: u16 = 0;
¬†
        loop {
            let recvd = rx.recv();
¬†
            match recvd {
                Ok(msg) => {
                    println!("{}", msg);
                    loop_count += 1;
                },
                Err(_) => break // rx.recv() will only err when tx is closed.
            }
        }
¬†
        println!("Line count: {}", loop_count);
    }).join().unwrap();
}
```

# Primorial numbers<a id="sec-333"></a>

Primorial numbers are those formed by multiplying successive prime numbers.

The primorial number series is:

¬† primorial(0) = ¬† ¬† ¬† ¬† 1 ¬† ¬† ¬† (by definition) ¬† primorial(1) = ¬† ¬† ¬† ¬† 2 ¬† ¬† ¬† (2) ¬† primorial(2) = ¬† ¬† ¬† ¬† 6 ¬† ¬† ¬† (2\*3) ¬† primorial(3) = ¬† ¬† ¬† 30 ¬† ¬† ¬† (2\*3\*5) ¬† primorial(4) = ¬† ¬† 210 ¬† ¬† ¬† (2\*3\*5\*7) ¬† primorial(5) = ¬† 2310 ¬† ¬† ¬† (2\*3\*5\*7\*11) ¬† primorial(6) = 30030 ¬† ¬† ¬† (2\*3\*5\*7\*11\*13) ¬† ¬† ¬† ¬† ‚àô ‚àô ‚àô

To express this mathematically, ¬† primorialn ¬† is ¬† the product of the first ¬† n ¬† (successive) primes:

¬† {\displaystyle primorial<sub>n</sub>=&prod; \_{k=1}<sup>n</sup>prime<sub>k</sub>}

‚îÄ‚îÄ‚îÄ where ¬† {\displaystyle prime<sub>k</sub>} ¬† is the ¬† kth ¬† prime number.

In some sense, generating primorial numbers is similar to factorials.

As with factorials, primorial numbers get large quickly.

task requirements:

¬† Show the first ten primorial numbers ¬† (0 ‚îÄ‚îÄ‚ñ∫ 9, ¬† inclusive). ¬† Show the length of primorial numbers whose index is: ¬† 10 ¬† 100 ¬† 1,000 ¬† 10,000 ¬† and ¬† 100,000. ¬† Show the length of the one millionth primorial number ¬† (optional). ¬† Use exact integers, not approximations.

By ¬† length ¬† (above), it is meant the number of decimal digits in the numbers.

links:

See the MathWorld webpage: ¬† primorial

See the Wikipedia ¬† webpage: ¬† primorial.

See the ¬† ¬† OEIS ¬† ¬† webpage: ¬† A2110.

Related tasks:

Factorial Sequence of primorial primes

```rust
¬†
extern crate primal;
extern crate rayon;
extern crate rug;
¬†
use rayon::prelude::*;
use rug::Integer;
¬†
fn partial(p1¬†: usize, p2¬†: usize) -> String {
    let mut aux = Integer::from(1);
    let (_, hi) = primal::estimate_nth_prime(p2 as u64);
    let sieve = primal::Sieve::new(hi as usize);
    let prime1 = sieve.nth_prime(p1);
    let prime2 = sieve.nth_prime(p2);
¬†
    for i in sieve.primes_from(prime1).take_while(|i| *i <= prime2) {
        aux = Integer::from(aux * i as u32);
    }
    aux.to_string_radix(10)
}
¬†
fn main() {
    let mut j1 = Integer::new();
    for k in [2,3,5,7,11,13,17,19,23,29].iter() { 
        j1.assign_primorial(*k);
        println!("Primorial¬†: {}", j1);
    }
    println!("Digits of primorial 10¬†: {}", partial(1, 10).chars().fold(0, |n, _| n + 1));
    println!("Digits of primorial 100¬†: {}", partial(1, 100).chars().fold(0, |n, _| n + 1));
    println!("Digits of primorial 1_000¬†: {}", partial(1, 1_000).chars().fold(0, |n, _| n + 1));
    println!("Digits of primorial 10_000¬†: {}", partial(1, 10_000).chars().fold(0, |n, _| n + 1));
    println!("Digits of primorial 100_000¬†: {}", partial(1, 100_000).chars().fold(0, |n, _| n + 1));
¬†
    let mut auxi = Integer::from(1);
    let ranges = vec![[1, 300_000], [300_001, 550_000], [550_001, 800_000], [800_001, 1_000_000]];
    let v = ranges.par_iter().map(|value| partial(value[0], value[1])).collect::<Vec<_>>();
    for i in v.iter() {
        auxi =Integer::from(&auxi * i.parse::<Integer>().unwrap());
    }
    let result = auxi.to_string_radix(10).chars().fold(0, |n, _| n+1);
    println!("Digits of primorial 1_000_000¬†: {}",result);
}
¬†
```

using Intel(R) Core(TM) i7-5500U CPU @ 2.40GHz

Output:

```rust
Primorial¬†: 2
Primorial¬†: 6
Primorial¬†: 30
Primorial¬†: 210
Primorial¬†: 2310
Primorial¬†: 30030
Primorial¬†: 510510
Primorial¬†: 9699690
Primorial¬†: 223092870
Primorial¬†: 6469693230
Digits of primorial 10¬†: 10
Digits of primorial 100¬†: 220
Digits of primorial 1_000¬†: 3393
Digits of primorial 10_000¬†: 45337
Digits of primorial 100_000¬†: 563921
Digits of primorial 1_000_000¬†: 6722809

real	0m19.448s
user	1m2.306s
sys	0m0.054s

```

# 4-rings or 4-squares puzzle<a id="sec-334"></a>

Task

Replace ¬† ¬† ¬† a, b, c, d, e, f, ¬† and ¬† g ¬† ¬† ¬† with the decimal digits ¬† LOW ¬† ‚îÄ‚îÄ‚îÄ‚ñ∫ ¬† HIGH such that the sum of the letters inside of each of the four large squares add up to the same sum.

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó      ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              ‚ïë      ‚ïë              ‚ïë
‚ïë      a       ‚ïë      ‚ïë      e       ‚ïë
‚ïë              ‚ïë      ‚ïë              ‚ïë
‚ïë          ‚îå‚îÄ‚îÄ‚îÄ‚ï´‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï´‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚ï´‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚ïë          ‚îÇ   ‚ïë      ‚ïë   ‚îÇ      ‚îÇ   ‚ïë         ‚îÇ
‚ïë          ‚îÇ b ‚ïë      ‚ïë d ‚îÇ      ‚îÇ f ‚ïë         ‚îÇ
‚ïë          ‚îÇ   ‚ïë      ‚ïë   ‚îÇ      ‚îÇ   ‚ïë         ‚îÇ
‚ïë          ‚îÇ   ‚ïë      ‚ïë   ‚îÇ      ‚îÇ   ‚ïë         ‚îÇ
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïù         ‚îÇ
           ‚îÇ       c      ‚îÇ      ‚îÇ      g      ‚îÇ
           ‚îÇ              ‚îÇ      ‚îÇ             ‚îÇ
           ‚îÇ              ‚îÇ      ‚îÇ             ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

```

Show all output here.

¬† Show all solutions for each letter being unique with

```
LOW=1     HIGH=7

```

¬† Show all solutions for each letter being unique with

```
LOW=3     HIGH=9

```

¬† Show only the ¬† number ¬† of solutions when each letter can be non-unique

```
LOW=0     HIGH=9

```

Related task

Solve the no connection puzzle

```rust
¬†
#![feature(inclusive_range_syntax)]
¬†
fn is_unique(a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, g: u8) -> bool {
    a¬†!= b && a¬†!= c && a¬†!= d && a¬†!= e && a¬†!= f && a¬†!= g &&
    b¬†!= c && b¬†!= d && b¬†!= e && b¬†!= f && b¬†!= g &&
    c¬†!= d && c¬†!= e && c¬†!= f && c¬†!= g &&
    d¬†!= e && d¬†!= f && d¬†!= g &&
    e¬†!= f && e¬†!= g &&
    f¬†!= g
}
¬†
fn is_solution(a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, g: u8) -> bool {
    a + b == b + c + d &&
        b + c + d == d + e + f &&
        d + e + f == f + g
}
¬†
fn four_squares(low: u8, high: u8, unique: bool) -> Vec<Vec<u8>> {
    let mut results: Vec<Vec<u8>> = Vec::new();
¬†
    for a in low..=high {
        for b in low..=high {
            for c in low..=high {
                for d in low..=high {
                    for e in low..=high {
                        for f in low..=high {
                            for g in low..=high {
                                if (!unique || is_unique(a, b, c, d, e, f, g)) &&
                                    is_solution(a, b, c, d, e, f, g) {
                                    results.push(vec![a, b, c, d, e, f, g]);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    results
}
¬†
fn print_results(solutions: &Vec<Vec<u8>>) {
    for solution in solutions {
        println!("{:?}", solution)
    }
}
¬†
fn print_results_summary(solutions: usize, low: u8, high: u8, unique: bool) {
    let uniqueness = if unique {
        "unique"
    } else {
        "non-unique"
    };
    println!("{} {} solutions in {} to {} range", solutions, uniqueness, low, high)
}
¬†
fn uniques(low: u8, high: u8) {
    let solutions = four_squares(low, high, true);
    print_results(&solutions);
    print_results_summary(solutions.len(), low, high, true);
}
¬†
fn nonuniques(low: u8, high: u8) {
    let solutions = four_squares(low, high, false);
    print_results_summary(solutions.len(), low, high, false);
}
¬†
fn main() {
    uniques(1, 7);
    println!();
    uniques(3, 9);
    println!();
    nonuniques(0, 9);
}
¬†
```

Output:

```rust
[3, 7, 2, 1, 5, 4, 6]
[4, 5, 3, 1, 6, 2, 7]
[4, 7, 1, 3, 2, 6, 5]
[5, 6, 2, 3, 1, 7, 4]
[6, 4, 1, 5, 2, 3, 7]
[6, 4, 5, 1, 2, 7, 3]
[7, 2, 6, 1, 3, 5, 4]
[7, 3, 2, 5, 1, 4, 6]
8 unique solutions in 1 to 7 range

[7, 8, 3, 4, 5, 6, 9]
[8, 7, 3, 5, 4, 6, 9]
[9, 6, 4, 5, 3, 7, 8]
[9, 6, 5, 4, 3, 8, 7]
4 unique solutions in 3 to 9 range

2860 non-unique solutions in 0 to 9 range

```

# Unbias a random generator<a id="sec-335"></a>

{\displaystyle P<sub>1</sub>}

{\displaystyle P<sub>0</sub>}

{\displaystyle P<sub>1</sub>}

{\displaystyle P<sub>0</sub>}

{\displaystyle P<sub>0</sub>}

{\displaystyle P<sub>1</sub>}

Task details

Use your language's random number generator to create a function/method/subroutine/&#x2026; randN that returns a one or a zero, but with one occurring, on average, 1 out of N times, where N is an integer from the range 3 to 6 inclusive. Create a function unbiased that uses only randN as its source of randomness to become an unbiased generator of random ones and zeroes. For N over its range, generate and show counts of the outputs of randN and unbiased(randN).

The actual unbiasing should be done by generating two numbers at a time from randN and only returning a 1 or 0 if they are different. As long as you always return the first number or always return the second number, the probabilities discussed above should take over the biased probability of randN.

This task is an implementation of Von Neumann debiasing, first described in a 1951 paper.

```rust
#![feature(inclusive_range_syntax)]
¬†
extern crate rand;
¬†
use rand::Rng;
¬†
fn rand_n<R: Rng>(rng: &mut R, n: u32) -> usize {
    rng.gen_weighted_bool(n) as usize // maps `false` to 0 and `true` to 1
}
¬†
fn unbiased<R: Rng>(rng: &mut R, n: u32) -> usize {
    let mut bit = rand_n(rng, n);
    while bit == rand_n(rng, n) {
        bit = rand_n(rng, n);
    }
    bit
}
¬†
fn main() {
    const SAMPLES: usize = 100_000;
    let mut rng = rand::weak_rng();
¬†
    println!(" Bias    rand_n  unbiased");
    for n in 3..=6 {
        let mut count_biased = 0;
        let mut count_unbiased = 0;
        for _ in 0..SAMPLES {
            count_biased += rand_n(&mut rng, n);
            count_unbiased += unbiased(&mut rng, n);
        }
¬†
        let b_percentage = 100.0 * count_biased as f64 / SAMPLES as f64;
        let ub_percentage = 100.0 * count_unbiased as f64 / SAMPLES as f64;
        println!(
            "bias {}:  {:0.2}%   {:0.2}%",
            n, b_percentage, ub_percentage
        );
    }
}
```

Output:

```rust
 Bias    rand_n  unbiased
bias 3:  33.32%   49.80%
bias 4:  25.22%   50.16%
bias 5:  19.91%   50.00%
bias 6:  16.66%   49.95%

```

# Dijkstra's algorithm<a id="sec-336"></a>

Dijkstra's algorithm, conceived by Dutch computer scientist Edsger Dijkstra in 1956 and published in 1959, is a graph search algorithm that solves the single-source shortest path problem for a graph with nonnegative edge path costs, producing a shortest path tree. This algorithm is often used in routing and as a subroutine in other graph algorithms.

For a given source vertex (node) in the graph, the algorithm finds the path with lowest cost (i.e. the shortest path) between that vertex and every other vertex.

For example, if the vertices of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road, Dijkstra's algorithm can be used to find the shortest route between one city and all other cities. As a result, the shortest path first is widely used in network routing protocols, most notably IS-IS and OSPF (Open Shortest Path First).

Important note: The inputs to Dijkstra's algorithm are a directed and weighted graph consisting of 2 or more nodes, generally represented by an adjacency matrix or list, and a start node. A destination node is not specified. The output is a set of edges depicting the shortest path to each destination node.

For the example we start:

```
a->b,cost=7,lastNode=a; a->c,cost=9,lastNode=a; a->d,cost=NA,lastNode=a; a->e,cost=NA,lastNode=a; a->f,cost=14,lastNode=a
The lowest cost is a->b so we add a->b to the output. There is a connection from b->d so we update our input to 
a->c,cost=9,lastNode=a; a->d,cost=22,lastNode=b; a->e,cost=NA,lastNode=a; a->f,cost=14,lastNode=a
The lowest cost is a->c so we add a->c to the output. Paths to d and f are cheaper via c so we update our input to 
a->d,cost=20,lastNode=c; a->e,cost=NA,lastNode=a; a->f,cost=11,lastNode=c
The lowest cost is a->f so we add c->f to the output. We update our input to
a->d,cost=20,lastNode=c; a->e,cost=NA,lastNode=a
The lowest cost is a->d so we add c->d to the output. There is a connection from d->e so we update our input to
a->e,cost=26,lastNode=d
Which just leaves adding d->e to the output.
The output should now be [d->e;c->d;c->f;a->c;a->b]

```

Task

Implement a version of Dijkstra's algorithm that outputs a set of edges depicting the shortest path to each reachable node from an origin. Run your program with the following directed graph starting at node a. Write a program which interprets the output from the above and use it to output the shortest path from node a to nodes e and f .

Vertices Number Name 1 a 2 b 3 c 4 d 5 e 6 f

Edges Start End Cost a b 7 a c 9 a f 14 b c 10 b d 15 c d 11 c f 2 d e 6 e f 9

You can use numbers or names to identify vertices in your program.

See also

Dijkstra's Algorithm vs. A\* Search vs. Concurrent Dijkstra's Algorithm (youtube)

This solution uses a very bare-bones, naive implementation of an adjacency list to represent the graph.

```rust
use std::cmp::Ordering;
use std::collections::BinaryHeap;
use std::usize;
¬†
¬†
struct Grid<T> {
    nodes: Vec<Node<T>>,
}
¬†
struct Node<T> {
    data: T,
    edges: Vec<(usize,usize)>,
}
¬†
#[derive(Copy, Clone, Eq, PartialEq)]
struct State {
    node: usize,
    cost: usize,
}
¬†
// Manually implement Ord so we get a min-heap instead of a max-heap
impl Ord for State {
    fn cmp(&self, other: &Self) -> Ordering {
        other.cost.cmp(&self.cost)
    }
}
¬†
impl PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}
¬†
type WeightedEdge = (usize, usize, usize);
¬†
impl<T> Grid<T> {
    fn new() -> Self {
        Grid { nodes: Vec::new() }
    }
¬†
    fn add_node(&mut self, data: T) -> usize {
        let node = Node {
            edges: Vec::new(),
            data: data,
        };
        self.nodes.push(node);
        self.nodes.len() - 1
    }
¬†
    fn create_edges<'a, I>(&mut self, iterator: I) where I: IntoIterator<Item=&'a WeightedEdge> {
        for &(start,end,weight) in iterator.into_iter() {
            self.nodes[start].edges.push((end,weight));
            self.nodes[end].edges.push((start,weight));
        }
¬†
    }
¬†
    fn find_path(&self, start: usize, end: usize) -> Option<(Vec<usize>, usize)> {
        let mut dist = vec![(usize::MAX, None); self.nodes.len()];
¬†
        let mut heap = BinaryHeap::new();
        dist[start] = (0, None);
        heap.push(State {
            node: start,
            cost: 0,
        });
¬†
        while let Some(State { node, cost }) = heap.pop() {
            if node == end {
                let mut path = Vec::with_capacity(dist.len() / 2);
                let mut current_dist = dist[end];
                path.push(end);
                while let Some(prev) = current_dist.1 {
                    path.push(prev);
                    current_dist = dist[prev];
                }
                path.reverse();
                return Some((path, cost));
            }
¬†
            if cost > dist[node].0 {
                continue;
            }
            for edge in &self.nodes[node].edges {
                let next = State {
                    node: edge.0,
                    cost: cost + edge.1,
                };
                if next.cost < dist[next.node].0 {
                    dist[next.node] = (next.cost, Some(node));
                    heap.push(next);
                }
            }
        }
        None
    }
}
¬†
fn main() {
    let mut grid = Grid::new();
    let (a,b,c,d,e,f) = (grid.add_node("a"), grid.add_node("b"),
                         grid.add_node("c"), grid.add_node("d"),
                         grid.add_node("e"), grid.add_node("f"));
¬†
    grid.create_edges(&[
        (a,b,7) ,(a,c,9) ,(a,f,14),
        (b,c,10),(b,d,15),(c,d,11),
        (c,f,2) ,(d,e,6) ,(e,f,9) ,
    ]);
¬†
    let (path, cost) = grid.find_path(a,e).unwrap();
¬†
    print!("{}", grid.nodes[path[0]].data);
    for i in path.iter().skip(1) {
        print!(" -> {}", grid.nodes[*i].data);
    }
    println!("\nCost: {}", cost);
¬†
}
```

Output:

```rust
Cost: 20
a -> c -> f -> e

```

# Dining philosophers<a id="sec-337"></a>

The dining philosophers problem illustrates non-composability of low-level synchronization primitives like semaphores. It is a modification of a problem posed by Edsger Dijkstra.

Five philosophers, Aristotle, Kant, Spinoza, Marx, and Russell (the tasks) spend their time thinking and eating spaghetti. They eat at a round table with five individual seats. For eating each philosopher needs two forks (the resources). There are five forks on the table, one left and one right of each seat. When a philosopher cannot grab both forks it sits and waits. Eating takes random time, then the philosopher puts the forks down and leaves the dining room. After spending some random time thinking about the nature of the universe, he again becomes hungry, and the circle repeats itself.

It can be observed that a straightforward solution, when forks are implemented by semaphores, is exposed to deadlock. There exist two deadlock states when all five philosophers are sitting at the table holding one fork each. One deadlock state is when each philosopher has grabbed the fork left of him, and another is when each has the fork on his right.

There are many solutions of the problem, program at least one, and explain how the deadlock is prevented.

A Rust implementation of a solution for the Dining Philosophers Problem. We prevent a deadlock by using Dijkstra's solution of making a single diner "left-handed." That is, all diners except one pick up the chopstick "to their left" and then the chopstick "to their right." The remaining diner performs this in reverse.

```rust
use std::thread;
use std::sync::{Mutex, Arc};
¬†
struct Philosopher {
    name: String,
    left: usize,
    right: usize,
}
¬†
impl Philosopher {
    fn new(name: &str, left: usize, right: usize) -> Philosopher {
        Philosopher {
            name: name.to_string(),
            left: left,
            right: right,
        }
    }
¬†
    fn eat(&self, table: &Table) {
        let _left = table.forks[self.left].lock().unwrap();
        let _right = table.forks[self.right].lock().unwrap();
¬†
        println!("{} is eating.", self.name);
¬†
        thread::sleep_ms(1000);
¬†
        println!("{} is done eating.", self.name);
    }
}
¬†
struct Table {
    forks: Vec<Mutex<()>>,
}
¬†
fn main() {
    let table = Arc::new(Table { forks: vec![
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
    ]});
¬†
    let philosophers = vec![
        Philosopher::new("Baruch Spinoza", 0, 1),
        Philosopher::new("Gilles Deleuze", 1, 2),
        Philosopher::new("Karl Marx", 2, 3),
        Philosopher::new("Friedrich Nietzsche", 3, 4),
        Philosopher::new("Michel Foucault", 0, 4),
    ];
¬†
    let handles: Vec<_> = philosophers.into_iter().map(|p| {
        let table = table.clone();
¬†
        thread::spawn(move || {
            p.eat(&table);
        })
    }).collect();
¬†
    for h in handles {
        h.join().unwrap();
    }
}
```

# Convert decimal number to rational<a id="sec-338"></a>

The task is to write a program to transform a decimal number into a fraction in lowest terms.

It is not always possible to do this exactly. For instance, while rational numbers can be converted to decimal representation, some of them need an infinite number of digits to be represented exactly in decimal form. Namely, repeating decimals such as 1/3 = 0.333&#x2026;

Because of this, the following fractions cannot be obtained (reliably) unless the language has some way of representing repeating decimals:

67 / 74 = 0.9(054) = 0.9054054&#x2026; 14 / 27 = 0.(518) = 0.518518&#x2026;

Acceptable output:

0.9054054 ‚Üí 4527027 / 5000000 0.518518 ‚Üí 259259 / 500000

Finite decimals are of course no problem:

0.75 ‚Üí 3 / 4

```rust
¬†
extern crate rand;
extern crate num;
¬†
use num::Integer;
use rand::Rng;
¬†
fn decimal_to_rational (mut n¬†: f64) -> [isize;2] {
    //Based on Farey sequences
    assert!(n.is_finite());
    let flag_neg  = n < 0.0;
    if flag_neg { n = n*(-1.0) }
    if n < std::f64::MIN_POSITIVE { return [0,1] }
    if (n - n.round()).abs() < std::f64::EPSILON { return [n.round() as isize, 1] }
    let mut a¬†: isize = 0;
    let mut b¬†: isize = 1;
    let mut c¬†: isize = n.ceil() as isize;
    let mut d¬†: isize = 1;
    let aux1 = isize::max_value()/2;
    while c < aux1  && d < aux1 {
        let aux2¬†: f64 = (a as f64 + c as f64)/(b as f64 + d as f64);
        if (n - aux2).abs() < std::f64::EPSILON { break } 
        if n > aux2 { 
            a = a + c;
            b = b + d;
        } else {
            c = a + c;
            d = b + d;
        }
    }
    // Make sure that the fraction is irreducible
    let gcd = (a+c).gcd(&(b+d));
    if flag_neg { [-(a + c)/gcd, (b + d)/gcd] } else { [(a + c)/gcd, (b + d)/gcd] }
} 
¬†
#[test]
fn test1 () {
    // Test the function with 1_000_000 random decimal numbers
    let mut rng = rand::thread_rng();
    for _i in 1..1_000_000 {
        let number = rng.gen::<f64>();
        let result = decimal_to_rational(number);
        assert!((number - (result[0] as f64)/(result[1] as f64)).abs() < std::f64::EPSILON);
        assert!(result[0].gcd(&result[1]) == 1);
    }
}
¬†
fn main () {
    let mut rng = rand::thread_rng();
    for _i in 1..10 {
        let number = rng.gen::<f64>();
        let result = decimal_to_rational(number);
        if result[1] == 1 { println!("{} -> {}", number, result[0]) } else { println!("{} ->  {}/{}", number, result[0], result[1]) }
    }
    for i in [-0.9054054, 0.518518, -0.75, 0.5185185185185185, -0.9054054054054054, 0.0, 1.0, 2.0].iter() {
        let result = decimal_to_rational(*i as f64);
        if result[1] == 1 { println!("{} = {}",*i, result[0]) } else { println!("{} =  {}/{}", *i, result[0], result[1]) }
    }
}
¬†
```

First test the function with 1<sub>000</sub><sub>000</sub> random double floats¬†:

```rust
running 1 test
test test1 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

```

Now run it with 10 random double floats and some selected ones printing the results

```rust
0.47783621261626297 -> 36036136/75415247
0.29135687639237284 -> 164756020/565478399
0.04962905490905656 -> 4105111/82715881
0.33418703921783965 -> 16612678/49710719
0.07284921759788943 -> 6252865/85832974
0.783712619202954 -> 62096920/79234299
0.3788902482801324 -> 30401287/80237713
0.03780115715370047 -> 1522201/40268635
0.9975233883406127 -> 79858287/80056556
-0.9054054 ->  -4527027/5000000
0.518518 ->  259259/500000
-0.75 ->  -3/4
0.5185185185185185 ->  14/27
-0.9054054054054054 ->  -67/74
0 -> 0
1 -> 1
2 -> 2

```

# Empty directory<a id="sec-339"></a>

Starting with a path to some directory, determine whether the directory is empty.

An empty directory contains no files nor subdirectories. With Unix or Windows systems, every directory contains an entry for ‚Äú.‚Äù and almost every directory contains ‚Äú..‚Äù (except for a root directory); an empty directory contains no other entries.

```rust
use std::fs::read_dir;
use std::error::Error;
¬†
fn main() {
    for path in std::env::args().skip(1) { // iterate over the arguments, skipping the first (which is the executable)
        match read_dir(path.as_str()) { // try to read the directory specified
            Ok(contents) => {
                let len = contents.collect::<Vec<_>>().len(); // calculate the amount of items in the directory
                if len == 0 {
                    println!("{} is empty", path);
                } else {
                    println!("{} is not empty", path);
                }
            },
            Err(e) => { // If the attempt failed, print the corresponding error msg
                println!("Failed to read directory \"{}\": {}", path, e.description());
            }
        }
    }
}
```

# Aliquot sequence classifications<a id="sec-340"></a>

An aliquot sequence of a positive integer K is defined recursively as the first member being K and subsequent members being the sum of the Proper divisors of the previous term.

If the terms eventually reach 0 then the series for K is said to terminate.

There are several classifications for non termination: If the second term is K then all future terms are also K and so the sequence repeats from the first term with period 1 and K is called perfect. If the third term would be repeating K then the sequence repeats with period 2 and K is called amicable. If the Nth term would be repeating K for the first time, with N > 3 then the sequence repeats with period N - 1 and K is called sociable.

Perfect, amicable and sociable numbers eventually repeat the original number K; there are other repetitions&#x2026; Some K have a sequence that eventually forms a periodic repetition of period 1 but of a number other than K, for example 95 which forms the sequence 95, 25, 6, 6, 6, &#x2026; such K are called aspiring. K that have a sequence that eventually forms a periodic repetition of period >= 2 but of a number other than K, for example 562 which forms the sequence 562, 284, 220, 284, 220, &#x2026; such K are called cyclic.

And finally: Some K form aliquot sequences that are not known to be either terminating or periodic; these K are to be called non-terminating. For the purposes of this task, K is to be classed as non-terminating if it has not been otherwise classed after generating 16 terms or if any term of the sequence is greater than 2\*\*47 = 140,737,488,355,328.

Task

Create routine(s) to generate the aliquot sequence of a positive integer enough to classify it according to the classifications given above. Use it to display the classification and sequences of the numbers one to ten inclusive. Use it to show the classification and sequences of the following integers, in order:

11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488, and optionally 15355717786080.

Show all output on this page.

Related tasks

¬† Abundant, deficient and perfect number classifications. (Classifications from only the first two members of the whole sequence). ¬† Proper divisors ¬† Amicable pairs

```rust
#[derive(Debug)]
enum AliquotType { Terminating, Perfect, Amicable, Sociable, Aspiring, Cyclic, NonTerminating }
¬†
fn classify_aliquot(num: i64) -> (AliquotType, Vec<i64>) {
    let limit = 1i64 << 47; //140737488355328
    let mut terms = Some(num).into_iter().collect::<Vec<_>>();
    for i in 0..16 {
        let n = terms[i];
        let divsum = (1..(n + 1) / 2 + 1).filter(|&x| n¬†% x == 0 && n¬†!= x).fold(0, |sum, x| sum + x);
        let classification = if divsum == 0 {
            Some(AliquotType::Terminating)
        }
        else if divsum > limit {
            Some(AliquotType::NonTerminating)
        }
        else if let Some(prev_idx) = terms.iter().position(|&x| x == divsum) {
            let cycle_len = terms.len() - prev_idx;
            Some(if prev_idx == 0 {
                match cycle_len {
                    1 => AliquotType::Perfect,
                    2 => AliquotType::Amicable,
                    _ => AliquotType::Sociable
                }
            }
            else {
                if cycle_len == 1 {AliquotType::Aspiring} else {AliquotType::Cyclic}
            })
        }
        else {
            None
        };
        terms.push(divsum);
        if let Some(result) = classification {
            return (result, terms);
        }
    }
    (AliquotType::NonTerminating, terms)
}
¬†
fn main() {
    let nums = [1i64, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488/*, 15355717786080*/];
    for num in &nums {
        println!("{} {:?}", num, classify_aliquot(*num));
    }
}
```

Output:

```rust
1 (Terminating, [1, 0])
2 (Terminating, [2, 1, 0])
3 (Terminating, [3, 1, 0])
4 (Terminating, [4, 3, 1, 0])
5 (Terminating, [5, 1, 0])
6 (Perfect, [6, 6])
7 (Terminating, [7, 1, 0])
8 (Terminating, [8, 7, 1, 0])
9 (Terminating, [9, 4, 3, 1, 0])
10 (Terminating, [10, 8, 7, 1, 0])
11 (Terminating, [11, 1, 0])
12 (Terminating, [12, 16, 15, 9, 4, 3, 1, 0])
28 (Perfect, [28, 28])
496 (Perfect, [496, 496])
220 (Amicable, [220, 284, 220])
1184 (Amicable, [1184, 1210, 1184])
12496 (Sociable, [12496, 14288, 15472, 14536, 14264, 12496])
1264460 (Sociable, [1264460, 1547860, 1727636, 1305184, 1264460])
790 (Aspiring, [790, 650, 652, 496, 496])
909 (Aspiring, [909, 417, 143, 25, 6, 6])
562 (Cyclic, [562, 284, 220, 284])
1064 (Cyclic, [1064, 1336, 1184, 1210, 1184])
1488 (NonTerminating, [1488, 2480, 3472, 4464, 8432, 9424, 10416, 21328, 22320, 55056, 95728, 96720, 236592, 459792, 881392, 882384, 1474608])

```

# Animation<a id="sec-341"></a>

Animation is integral to many parts of GUIs, including both the fancy effects when things change used in window managers, and of course games. ¬† The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user. ¬† This task demonstrates this.

Task

Create a window containing the string "Hello World! " (the trailing space is significant).

Make the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front.

When the user clicks on the (windowed) text, it should reverse its direction.

Library: GTK [edit]

```rust
#[cfg(feature = "gtk")]
mod graphical {
    extern crate gtk;
¬†
    use self::gtk::traits::*;
    use self::gtk::{Inhibit, Window, WindowType};
    use std::ops::Not;
    use std::sync::{Arc, RwLock};
¬†
    pub fn create_window() {
        gtk::init().expect("Failed to initialize GTK");
¬†
        let window = Window::new(WindowType::Toplevel);
        window.connect_delete_event(|_, _| {
            gtk::main_quit();
            Inhibit(false)
        });
        let button = gtk::Button::new_with_label("Hello World! ");
        window.add(&button);
¬†
        let lock = Arc::new(RwLock::new(false));
¬†
        let lock_button = lock.clone();
        button.connect_clicked(move |_| {
            let mut reverse = lock_button.write().unwrap();
            *reverse = reverse.not();
        });
¬†
        let lock_thread = lock.clone();
        gtk::timeout_add(100, move || {
            let reverse = lock_thread.read().unwrap();
            let mut text = button.get_label().unwrap();
            let len = &text.len();
¬†
            if *reverse {
                let begin = &text.split_off(1);
                text.insert_str(0, begin);
            } else {
                let end = &text.split_off(len - 1);
                text.insert_str(0, end);
            }
¬†
            button.set_label(&text);
¬†
            gtk::Continue(true)
        });
¬†
        window.show_all();
        gtk::main();
    }
}
¬†
¬†
#[cfg(feature = "gtk")]
fn main() {
    graphical::create_window();
}
¬†
#[cfg(not(feature = "gtk"))]
fn main() {}
```

# Deal cards for FreeCell<a id="sec-342"></a>

Free Cell is the solitaire card game that Paul Alfille introduced to the PLATO system in 1978. Jim Horne, at Microsoft, changed the name to FreeCell and reimplemented the game for DOS, then Windows. This version introduced 32000 numbered deals. (The FreeCell FAQ tells this history.)

As the game became popular, Jim Horne disclosed the algorithm, and other implementations of FreeCell began to reproduce the Microsoft deals. These deals are numbered from 1 to 32000. Newer versions from Microsoft have 1 million deals, numbered from 1 to 1000000; some implementations allow numbers outside that range.

The algorithm uses this linear congruential generator from Microsoft C:

{\displaystyle state<sub>n+1</sub>&equiv; 214013&times; state<sub>n</sub>+2531011{\pmod {2<sup>31</sup>}}} {\displaystyle rand<sub>n</sub>=state<sub>n</sub>&divide; 2<sup>16</sup>} {\displaystyle rand<sub>n</sub>} is in range 0 to 32767. Rosetta Code has another task, linear congruential generator, with code for this RNG in several languages.

The algorithm follows:

Seed the RNG with the number of the deal. Create an array of 52 cards: Ace of Clubs, Ace of Diamonds, Ace of Hearts, Ace of Spades, 2 of Clubs, 2 of Diamonds, and so on through the ranks: Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King. The array indexes are 0 to 51, with Ace of Clubs at 0, and King of Spades at 51. Until the array is empty: Choose a random card at index ‚â° next random number (mod array length). Swap this random card with the last card of the array. Remove this random card from the array. (Array length goes down by 1.) Deal this random card. Deal all 52 cards, face up, across 8 columns. The first 8 cards go in 8 columns, the next 8 cards go on the first 8 cards, and so on.

Order to deal cards Game #1 Game #617

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52

JD 2D 9H JC 5D 7H 7C 5H KD KC 9S 5S AD QC KH 3H 2S KS 9D QD JS AS AH 3C 4C 5C TS QH 4H AC 4D 7S 3S TD 4S TH 8H 2C JH 7D 6D 8S 8D QS 6C 3D 8C TC 6S 9C 2H 6H

7D AD 5C 3S 5S 8C 2D AH TD 7S QD AC 6D 8H AS KH TH QC 3H 9D 6S 8D 3D TC KD 5H 9S 3C 8S 7H 4D JS 4C QS 9C 9H 7C 6H 2C 2S 4S TS 2H 5D JC 6C JH QH JD KS KC 4H

Deals can also be checked against FreeCell solutions to 1000000 games. (Summon a video solution, and it displays the initial deal.)

Write a program to take a deal number and deal cards in the same order as this algorithm. The program may display the cards with ASCII, with Unicode, by drawing graphics, or any other way.

Based on JavaScript.

```rust
// Code available at https://rosettacode.org/wiki/Linear_congruential_generator#Rust
extern crate linear_congruential_generator;
¬†
use linear_congruential_generator::{MsLcg, Rng, SeedableRng};
¬†
// We can't use `rand::Rng::shuffle` because it uses the more uniform `rand::Rng::gen_range`
// (`% range` is subject to modulo bias).  If an exact match of the old dealer is not needed,
// `rand::Rng::shuffle` should be used.
fn shuffle<T>(rng: &mut MsLcg, deck: &mut [T]) {
    let len = deck.len() as u32;
    for i in (1..len).rev() {
        let j = rng.next_u32()¬†% (i + 1);
        deck.swap(i as usize, j as usize);
    }
}
¬†
fn gen_deck() -> Vec<String> {
    const RANKS: [char; 13] = ['A','2','3','4','5','6','7','8','9','T','J','Q','K'];
    const SUITS: [char; 4] = ['C', 'D', 'H', 'S'];
¬†
    let render_card = |card: usize| {
        let (suit, rank) = (card¬†% 4, card / 4);
        format!("{}{}", RANKS[rank], SUITS[suit])
    };
¬†
    (0..52).map(render_card).collect()
}
¬†
fn deal_ms_fc_board(seed: u32) -> Vec<String> {
    let mut rng = MsLcg::from_seed(seed);
    let mut deck = gen_deck();
¬†
    shuffle(&mut rng, &mut deck);
    deck.reverse();
¬†
    deck.chunks(8).map(|row| row.join(" ")).collect::<Vec<_>>()
}
¬†
fn main() {
    let seed = std::env::args()
        .nth(1)
        .and_then(|n| n.parse().ok())
        .expect("A 32-bit seed is required");
¬†
    for row in deal_ms_fc_board(seed) {
        println!(": {}", row);
    }
}
¬†
```

# Parsing/Shunting-yard algorithm<a id="sec-343"></a>

Task

Given the operator characteristics and input from the Shunting-yard algorithm page and tables, use the algorithm to show the changes in the operator stack and RPN output as each individual token is processed.

Assume an input of a correct, space separated, string of tokens representing an infix expression Generate a space separated output string representing the RPN Test with the input string:

3 + 4 \* 2 / ( 1 - 5 ) ^ 2 ^ 3

print and display the output here. Operator precedence is given in this table:

operator precedence associativity operation ^ 4 right exponentiation

\* 3 left multiplication / 3 left division

-   2 left addition
-   2 left subtraction

Extra credit

Add extra text explaining the actions and an optional comment for the action on receipt of each token.

Note

The handling of functions and arguments is not required.

See also

Parsing/RPN calculator algorithm for a method of calculating a final value from this output RPN expression. Parsing/RPN to infix conversion.

```rust
type Number = f64;
¬†
#[derive(Debug, Copy, Clone, PartialEq)]
struct Operator {
    token: char,
    operation: fn(Number, Number) -> Number,
    precedence: u8,
    is_left_associative: bool,
}
¬†
#[derive(Debug, Clone, PartialEq)]
enum Token {
    Digit(Number),
    Operator(Operator),
    LeftParen,
    RightParen,
}
¬†
impl Operator {
    fn new_token(
        token: char,
        precedence: u8,
        is_left_associative: bool,
        operation: fn(Number, Number) -> Number,
    ) -> Token {
        Token::Operator(Operator {
            token: token,
            operation: operation,
            precedence: precedence,
            is_left_associative,
        })
    }
¬†
    fn apply(&self, x: Number, y: Number) -> Number {
        (self.operation)(x, y)
    }
}
¬†
trait Stack<T> {
    fn top(&self) -> Option<T>;
}
¬†
impl<T: Clone> Stack<T> for Vec<T> {
    fn top(&self) -> Option<T> {
        if self.is_empty() {
            return None;
        }
        self.get(self.len() - 1).map(|value| value.clone())
    }
}
fn lex_token(input: char) -> Result<Token, char> {
    match input {
        '0'...'9' => Ok(Token::Digit(input.to_digit(10).unwrap() as Number)),
        '+' => Ok(Operator::new_token('+', 1, true, |x, y| x + y)),
        '-' => Ok(Operator::new_token('-', 1, true, |x, y| x - y)),
        '*' => Ok(Operator::new_token('*', 2, true, |x, y| x * y)),
        '/' => Ok(Operator::new_token('/', 2, true, |x, y| x / y)),
        '^' => Ok(Operator::new_token('^', 3, false, |x, y| x.powf(y))),
        '(' => Ok(Token::LeftParen),
        ')' => Ok(Token::RightParen),
        _ => Err(input),
    }
}
¬†
fn lex(input: String) -> Result<Vec<Token>, char> {
    input
        .chars()
        .filter(|c|¬†!c.is_whitespace())
        .map(lex_token)
        .collect()
}
¬†
fn tilt_until(operators: &mut Vec<Token>, output: &mut Vec<Token>, stop: Token) -> bool {
    while let Some(token) = operators.pop() {
        if token == stop {
            return true;
        }
        output.push(token)
    }
    false
}
¬†
fn shunting_yard(tokens: Vec<Token>) -> Result<Vec<Token>, String> {
    let mut output: Vec<Token> = Vec::new();
    let mut operators: Vec<Token> = Vec::new();
¬†
    for token in tokens {
        match token {
            Token::Digit(_) => output.push(token),
            Token::LeftParen => operators.push(token),
            Token::Operator(operator) => {
                while let Some(top) = operators.top() {
                    match top {
                        Token::LeftParen => break,
                        Token::Operator(top_op) => {
                            let p = top_op.precedence;
                            let q = operator.precedence;
                            if (p > q) || (p == q && operator.is_left_associative) {
                                output.push(operators.pop().unwrap());
                            } else {
                                break;
                            }
                        }
                        _ => unreachable!("{:?} must not be on operator stack", token),
                    }
                }
                operators.push(token);
            }
            Token::RightParen => {
                if¬†!tilt_until(&mut operators, &mut output, Token::LeftParen) {
                    return Err(String::from("Mismatched ')'"));
                }
            }
        }
    }
¬†
    if tilt_until(&mut operators, &mut output, Token::LeftParen) {
        return Err(String::from("Mismatched '('"));
    }
¬†
    assert!(operators.is_empty());
    Ok(output)
}
¬†
fn calculate(postfix_tokens: Vec<Token>) -> Result<Number, String> {
    let mut stack = Vec::new();
¬†
    for token in postfix_tokens {
        match token {
            Token::Digit(number) => stack.push(number),
            Token::Operator(operator) => {
                if let Some(y) = stack.pop() {
                    if let Some(x) = stack.pop() {
                        stack.push(operator.apply(x, y));
                        continue;
                    }
                }
                return Err(format!("Missing operand for operator '{}'", operator.token));
            }
            _ => unreachable!("Unexpected token {:?} during calculation", token),
        }
    }
¬†
    assert!(stack.len() == 1);
    Ok(stack.pop().unwrap())
}
¬†
fn run(input: String) -> Result<Number, String> {
    let tokens = match lex(input) {
        Ok(tokens) => tokens,
        Err(c) => return Err(format!("Invalid character: {}", c)),
    };
    let postfix_tokens = match shunting_yard(tokens) {
        Ok(tokens) => tokens,
        Err(message) => return Err(message),
    };
¬†
    calculate(postfix_tokens)
}
```

# Random number generator (device)<a id="sec-344"></a>

Task

If your system has a means to generate random numbers involving not only a software algorithm ¬† (like the /dev/urandom devices in Unix), ¬† then:

show how to obtain a random 32-bit number from that mechanism.

rand used to be part of Rust standard library but it was extracted as a 'crate' (<https://crates.io/crates/rand>). OsRng uses the appropriate device for many platforms including Unix, Windows, BSD, and iOS (listed here). Other methods like RDRAND can be found in other crates (<https://crates.io/crates/rdrand>).

```rust
extern crate rand;
¬†
use rand::{OsRng, Rng};
¬†
fn main() {
    // because `OsRng` opens files, it may fail
    let mut rng = match OsRng::new() {
        Ok(v) => v,
        Err(e) => panic!("Failed to obtain OS RNG: {}", e)
    };
¬†
    let rand_num: u32 = rng.gen();
    println!("{}", rand_num);
}
```

# Extract file extension<a id="sec-345"></a>

Filename extensions are a rudimentary but commonly used way of identifying files types.

Task[edit]

Write a function or program that

takes one string argument representing the path/URL to a file returns the filename extension according to the below specification, or an empty string if the filename has no extension.

If your programming language (or standard library) has built-in functionality for extracting a filename extension, show how it would be used and how exactly its behavior differs from this specification.

Specification

For the purposes of this task, a filename extension

occurs at the very end of the filename consists of a period, followed solely by one or more ASCII letters or digits (A-Z, a-z, 0-9)

Test cases

Input Output Comment <http://example.com/download.tar.gz> .gz CharacterModel.3DS .3DS .desktop .desktop document empty string document.txt<sub>backup</sub> empty string, because \_ is not a letter or number /etc/pam.d/login empty string, as the period is in the parent directory name rather than the filename

```rust
use std::path::Path;
¬†
fn main() {
    let filenames = &[
        "http://example.com/download.tar.gz",
        "CharacterModel.3DS",
        ".desktop",
        "document",
        "document.txt_backup",
        "/etc/pam.d/login",
    ];
¬†
    for filename in filenames {
        println!(
            "{:34} | {:8} | {:?}",
            filename,
            extension(filename),
            Path::new(filename).extension()
        );
    }
}
¬†
fn extension(filename: &str) -> &str {
    filename
        .rfind('.')
        .map(|idx| &filename[idx..])
        .filter(|ext| ext.chars().skip(1).all(|c| c.is_ascii_alphanumeric()))
        .unwrap_or("")
}
```

The built-in method requires a filename before the extension, allows any non-period character to appear in the extension, and returns None if no extension is found.

Output:

```rust
http://example.com/download.tar.gz | .gz      | Some("gz")
CharacterModel.3DS                 | .3DS     | Some("3DS")
.desktop                           | .desktop | None
document                           |          | None
document.txt_backup                |          | Some("txt_backup")
/etc/pam.d/login                   |          | None

```

# Draw a clock<a id="sec-346"></a>

Task

Draw a clock.

More specific:

Draw a time keeping device. It can be a stopwatch, hourglass, sundial, a mouth counting "one thousand and one", anything. Only showing the seconds is required, e.g.: a watch with just a second hand will suffice. However, it must clearly change every second, and the change must cycle every so often (one minute, 30 seconds, etc.) It must be drawn; printing a string of numbers to your terminal doesn't qualify. Both text-based and graphical drawing are OK. The clock is unlikely to be used to control space flights, so it needs not be hyper-accurate, but it should be usable, meaning if one can read the seconds off the clock, it must agree with the system clock. A clock is rarely (never?) a major application: don't be a CPU hog and poll the system timer every microsecond, use a proper timer/signal/event from your system or language instead. For a bad example, many OpenGL programs update the frame-buffer in a busy loop even if no redraw is needed, which is very undesirable for this task. A clock is rarely (never?) a major application: try to keep your code simple and to the point. Don't write something too elaborate or convoluted, instead do whatever is natural, concise and clear in your language.

Key points

animate simple object timed event polling system resources code clarity

```rust
// cargo-deps: time="0.1"
extern crate time;
¬†
use std::thread;
use std::time::Duration;
¬†
const TOP: &str = " ‚°é‚¢â‚¢µ ‚†Ä‚¢∫‚†Ä ‚†ä‚†â‚°± ‚†ä‚£â‚°± ‚¢Ä‚†î‚°á ‚£è‚£â‚°â ‚£é‚£â‚°Å ‚†ä‚¢â‚†ù ‚¢é‚£â‚°± ‚°é‚†â‚¢± ‚†Ä‚†∂‚†Ä";
const BOT: &str = " ‚¢ó‚£Å‚°∏ ‚¢Ä‚£∏‚£Ä ‚£î‚£â‚£Ä ‚¢Ñ‚£Ä‚°∏ ‚†â‚†â‚°è ‚¢Ñ‚£Ä‚°∏ ‚¢á‚£Ä‚°∏ ‚¢∞‚†Å‚†Ä ‚¢á‚£Ä‚°∏ ‚¢à‚£â‚°π ‚†Ä‚†∂‚†Ä";
¬†
fn main() {
    let top: Vec<&str> = TOP.split_whitespace().collect();
    let bot: Vec<&str> = BOT.split_whitespace().collect();
¬†
    loop {
        let tm = &time::now().rfc822().to_string()[17..25];
        let top_str: String = tm.chars().map(|x| top[x as usize - '0' as usize]).collect();
        let bot_str: String = tm.chars().map(|x| bot[x as usize - '0' as usize]).collect();
¬†
        clear_screen();
        println!("{}", top_str);
        println!("{}", bot_str);
¬†
        thread::sleep(Duration::from_secs(1));
    }
}
¬†
fn clear_screen() {
    println!("{}[H{}[J", 27 as char, 27 as char);
}
```

# Lychrel numbers<a id="sec-347"></a>

Take an integer n, greater than zero. Form the next n of its series by reversing the digits of the current n and adding the result to the current n. Stop when n becomes palindromic - i.e. the digits of n in reverse order == n.

The above recurrence relation when applied to most starting numbers n = 1, 2, &#x2026; terminates in a palindrome quite quickly, for example if n0 = 12 we get

```
12
12 + 21 = 33, a palindrome!
```

And if n0 = 55 we get

```
55
55 + 55 = 110
110 + 011 = 121, a palindrome!
```

Notice that the check for a palindrome happens after an addition.

Some starting numbers seem to go on forever; the recurrence relation for 196 has been calculated for millions of repetitions forming numbers with millions of digits, without forming a palindrome. These numbers that do not end in a palindrome are called Lychrel numbers.

For the purposes of this task a Lychrel number is any starting number that does not form a palindrome within 500 (or more) iterations.

Seed and related Lychrel numbers

Any integer produced in the sequence of a Lychrel number is also a Lychrel number.

In general, any sequence from one Lychrel number might converge to join the sequence from a prior Lychrel number candidate; for example the sequences for the numbers 196 and then 689 begin:

```
196
196 + 691 = 887
887 + 788 = 1675
1675 + 5761 = 7436
7436 + 6347 = 13783
13783 + 38731 = 52514
52514 + 41525 = 94039
...


689
689 + 986 = 1675
1675 + 5761 = 7436
...
```

So we see that the sequence starting with 689 converges to, and continues with the same numbers as that for 196. Because of this we can further split the Lychrel numbers into true Seed Lychrel number candidates, and Related numbers that produce no palindromes but have integers in their sequence seen as part of the sequence generated from a lower Lychrel number.

Task

Find the number of seed Lychrel number candidates and related numbers for n in the range 1..10000 inclusive. (With that iteration limit of 500). Print the number of seed Lychrels found; the actual seed Lychrels; and just the number of relateds found. Print any seed Lychrel or related number that is itself a palindrome.

Show all output here.

References

What's special about 196? Numberphile video. A023108 Positive integers which apparently never result in a palindrome under repeated applications of the function f(x) = x + (x with digits reversed). Status of the 196 conjecture? Mathoverflow.

This uses the num library for arbitrary-sized integer support as normal integers will overflow.

Cargo.toml

```rust
[package]
name = "lychrel"
version = "0.1.0"
authors = ["monsieursquirrel"]

[dependencies]
num = "0.1.27"
```

src/main.rs

```rust
extern crate num;
use num::FromPrimitive;
use num::bigint::BigInt;
¬†
use std::collections::HashSet;
¬†
/// Reverse a number then add it to the original.
fn rev_add(num: &BigInt) -> BigInt {
    let rev_string: String = num.to_string().chars().rev().collect();
    // should be safe, our string is guaranteed to be a number
    let rev_val: BigInt = rev_string.parse().unwrap();
    num + rev_val
}
¬†
/// Check if a number is a palindrome when written in base 10.
fn is_palindrome(num: &BigInt) -> bool {
    let num_string = num.to_string();
    let rev_string: String = num_string.chars().rev().collect();
    let comp_len = num_string.len() / 2;
    num_string[0..comp_len] == rev_string[0..comp_len]
}
¬†
/// Perform a lychrel test on a number, stopping after max_tests
/// Returns the sequence of numbers if this number is a lychrel, None otherwise.
fn test_lychrel(num: &BigInt, max_tests: usize) -> Option<Vec<BigInt>> {
    let mut sequence = Vec::<BigInt>::new();
¬†
    let is_lychrel = (0..max_tests)
        .scan(num.clone(), |current, _| {
            *current = rev_add(current);
            Some(current.clone())
        })
        .inspect(|current| sequence.push(current.clone()))
        .filter(|curent| is_palindrome(curent))
        .next()
        .is_none();
¬†
    if is_lychrel {
        Some(sequence)
    }
    else {
        None
    }
}
¬†
/// Determine if the sequence for a lychrel number is related to a previously seen sequence
fn is_related(seq: &Vec<BigInt>, lychrel_seq_numbers: &HashSet<BigInt>) -> bool {
    seq.iter().filter(|num| lychrel_seq_numbers.contains(num)).next().is_some()
}
¬†
/// Find the lychrel numbers up to max_num (inclusive).
/// Returns a tuple (lychrel numbers, related numbers, palindrome lychrel/related numbers)
fn find_lychrels(max_num: u64, max_tests: usize) -> (Vec<BigInt>, Vec<BigInt>, Vec<BigInt>) {
    // storage for various outputs
    let mut lychrels = Vec::<BigInt>::new();
    let mut relateds = Vec::<BigInt>::new();
    let mut palindrome_lychrels = Vec::<BigInt>::new();
¬†
    let mut lychrel_seq_numbers: HashSet<BigInt> = HashSet::new();
¬†
    for i in (1..(max_num + 1)) {
        let num = FromPrimitive::from_u64(i).unwrap();
        let maybe_lychrel = test_lychrel(&num, max_tests);
¬†
        if let Some(lychrel_seq) = maybe_lychrel {
            // it's a lychrel - check if it's a related number
            let related = is_related(&lychrel_seq, &lychrel_seq_numbers);
¬†
            // update our sequences
            for seq_num in lychrel_seq.into_iter() {
                lychrel_seq_numbers.insert(seq_num);
            }
¬†
            if¬†!related {
                // the number has a new lychrel sequence, store it
                lychrels.push(num.clone());
            }
            else {
                // just count it as a related number
                relateds.push(num.clone());
            }
¬†
            if is_palindrome(&num) {
                // doesn't matter if palindromes are related or not
                palindrome_lychrels.push(num.clone());
            }
        }
    }
¬†
    (lychrels, relateds, palindrome_lychrels)
}
¬†
fn print_nums(before: &str, numbers: &Vec<BigInt>) {
    print!("{}", before);
    for (i, current) in numbers.iter().enumerate() {
        print!("{}", current);
        if i + 1 < numbers.len() {
            print!(", ");
        }
    }
    println!("");
}
¬†
fn main() {
    let max_num: u64 = 10_000;
    let max_tests: usize = 500;
¬†
    println!("Calculations using n = 1..{} and limiting each search to {} reverse-digits-and-adds",
        max_num, max_tests);
¬†
    let (lychrels, relateds, palindrome_lychrels) = find_lychrels(max_num, max_tests);
¬†
    println!("Number of Lychrel numbers: {}", lychrels.len());
    print_nums("Lychrel numbers: ", &lychrels);
    println!("Number of Lychrel related: {}", relateds.len());
    println!("Number of Lychrel palindromes: {}", palindrome_lychrels.len());
    print_nums("Lychrel palindromes: ", &palindrome_lychrels);
}
```

Output:

```rust
Calculations using n = 1..10000 and limiting each search to 500 reverse-digits-and-adds
Number of Lychrel numbers: 5
Lychrel numbers: 196, 879, 1997, 7059, 9999
Number of Lychrel related: 244
Number of Lychrel palindromes: 3
Lychrel palindromes: 4994, 8778, 9999
```

# Repeat<a id="sec-348"></a>

Task

Write a procedure which accepts as arguments another procedure and a positive integer.

The latter procedure is executed a number of times equal to the accepted integer.

```rust
// Repeat the function f, n times.
fn repeat<F>(f: &F, n: u32)
    where F: Fn() {
    for _ in 0..n {
        f();
    }
}
¬†
fn static_fn() {
    print!("Static ");
}
¬†
fn main() {
    // Repeat a static function.
    repeat(&static_fn, 4);
¬†
    println!("");
¬†
    // Repeat an anonymous closure.
    repeat(&|| print!("Closure "), 5);
}
```

Output:

```rust
Static Static Static Static
Closure Closure Closure Closure Closure
```

# Knuth's algorithm S<a id="sec-349"></a>

This is a method of randomly sampling n items from a set of M items, with equal probability; where M >= n and M, the number of items is unknown until the end. This means that the equal probability sampling should be maintained for all successive items > n as they become available (although the content of successive samples can change).

The algorithm Select the first n items as the sample as they become available; For the i-th item where i > n, have a random chance of n/i of keeping it. If failing this chance, the sample remains the same. If not, have it randomly (1/n) replace one of the previously selected n items of the sample. Repeat ¬† 2nd step ¬† for any subsequent items.

The Task Create a function s<sub>of</sub><sub>n</sub><sub>creator</sub> that given {\displaystyle n} the maximum sample size, returns a function s<sub>of</sub><sub>n</sub> that takes one parameter, item. Function s<sub>of</sub><sub>n</sub> when called with successive items returns an equi-weighted random sample of up to n of its items so far, each time it is called, calculated using Knuths Algorithm S. Test your functions by printing and showing the frequency of occurrences of the selected digits from 100,000 repetitions of: Use the s<sub>of</sub><sub>n</sub><sub>creator</sub> with n == 3 to generate an s<sub>of</sub><sub>n</sub>. call s<sub>of</sub><sub>n</sub> with each of the digits 0 to 9 in order, keeping the returned three digits of its random sampling from its last call with argument item=9.

Note: A class taking n and generating a callable instance/function might also be used.

Reference

The Art of Computer Programming, Vol 2, 3.4.2 p.142

Related tasks

One of n lines in a file Accumulator factory

Library: rand 0.3

```rust
use rand::{Rng,weak_rng};
¬†
struct SofN<R: Rng+Sized, T> {
    rng: R,
    sample: Vec<T>,
    i: usize,
    n: usize,
}
¬†
impl<R: Rng, T> SofN<R, T> {
    fn new(rng: R, n: usize) -> Self {
        SofN{rng, sample: Vec::new(), i: 0, n}
    }
¬†
    fn add(&mut self, item: T) {
        self.i += 1;
        if self.i <= self.n {
            self.sample.push(item);
        } else if self.rng.gen_range(0, self.i) < self.n {
            self.sample[self.rng.gen_range(0, self.n)] = item;
        }
    }
¬†
    fn sample(&self) -> &Vec<T> {
        &self.sample
    }
}
¬†
¬†
pub fn main() {
    const MAX: usize = 10;
    let mut bin: [i32; MAX] = Default::default();
    for _ in 0..100000 {
        let mut s_of_n = SofN::new(weak_rng(), 3);
¬†
        for i in 0..MAX { s_of_n.add(i); }
¬†
        for s in s_of_n.sample() {
            bin[*s] += 1;
        }
    }
¬†
    for (i, x) in bin.iter().enumerate() {
        println!("frequency of {}: {}", i, x);
    }
}
```

Output:

```rust
frequency of 0: 29883
frequency of 1: 29901
frequency of 2: 29896
frequency of 3: 30029
frequency of 4: 30017
frequency of 5: 29850
frequency of 6: 30139
frequency of 7: 30252
frequency of 8: 30030
frequency of 9: 30003

```

# Constrained genericity<a id="sec-350"></a>

Constrained genericity or bounded quantification means that a parametrized type or function (see parametric polymorphism) can only be instantiated on types fulfilling some conditions, even if those conditions are not used in that function.

Say a type is called "eatable" if you can call the function eat on it. Write a generic type FoodBox which contains a collection of objects of a type given as parameter, but can only be instantiated on eatable types. The FoodBox shall not use the function eat in any way (i.e. without the explicit restriction, it could be instantiated on any type). The specification of a type being eatable should be as generic as possible in your language (i.e. the restrictions on the implementation of eatable types should be as minimal as possible). Also explain the restrictions, if any, on the implementation of eatable types, and show at least one example of an eatable type.

```rust
¬†
// This declares the "Eatable" constraint. It could contain no function.
trait Eatable {
    fn eat();
}
¬†
// This declares the generic "FoodBox" type,
// whose parameter must satisfy the "Eatable" constraint.
// The objects of this type contain a vector of eatable objects.
struct FoodBox<T: Eatable> {
    _data: Vec<T>,
}
¬†
// This implements the functions associated with the "FoodBox" type.
// This statement is not required, but here it is used
// to declare a handy "new" constructor.
impl<T: Eatable> FoodBox<T> {
    fn new() -> FoodBox<T> {
        FoodBox::<T> { _data: Vec::<T>::new() }
    }
}
¬†
// This declares a simple type.
struct Banana {}
¬†
// This makes the "Banana" type satisfy the "Eatable" constraint.
// For that, every declaration inside the declaration of "Eatable"
// must be implemented here.
impl Eatable for Banana {
    fn eat() {}
}
¬†
// This makes also the primitive "char" type satisfy the "Eatable" constraint.
impl Eatable for char {
    fn eat() {}
}
¬†
fn main() {
    // This instantiate a "FoodBox" parameterized by the "Banana" type.
    // It is allowed as "Banana" implements "Eatable".
    let _fb1 = FoodBox::<Banana>::new();
¬†
    // This instantiate a "FoodBox" parameterized by the "char" type.
    // It is allowed, as "char" implements "Eatable".
    let _fb2 = FoodBox::<char>::new();
¬†
    // This instantiate a "FoodBox" parameterized by the "bool" type.
    // It is NOT allowed, as "bool" does not implement "Eatable".
    //let _fb3 = FoodBox::<bool>::new();
}
¬†
```

# DNS query<a id="sec-351"></a>

DNS is an internet service that maps domain names, like rosettacode.org, to IP addresses, like 66.220.0.231.

Use DNS to resolve www.kame.net to both IPv4 and IPv6 addresses. Print these addresses.

```rust
use std::net::ToSocketAddrs;
¬†
fn main() {
    let host = "www.kame.net";
    // Ideally, we would want to use std::net::lookup_host to resolve the host ips,
    // but at time of writing this, it is still unstable. Fortunately, we can
    // still resolve using the ToSocketAddrs trait, but we need to add a port,
    // so we use the dummy port 0.
    let host_port = (host, 0);
    let ip_iter = host_port.to_socket_addrs().unwrap();
¬†
¬†
    for ip_port in ip_iter {
        println!("{}", ip_port.ip());
    }
}
```

```rust
203.178.141.194
2001:200:dff:fff1:216:3eff:feb1:44d7
```

# Smith numbers<a id="sec-352"></a>

Smith numbers are numbers such that the sum of the decimal digits of the integers that make up that number is the same as the sum of the decimal digits of its prime factors excluding 1.

By definition, all primes are excluded as they (naturally) satisfy this condition!

Smith numbers are also known as ¬† joke ¬† numbers.

Example

Using the number 166 Find the prime factors of 166 which are: 2 x 83 Then, take those two prime factors and sum all their decimal digits: 2 + 8 + 3 which is 13 Then, take the decimal digits of 166 and add their decimal digits: 1 + 6 + 6 which is 13 Therefore, the number 166 is a Smith number.

Task

Write a program to find all Smith numbers below 10000.

See also

from Wikipedia: ¬† [Smith number]. from MathWorld: ¬† [Smith number]. from OEIS A6753: ¬† [OEIS sequence A6753]. from OEIS A104170: ¬† [Number of Smith numbers below 10<sup>n</sup>]. from The Prime pages: ¬† [Smith numbers].

```rust
fn main () {
    //We just need the primes below 100
    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];
    let mut solution = Vec::new();
    let mut number;
    for i in 4..10000 {
        //Factorize each number below 10.000
        let mut prime_factors = Vec::new();
        number = i;
        for j in &primes {
            while number¬†% j == 0 {
                number = number / j;
                prime_factors.push(j);
            }
            if number == 1 { break; }
        }
        //Number is 1 (not a prime factor) if the factorization is complete or a prime bigger than 100
        if number¬†!= 1 { prime_factors.push(&number); }
        //Avoid the prime numbers
        if prime_factors.len() < 2 { continue; }
        //Check the smith number definition
        if prime_factors.iter().fold(0, |n,x| n + x.to_string().chars().map(|d| d.to_digit(10).unwrap()).fold(0, |n,x| n + x))  
            == i.to_string().chars().map(|d| d.to_digit(10).unwrap()).fold(0, |n,x| n + x) {
            solution.push(i);
        }
    }
    println!("Smith numbers below 10000 ({})¬†: {:?}",solution.len(), solution);
}
```

Output:

```rust
Smith numbers below 10000 (376)¬†: [4, 22, 27, 58, 85, 94, 121, 166, 202, 265, 274, 319, 346, 355, 378, 382, 391, 438, 454, 483, 517, 526, 535, 562, 576, 588, 627, 634, 636, 645, 648, 654, 663, 666, 690, 706, 728, 729, 762, 778, 825, 852, 861, 895, 913, 915, 922, 958, 985, 1086, 1111, 1165, 1219, 1255, 1282, 1284, 1376, 1449, 1507, 1581, 1626, 1633, 1642, 1678, 1736, 1755, 1776, 1795, 1822, 1842, 1858, 1872, 1881, 1894, 1903, 1908, 1921, 1935, 1952, 1962, 1966, 2038, 2067, 2079, 2155, 2173, 2182, 2218, 2227, 2265, 2286, 2326, 2362, 2366, 2373, 2409, 2434, 2461, 2475, 2484, 2515, 2556, 2576, 2578, 2583, 2605, 2614, 2679, 2688, 2722, 2745, 2751, 2785, 2839, 2888, 2902, 2911, 2934, 2944, 2958, 2964, 2965, 2970, 2974, 3046, 3091, 3138, 3168, 3174, 3226, 3246, 3258, 3294, 3345, 3366, 3390, 3442, 3505, 3564, 3595, 3615, 3622, 3649, 3663, 3690, 3694, 3802, 3852, 3864, 3865, 3930, 3946, 3973, 4054, 4126, 4162, 4173, 4185, 4189, 4191, 4198, 4209, 4279, 4306, 4369, 4414, 4428, 4464, 4472, 4557, 4592, 4594, 4702, 4743, 4765, 4788, 4794, 4832, 4855, 4880, 4918, 4954, 4959, 4960, 4974, 4981, 5062, 5071, 5088, 5098, 5172, 5242, 5248, 5253, 5269, 5298, 5305, 5386, 5388, 5397, 5422, 5458, 5485, 5526, 5539, 5602, 5638, 5642, 5674, 5772, 5818, 5854, 5874, 5915, 5926, 5935, 5936, 5946, 5998, 6036, 6054, 6084, 6096, 6115, 6171, 6178, 6187, 6188, 6252, 6259, 6295, 6315, 6344, 6385, 6439, 6457, 6502, 6531, 6567, 6583, 6585, 6603, 6684, 6693, 6702, 6718, 6760, 6816, 6835, 6855, 6880, 6934, 6981, 7026, 7051, 7062, 7068, 7078, 7089, 7119, 7136, 7186, 7195, 7227, 7249, 7287, 7339, 7402, 7438, 7447, 7465, 7503, 7627, 7674, 7683, 7695, 7712, 7726, 7762, 7764, 7782, 7784, 7809, 7824, 7834, 7915, 7952, 7978, 8005, 8014, 8023, 8073, 8077, 8095, 8149, 8154, 8158, 8185, 8196, 8253, 8257, 8277, 8307, 8347, 8372, 8412, 8421, 8466, 8518, 8545, 8568, 8628, 8653, 8680, 8736, 8754, 8766, 8790, 8792, 8851, 8864, 8874, 8883, 8901, 8914, 9015, 9031, 9036, 9094, 9166, 9184, 9193, 9229, 9274, 9276, 9285, 9294, 9296, 9301, 9330, 9346, 9355, 9382, 9386, 9387, 9396, 9414, 9427, 9483, 9522, 9535, 9571, 9598, 9633, 9634, 9639, 9648, 9657, 9684, 9708, 9717, 9735, 9742, 9760, 9778, 9840, 9843, 9849, 9861, 9880, 9895, 9924, 9942, 9968, 9975, 9985]

real	0m0.014s
user	0m0.014s
sys	0m0.000s
```

# Sparkline in unicode<a id="sec-353"></a>

A sparkline is a graph of successive values laid out horizontally where the height of the line is proportional to the values in succession.

Task

Use the following series of Unicode characters to create a program that takes a series of numbers separated by one or more whitespace or comma characters and generates a sparkline-type bar graph of the values on a single line of output.

The eight characters: '‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà' (Unicode values U+2581 through U+2588).

Use your program to show sparklines for the following input, here on this page:

1 2 3 4 5 6 7 8 7 6 5 4 3 2 1 1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5

(note the mix of separators in this second case)!

Notes

A space is not part of the generated sparkline. The sparkline may be accompanied by simple statistics of the data such as its range.

```rust
¬†
const BARS: &'static str = "‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà";
¬†
fn print_sparkline(s: &str){
    let v = BARS.chars().collect::<Vec<char>>();
    let line: String = s.replace(",", " ").split(" ")
                            .filter(|x|¬†!x.is_empty())
                            .map(|x| v[x.parse::<f64>().unwrap().ceil() as usize - 1])
                            .collect();
    println!("{:?}", line);
}
¬†
fn main(){
    let s1 = "1 2 3 4 5 6 7 8 7 6 5 4 3 2 1";
    print_sparkline(s1);
    let s2 = "1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5";
    print_sparkline(s2);
}
¬†
```

Output:

"‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà‚ñá‚ñÜ‚ñÖ‚ñÑ‚ñÉ‚ñÇ‚ñÅ"

"‚ñÇ‚ñÅ‚ñÑ‚ñÉ‚ñÜ‚ñÖ‚ñà‚ñá"

# Execute HQ9+<a id="sec-354"></a>

Task

Implement a ¬† HQ9+ ¬† interpreter or compiler.

```rust
use std::env;
¬†
// HQ9+ requires that '+' increments an accumulator, but it's inaccessible (and thus, unused).
#[allow(unused_variables)]
fn execute(code: &str) {
    let mut accumulator = 0;
¬†
    for c in code.chars() {
        match c {
            'Q' => println!("{}", code),
            'H' => println!("Hello, World!"),
            '9' => {
                for n in (1..100).rev() {
                    println!("{} bottles of beer on the wall", n);
                    println!("{} bottles of beer", n);
                    println!("Take one down, pass it around");
                    if (n - 1) > 1 {
                        println!("{} bottles of beer on the wall\n", n - 1);
                    } else {
                        println!("1 bottle of beer on the wall\n");
                    }
                }
            }
            '+' => accumulator += 1,
            _ => panic!("Invalid character '{}' found in source.", c),
        }
    }
}
¬†
fn main() {
    execute(&env::args().nth(1).unwrap());
}
```

# FASTA format<a id="sec-355"></a>

In bioinformatics, long character strings are often encoded in a format called FASTA.

A FASTA file can contain several strings, each identified by a name marked by a > (greater than) character at the beginning of the line.

Task

Write a program that reads a FASTA file such as:

```
>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED

```

Output:

```
Rosetta_Example_1: THERECANBENOSPACE
Rosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED

```

Note that a high-quality implementation will not hold the entire file in memory at once; real FASTA files can be multiple gigabytes in size.

This example is implemented using an iterator to reduce memory requirements and encourage code reuse.

```rust
¬†
use std::env;
use std::io::{BufReader, Lines};
use std::io::prelude::*;
use std::fs::File;
¬†
fn main() {
    let args: Vec<String> = env::args().collect();
    let f = File::open(&args[1]).unwrap();
    for line in FastaIter::new(f) {
        println!("{}", line);
    }
}
¬†
struct FastaIter<T> {
    buffer_lines: Lines<BufReader<T>>,
    current_name: Option<String>,
    current_sequence: String
}
¬†
impl<T: Read> FastaIter<T> {
    fn new(file: T) -> FastaIter<T> {
        FastaIter { buffer_lines: BufReader::new(file).lines(),
                    current_name: None,
                    current_sequence: String::new() }
    }
}
¬†
impl<T: Read> Iterator for FastaIter<T> {
    type Item = String;
¬†
    fn next(&mut self) -> Option<String> {
        while let Some(l) = self.buffer_lines.next() {
            let line = l.unwrap();
            if line.starts_with(">") {
                if self.current_name.is_some() {                    
                    let mut res = String::new();
                    res.push_str(self.current_name.as_ref().unwrap());
                    res.push_str(": ");
                    res.push_str(&self.current_sequence);
                    self.current_name = Some(String::from(&line[1..]));
                    self.current_sequence.clear();
                    return Some(res);
                } else {
                    self.current_name = Some(String::from(&line[1..]));
                    self.current_sequence.clear();
                }
                continue;
            }
            self.current_sequence.push_str(line.trim());
        }
        if self.current_name.is_some() {
            let mut res = String::new();
            res.push_str(self.current_name.as_ref().unwrap());
            res.push_str(": ");
            res.push_str(&self.current_sequence);
            self.current_name = None;
            self.current_sequence.clear();
            self.current_sequence.shrink_to_fit();
            return Some(res);
        }
        None
    }
}
¬†
```

Output:

```rust
Rosetta_Example_1: THERECANBENOSPACE
Rosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED
```

# 15 Puzzle Game<a id="sec-356"></a>

Task

Implement the Fifteen Puzzle Game.

The ¬† 15-puzzle ¬† is also known as:

¬† Fifteen Puzzle ¬† Gem Puzzle ¬† Boss Puzzle ¬† Game of Fifteen ¬† Mystic Square ¬† 14-15 Puzzle ¬† and many others.

Related Tasks ¬† 15 Puzzle Solver ¬† 16 Puzzle Game

Library: rand

```rust
extern crate rand;
¬†
use std::collections::HashMap;
use std::fmt;
¬†
use rand::Rng;
¬†
#[derive(Copy, Clone, PartialEq, Debug)]
enum Cell {
    Card(usize),
    Empty,
}
¬†
#[derive(Eq, PartialEq, Hash, Debug)]
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
¬†
enum Action {
    Move(Direction),
    Quit,
}
¬†
type Board = [Cell; 16];
const EMPTY: Board = [Cell::Empty; 16];
¬†
struct P15 {
    board: Board,
}
¬†
impl P15 {
    fn new() -> Self {
        let mut board = EMPTY;
        for (i, cell) in board.iter_mut().enumerate().skip(1) {
            *cell = Cell::Card(i);
        }
¬†
        let mut rng = rand::thread_rng();
¬†
        rng.shuffle(&mut board);
        if¬†!Self::is_valid(board) {
            // random swap
            let i = rng.gen_range(0, 16);
            let mut j = rng.gen_range(0, 16);
            while j == i {
                j = rng.gen_range(0, 16);
            }
            board.swap(i, j);
        }
¬†
        Self { board }
    }
¬†
    fn is_valid(mut board: Board) -> bool {
        // TODO: optimize
        let mut permutations = 0;
¬†
        let pos = board.iter().position(|&cell| cell == Cell::Empty).unwrap();
¬†
        if pos¬†!= 15 {
            board.swap(pos, 15);
            permutations += 1;
        }
¬†
        for i in 1..16 {
            let pos = board
                .iter()
                .position(|&cell| match cell {
                    Cell::Card(value) if value == i => true,
                    _ => false,
                })
                .unwrap();
¬†
            if pos + 1¬†!= i {
                board.swap(pos, i - 1);
                permutations += 1;
            }
        }
¬†
        permutations¬†% 2 == 0
    }
¬†
    fn get_empty_position(&self) -> usize {
        self.board.iter().position(|&c| c == Cell::Empty).unwrap()
    }
¬†
    fn get_moves(&self) -> HashMap<Direction, Cell> {
        let mut moves = HashMap::new();
        let i = self.get_empty_position();
¬†
        if i > 3 {
            moves.insert(Direction::Up, self.board[i - 4]);
        }
        if i¬†% 4¬†!= 0 {
            moves.insert(Direction::Left, self.board[i - 1]);
        }
        if i < 12 {
            moves.insert(Direction::Down, self.board[i + 4]);
        }
        if i¬†% 4¬†!= 3 {
            moves.insert(Direction::Right, self.board[i + 1]);
        }
        moves
    }
¬†
    fn play(&mut self, direction: &Direction) {
        let i = self.get_empty_position();
        // This is safe because `ask_action` only returns legal moves
        match *direction {
            Direction::Up => self.board.swap(i, i - 4),
            Direction::Left => self.board.swap(i, i - 1),
            Direction::Right => self.board.swap(i, i + 1),
            Direction::Down => self.board.swap(i, i + 4),
        };
    }
¬†
    fn is_complete(&self) -> bool {
        self.board.iter().enumerate().all(|(i, &cell)| match cell {
            Cell::Card(value) => value == i + 1,
            Cell::Empty => i == 15,
        })
    }
}
¬†
impl fmt::Display for P15 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        try!(write!(f, "+----|----|----|----+\n"));
        for (i, &cell) in self.board.iter().enumerate() {
            match cell {
                Cell::Card(value) => try!(write!(f, "| {:2} ", value)),
                Cell::Empty => try!(write!(f, "|    ")),
            }
¬†
            if i¬†% 4 == 3 {
                try!(write!(f, "|\n"));
                try!(write!(f, "+----|----|----|----+\n"));
            }
        }
        Ok(())
    }
}
¬†
fn main() {
    let mut p15 = P15::new();
¬†
    for turns in 1.. {
        println!("{}", p15);
        match ask_action(&p15.get_moves()) {
            Action::Move(direction) => {
                p15.play(&direction);
            }
            Action::Quit => {
                println!("Bye¬†!");
                break;
            }
        }
¬†
        if p15.is_complete() {
            println!("Well done¬†! You won in {} turns", turns);
            break;
        }
    }
}
¬†
fn ask_action(moves: &HashMap<Direction, Cell>) -> Action {
    use std::io::{self, Write};
    use Action::*;
    use Direction::*;
¬†
    println!("Possible moves:");
¬†
    if let Some(&Cell::Card(value)) = moves.get(&Up) {
        println!("\tU) {}", value);
    }
    if let Some(&Cell::Card(value)) = moves.get(&Left) {
        println!("\tL) {}", value);
    }
    if let Some(&Cell::Card(value)) = moves.get(&Right) {
        println!("\tR) {}", value);
    }
    if let Some(&Cell::Card(value)) = moves.get(&Down) {
        println!("\tD) {}", value);
    }
    println!("\tQ) Quit");
    print!("Choose your move¬†: ");
    io::stdout().flush().unwrap();
¬†
    let mut action = String::new();
    io::stdin().read_line(&mut action).expect("read error");
    match action.to_uppercase().trim() {
        "U" if moves.contains_key(&Up) => Move(Up),
        "L" if moves.contains_key(&Left) => Move(Left),
        "R" if moves.contains_key(&Right) => Move(Right),
        "D" if moves.contains_key(&Down) => Move(Down),
        "Q" => Quit,
        _ => {
            println!("Unknown action: {}", action);
            ask_action(moves)
        }
    }
}
```

# Take notes on the command line<a id="sec-357"></a>

Invoking NOTES without commandline arguments displays the current contents of the local NOTES.TXT if it exists. If NOTES has arguments, the current date and time are appended to the local NOTES.TXT followed by a newline. Then all the arguments, joined with spaces, prepended with a tab, and appended with a trailing newline, are written to NOTES.TXT. If NOTES.TXT doesn't already exist in the current directory then a new NOTES.TXT file should be created.

This uses version 0.4 of the chrono crate

```rust
extern crate chrono;
¬†
use std::fs::OpenOptions;
use std::io::{self, BufReader, BufWriter};
use std::io::prelude::*;
use std::env;
¬†
const FILENAME: &str = "NOTES.TXT";
¬†
fn show_notes() -> Result<(), io::Error> {
    let file = OpenOptions::new()
        .read(true)
        .create(true) // create the file if not found
        .write(true) // necessary to create the file
        .open(FILENAME)?;
    let mut buf_reader = BufReader::new(file);
    let mut contents = String::new();
    buf_reader.read_to_string(&mut contents)?;
    println!("{}", contents);
    Ok(())
}
¬†
fn add_to_notes(note: &str) -> Result<(), io::Error> {
    let file = OpenOptions::new()
        .append(true) // disables overwriting, writes to the end of the file
        .create(true)
        .open(FILENAME)?;
    let mut buf_writer = BufWriter::new(file);
¬†
    let date_and_time = chrono::Local::now();
    writeln!(buf_writer, "{}", date_and_time)?;
¬†
    writeln!(buf_writer, "\t{}", note)
}
¬†
fn main() {
    let note = env::args().skip(1).collect::<Vec<_>>();
¬†
    if note.is_empty() {
        show_notes().expect("failed to print NOTES.TXT");
    } else {
        add_to_notes(&note.join(" ")).expect("failed to write to NOTES.TXT");
    }
}
```

# Element-wise operations<a id="sec-358"></a>

This task is similar to:

¬† Matrix multiplication ¬† Matrix transposition

Task

Implement basic element-wise matrix-matrix and scalar-matrix operations, which can be referred to in other, higher-order tasks.

Implement:

¬† addition ¬† subtraction ¬† multiplication ¬† division ¬† exponentiation

Extend the task if necessary to include additional basic operations, which should not require their own specialised task.

```rust
struct Matrix {
    elements: Vec<f32>,
    pub height: u32,
    pub width: u32,
}
¬†
impl Matrix {
    fn new(elements: Vec<f32>, height: u32, width: u32) -> Matrix {
        // Should check for dimensions but omitting to be succient
        Matrix {
            elements: elements,
            height: height,
            width: width,
        }
    }
¬†
    fn get(&self, row: u32, col: u32) -> f32 {
        let row = row as usize;
        let col = col as usize;
        self.elements[col + row * (self.width as usize)]
    }
¬†
    fn set(&mut self, row: u32, col: u32, value: f32) {
        let row = row as usize;
        let col = col as usize;
        self.elements[col + row * (self.width as usize)] = value;
    }
¬†
    fn print(&self) {
        for row in 0..self.height {
            for col in 0..self.width {
                print!("{:3.0}", self.get(row, col));
            }
            println!("");
        }
        println!("");
    }
}
¬†
// Matrix addition will perform element-wise addition
fn matrix_addition(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {
    if first.width == second.width && first.height == second.height {
        let mut result = Matrix::new(vec![0.0f32; (first.height * first.width) as usize],
                                     first.height,
                                     first.width);
        for row in 0..first.height {
            for col in 0..first.width {
                let first_value = first.get(row, col);
                let second_value = second.get(row, col);
                result.set(row, col, first_value + second_value);
            }
        }
        Ok(result)
    } else {
        Err("Dimensions don't match".to_owned())
    }
}
¬†
fn scalar_multiplication(scalar: f32, matrix: &Matrix) -> Matrix {
    let mut result = Matrix::new(vec![0.0f32; (matrix.height * matrix.width) as usize],
                                 matrix.height,
                                 matrix.width);
    for row in 0..matrix.height {
        for col in 0..matrix.width {
            let value = matrix.get(row, col);
            result.set(row, col, scalar * value);
        }
    }
    result
}
¬†
// Subtract second from first
fn matrix_subtraction(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {
    if first.width == second.width && first.height == second.height {
        let negative_matrix = scalar_multiplication(-1.0, second);
        let result = matrix_addition(first, &negative_matrix).unwrap();
        Ok(result)
    } else {
        Err("Dimensions don't match".to_owned())
    }
}
¬†
// First must be a l x m matrix and second a m x n matrix for this to work.
fn matrix_multiplication(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {
    if first.width == second.height {
        let mut result = Matrix::new(vec![0.0f32; (first.height * second.width) as usize],
                                     first.height,
                                     second.width);
        for row in 0..result.height {
            for col in 0..result.width {
                let mut value = 0.0;
                for it in 0..first.width {
                    value += first.get(row, it) * second.get(it, col);
                }
                result.set(row, col, value);
            }
        }
        Ok(result)
    } else {
        Err("Dimensions don't match. Width of first must equal height of second".to_owned())
    }
}
¬†
¬†
fn main() {
    let height = 2;
    let width = 3;
    // Matrix will look like:
    // | 1.0  2.0  3.0  |
    // | 4.0  5.0  6.0 |
    let matrix1 = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], height, width);
¬†
    // Matrix will look like:
    // | 6.0  5.0  4.0  |
    // | 3.0  2.0  1.0 |
    let matrix2 = Matrix::new(vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0], height, width);
¬†
    // | 7.0  7.0  7.0  |
    // | 7.0  7.0  7.0 |
    matrix_addition(&matrix1, &matrix2).unwrap().print();
    // | 2.0   4.0   6.0  |
    // | 8.0  10.0  12.0 |
    scalar_multiplication(2.0, &matrix1).print();
    // | -5.0  -3.0  -1.0  |
    // |  1.0   3.0   5.0 |
    matrix_subtraction(&matrix1, &matrix2).unwrap().print();
¬†
    // | 1.0 |
    // | 1.0 |
    // | 1.0 |
    let matrix3 = Matrix::new(vec![1.0, 1.0, 1.0], width, 1);
    // |  6 |
    // | 15 |
    matrix_multiplication(&matrix1, &matrix3).unwrap().print();
}
```

# Exponentiation order<a id="sec-359"></a>

This task will demonstrate the order of exponentiation ¬† (xy) ¬† when there are multiple exponents.

(Many programming languages, especially those with extended-precision integer arithmetic, usually support one of \*\*, ^, ‚Üë or some such for exponentiation.)

Task requirements

Show the result of a language's evaluation of multiple exponentiation (either as an integer or floating point).

If your language's exponentiation operator is not one of the usual ones, please comment on how to recognize it.

Using whatever operator or syntax your language supports (if any), show the results in three lines (with identification):

¬† 5\*\*3\*\*2 ¬† (5\*\*3)\*\*2 ¬† 5\*\*(3\*\*2)

If there are other methods (or formats) of multiple exponentiations, show them as well.

See also

MathWorld entry: ¬† exponentiation

Related task

Rosetta Code task: ¬† Arbitrary-precision integers (included)

```rust
fn main() {
    println!("5**3**2   = {:7}", 5u32.pow(3).pow(2));
    println!("(5**3)**2 = {:7}", (5u32.pow(3)).pow(2));
    println!("5**(3**2) = {:7}", 5u32.pow(3u32.pow(2)));
}
```

Output:

```rust
5**3**2   =   15625
(5**3)**2 =   15625
5**(3**2) = 1953125

```

# Perfect shuffle<a id="sec-360"></a>

A perfect shuffle (or faro/weave shuffle) means splitting a deck of cards into equal halves, and perfectly interleaving them - so that you end up with the first card from the left half, followed by the first card from the right half, and so on:

7‚ô† 8‚ô† 9‚ô† J‚ô† Q‚ô† K‚ô†

‚Üí7‚ô†¬† 8‚ô†¬† 9‚ô† ¬†¬†J‚ô†¬† Q‚ô†¬† K‚ô†

‚Üí7‚ô† J‚ô† 8‚ô† Q‚ô† 9‚ô† K‚ô†

When you repeatedly perform perfect shuffles on an even-sized deck of unique cards, it will at some point arrive back at its original order. How many shuffles this takes, depends solely on the number of cards in the deck - for example for a deck of eight cards it takes three shuffles:

original:

1 2 3 4 5 6 7 8

after 1st shuffle:

1 5 2 6 3 7 4 8

after 2nd shuffle:

1 3 5 7 2 4 6 8

after 3rd shuffle:

1 2 3 4 5 6 7 8

The Task

Write a function that can perform a perfect shuffle on an even-sized list of values. Call this function repeatedly to count how many shuffles are needed to get a deck back to its original order, for each of the deck sizes listed under "Test Cases" below. You can use a list of numbers (or anything else that's convenient) to represent a deck; just make sure that all "cards" are unique within each deck. Print out the resulting shuffle counts, to demonstrate that your program passes the test-cases.

Test Cases

input (deck size) output (number of shuffles required) 8 3 24 11 52 8 100 30 1020 1018 1024 10 10000 300

```rust
extern crate itertools;
¬†
fn shuffle<T>(mut deck: Vec<T>) -> Vec<T> {
    let index = deck.len() / 2;
    let right_half = deck.split_off(index);
    itertools::interleave(deck, right_half).collect()
}
¬†
fn main() {
    for &size in &[8, 24, 52, 100, 1020, 1024, 10_000] {
        let original_deck: Vec<_> = (0..size).collect();
        let mut deck = original_deck.clone();
        let mut iterations = 0;
        loop {
            deck = shuffle(deck);
            iterations += 1;
            if deck == original_deck {
                break;
            }
        }
        println!("{: >5}: {: >4}", size, iterations);
    }
}
```

Output:

```rust
    8:    3
   24:   11
   52:    8
  100:   30
 1020: 1018
 1024:   10
10000:  300

```

# Visualize a tree<a id="sec-361"></a>

A tree structure ¬† (i.e. a rooted, connected acyclic graph) ¬† is often used in programming.

It's often helpful to visually examine such a structure.

There are many ways to represent trees to a reader, such as:

¬† indented text ¬† (√† la unix tree command) ¬† nested HTML tables ¬† hierarchical GUI widgets ¬† 2D ¬† or ¬† 3D ¬† images ¬† etc.

Task

Write a program to produce a visual representation of some tree.

The content of the tree doesn't matter, nor does the output format, the only requirement being that the output is human friendly.

Make do with the vague term "friendly" the best you can.

Console visualization of binary trees translated from parts of the C AVL tree solution.

```rust
¬†
extern crate rustc_serialize;
extern crate term_painter;
¬†
use rustc_serialize::json;
use std::fmt::{Debug, Display, Formatter, Result};
use term_painter::ToStyle;
use term_painter::Color::*;
¬†
type NodePtr = Option<usize>;
¬†
#[derive(Debug, PartialEq, Clone, Copy)]
enum Side {
    Left,
    Right,
    Up,
}
¬†
#[derive(Debug, PartialEq, Clone, Copy)]
enum DisplayElement {
    TrunkSpace,
    SpaceLeft,
    SpaceRight,
    SpaceSpace,
    Root,
}
¬†
impl DisplayElement {
    fn string(&self) -> String {
        match *self {
            DisplayElement::TrunkSpace => "    ‚îÇ   ".to_string(),
            DisplayElement::SpaceRight => "    ‚îå‚îÄ‚îÄ‚îÄ".to_string(),
            DisplayElement::SpaceLeft => "    ‚îî‚îÄ‚îÄ‚îÄ".to_string(),
            DisplayElement::SpaceSpace => "        ".to_string(),
            DisplayElement::Root => "‚îú‚îÄ‚îÄ".to_string(),
        }
    }
}
¬†
#[derive(Debug, Clone, Copy, RustcDecodable, RustcEncodable)]
struct Node<K, V> {
    key: K,
    value: V,
    left: NodePtr,
    right: NodePtr,
    up: NodePtr,
}
¬†
impl<K: Ord + Copy, V: Copy> Node<K, V> {
    pub fn get_ptr(&self, side: Side) -> NodePtr {
        match side {
            Side::Up => self.up,
            Side::Left => self.left,
            _ => self.right,
        }
    }
}
¬†
#[derive(Debug, RustcDecodable, RustcEncodable)]
struct Tree<K, V> {
    root: NodePtr,
    store: Vec<Node<K, V>>,
}
¬†
impl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> Tree<K, V> {
    pub fn get_node(&self, np: NodePtr) -> Node<K, V> {
        assert!(np.is_some());
        self.store[np.unwrap()]
    }
¬†
    pub fn get_pointer(&self, np: NodePtr, side: Side) -> NodePtr {
        assert!(np.is_some());
        self.store[np.unwrap()].get_ptr(side)
    }
¬†
    // Prints the tree with root p.  The idea is to do an in-order traversal
    // (reverse in-order in this case, where right is on top), and print nodes as they
    // are visited, one per line. Each invocation of display() gets its own copy
    // of the display element vector e, which is grown with either whitespace or
    // a trunk element, then modified in its last and possibly second-to-last
    // characters in context.
    fn display(&self, p: NodePtr, side: Side, e: &Vec<DisplayElement>, f: &mut Formatter) {
        if p.is_none() {
            return;
        }
¬†
        let mut elems = e.clone();
        let node = self.get_node(p);
        let mut tail = DisplayElement::SpaceSpace;
        if node.up¬†!= self.root {
            // If the direction is switching, I need the trunk element to appear in the lines
            // printed before that node is visited.
            if side == Side::Left && node.right.is_some() {
                elems.push(DisplayElement::TrunkSpace);
            } else {
                elems.push(DisplayElement::SpaceSpace);
            }
        }
        let hindex = elems.len() - 1;
        self.display(node.right, Side::Right, &elems, f);
¬†
        if p == self.root {
            elems[hindex] = DisplayElement::Root;
            tail = DisplayElement::TrunkSpace;
        } else if side == Side::Right {
            // Right subtree finished
            elems[hindex] = DisplayElement::SpaceRight;
            // Prepare trunk element in case there is a left subtree
            tail = DisplayElement::TrunkSpace;
        } else if side == Side::Left {
            elems[hindex] = DisplayElement::SpaceLeft;
            let parent = self.get_node(node.up);
            if parent.up.is_some() && self.get_pointer(parent.up, Side::Right) == node.up {
                // Direction switched, need trunk element starting with this node/line
                elems[hindex - 1] = DisplayElement::TrunkSpace;
            }
        }
¬†
        // Visit node => print accumulated elements. Each node gets a line and each line gets a
        // node.
        for e in elems.clone() {
            let _ = write!(f, "{}", e.string());
        }
        let _ = write!(f,
                       "{key:>width$} ",
                       key = Green.bold().paint(node.key),
                       width = 2);
        let _ = write!(f,
                       "{value:>width$}\n",
                       value = Blue.bold().paint(format!("{:.*}", 2, node.value)),
                       width = 4);
¬†
        // Overwrite last element before continuing traversal
        elems[hindex] = tail;
¬†
        self.display(node.left, Side::Left, &elems, f);
    }
}
¬†
impl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> Display for Tree<K, V> {
    fn fmt(&self, f: &mut Formatter) -> Result {
        if self.root.is_none() {
            write!(f, "[empty]")
        } else {
            let mut v: Vec<DisplayElement> = Vec::new();
            self.display(self.root, Side::Up, &mut v, f);
            Ok(())
        }
    }
}
¬†
/// Decodes and prints a previously generated tree.
fn main() {
    let encoded = r#"{"root":0,"store":[{"key":0,"value":0.45,"left":1,"right":3,
        "up":null},{"key":-8,"value":-0.94,"left":7,"right":2,"up":0}, {"key":-1,
        "value":0.15,"left":8,"right":null,"up":1},{"key":7, "value":-0.29,"left":4,
        "right":9,"up":0},{"key":5,"value":0.80,"left":5,"right":null,"up":3},
        {"key":4,"value":-0.85,"left":6,"right":null,"up":4},{"key":3,"value":-0.46,
        "left":null,"right":null,"up":5},{"key":-10,"value":-0.85,"left":null,
        "right":13,"up":1},{"key":-6,"value":-0.42,"left":null,"right":10,"up":2},
        {"key":9,"value":0.63,"left":12,"right":null,"up":3},{"key":-3,"value":-0.83,
        "left":null,"right":11,"up":8},{"key":-2,"value":0.75,"left":null,"right":null,
        "up":10},{"key":8,"value":-0.48,"left":null,"right":null,"up":9},{"key":-9,
        "value":0.53,"left":null,"right":null,"up":7}]}"#;
    let tree: Tree<i32, f32> = json::decode(&encoded).unwrap();
    println!("{}", tree);
}
¬†
```

Output:

# Discordian date<a id="sec-362"></a>

Task

Convert a given date from the ¬† Gregorian calendar ¬† to the ¬† Discordian calendar.

Compiler: Rust (1.21.0)

Library: chrono

Library: ddate

This example is taken in large part from the ddate crate and used with the permission of the author.

```rust
extern crate chrono;
¬†
use chrono::NaiveDate;
use std::str::FromStr;
¬†
fn main() {
    let date = std::env::args().nth(1).expect("Please provide a YYYY-MM-DD date.");
    println!("{} is {}", date, NaiveDate::from_str(&date).unwrap().to_poee());
}
¬†
// The necessary constants for the seasons, weekdays, and holydays.
const APOSTLES: [&str; 5] = ["Mungday", "Mojoday", "Syaday", "Zaraday", "Maladay"];
const HOLYDAYS: [&str; 5] = ["Chaoflux", "Discoflux", "Confuflux", "Bureflux", "Afflux"];
const SEASONS: [&str; 5] = ["Chaos", "Discord", "Confusion", "Bureaucracy", "The Aftermath"];
const WEEKDAYS: [&str; 5] = ["Sweetmorn", "Boomtime", "Pungenday", "Prickle-Prickle", "Setting Orange"];
¬†
// The necessary constants for the conversion.
const APOSTLE_HOLYDAY: usize = 5;
const CURSE_OF_GREYFACE: i32 = 1166;
const SEASON_DAYS: usize = 73;
const SEASON_HOLYDAY: usize = 50;
const ST_TIBS_DAY: usize = 59;
const WEEK_DAYS: usize = 5;
¬†
// This extends the `Datelike` trait of Rust's Chrono crate with a method that
// prints any Datelike type as a String.
impl<T: Datelike> DiscordianDate for T {}
pub trait DiscordianDate: Datelike {
    fn to_poee(&self) -> String {
        let day = self.ordinal0() as usize;
        let leap = self.year()¬†% 4 == 0 && self.year()¬†% 100¬†!= 0 || self.year()¬†% 400 == 0;
        let year = self.year() + CURSE_OF_GREYFACE;
¬†
        if leap && day == ST_TIBS_DAY { return format!("St. Tib's Day, in the YOLD {}", year); }
¬†
        let day_offset = if leap && day > ST_TIBS_DAY { day - 1 } else { day };
¬†
        let day_of_season = day_offset¬†% SEASON_DAYS + 1;
¬†
        let season = SEASONS[day_offset / SEASON_DAYS];
        let weekday = WEEKDAYS[day_offset¬†% WEEK_DAYS];
¬†
        let holiday = if day_of_season == APOSTLE_HOLYDAY {
            format!("\nCelebrate {}", APOSTLES[day_offset / SEASON_DAYS])
        } else if day_of_season == SEASON_HOLYDAY {
            format!("\nCelebrate {}", HOLYDAYS[day_offset / SEASON_DAYS])
        } else {
            String::with_capacity(0)
        };
¬†
        format!("{}, the {} day of {} in the YOLD {}{}",
            weekday, ordinalize(day_of_season), season, year, holiday)
    }
}
¬†
/// A helper function to ordinalize a numeral.
fn ordinalize(num: usize) -> String {
    let s = format!("{}", num);
¬†
    let suffix = if s.ends_with('1') &&¬†!s.ends_with("11") {
        "st"
    } else if s.ends_with('2') &&¬†!s.ends_with("12") {
        "nd"
    } else if s.ends_with('3') &&¬†!s.ends_with("13") {
        "rd"
    } else {
        "th"
    };
¬†
    format!("{}{}", s, suffix)
}
¬†
```

Output:

```rust
$ ./ddate -1166-1-1


-1166-1-1 is Sweetmorn, the 1st day of Chaos in the YOLD 0
$ ./ddate 2000-2-28
2000-2-28 is Prickle-Prickle, the 59th day of Chaos in the YOLD 3166
$ ./ddate -4004-2-29
-4004-2-29 is St. Tib's Day, in the YOLD -2838
$ ./ddate 1066-2-28
1066-2-28 is Prickle-Prickle, the 59th day of Chaos in the YOLD 2232
$ ./ddate 1492-3-1
1492-3-1 is Setting Orange, the 60th day of Chaos in the YOLD 2658
$ ./ddate 1492-9-26
1492-9-26 is Prickle-Prickle, the 50th day of Bureaucracy in the YOLD 2658
Celebrate Bureflux
$ ./ddate 2012-10-24
2012-10-24 is Boomtime, the 5th day of The Aftermath in the YOLD 3178
Celebrate Maladay
$ 




```

# Continued fraction/Arithmetic/Construct from rational number<a id="sec-363"></a>

Continued fraction arithmetic

The purpose of this task is to write a function {\displaystyle {\mathit {r2cf}}(\mathrm {int} } {\displaystyle N<sub>1</sub>,\mathrm {int} } {\displaystyle N<sub>2</sub>)} , or {\displaystyle {\mathit {r2cf}}(\mathrm {Fraction} } {\displaystyle N)} , which will output a continued fraction assuming:

{\displaystyle N<sub>1</sub>} is the numerator {\displaystyle N<sub>2</sub>} is the denominator

The function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.

To achieve this it must determine: the integer part; and remainder part, of {\displaystyle N<sub>1</sub>} divided by {\displaystyle N<sub>2</sub>} . It then sets {\displaystyle N<sub>1</sub>} to {\displaystyle N<sub>2</sub>} and {\displaystyle N<sub>2</sub>} to the determined remainder part. It then outputs the determined integer part. It does this until {\displaystyle \mathrm {abs} (N<sub>2</sub>)} is zero.

Demonstrate the function by outputing the continued fraction for:

1/2 3 23/8 13/11 22/7 -151/77

{\displaystyle {\sqrt {2}}} should approach {\displaystyle [1;2,2,2,2,\ldots ]} try ever closer rational approximations until boredom gets the better of you:

14142,10000 141421,100000 1414214,1000000 14142136,10000000

Try¬†:

31,10 314,100 3142,1000 31428,10000 314285,100000 3142857,1000000 31428571,10000000 314285714,100000000

Observe how this rational number behaves differently to {\displaystyle {\sqrt {2}}} and convince yourself that, in the same way as {\displaystyle 3.7} may be represented as {\displaystyle 3.70} when an extra decimal place is required, {\displaystyle [3;7]} may be represented as {\displaystyle [3;7,&infin; ]} when an extra term is required.

```rust
¬†
struct R2cf {
    n1: i64,
    n2: i64
}
¬†
// This iterator generates the continued fraction representation from the
// specified rational number.
impl Iterator for R2cf {
    type Item = i64;
¬†
    fn next(&mut self) -> Option<i64> {
        if self.n2 == 0 {
            None
        }
        else {
            let t1 = self.n1 / self.n2;
            let t2 = self.n2;
            self.n2 = self.n1 - t1 * t2;
            self.n1 = t2;
            Some(t1)
        }
    }
}
¬†
fn r2cf(n1: i64, n2: i64) -> R2cf {
    R2cf { n1: n1, n2: n2 }
}
¬†
macro_rules! printcf {
    ($x:expr, $y:expr) => (println!("{:?}", r2cf($x, $y).collect::<Vec<_>>()));
}
¬†
fn main() {
    printcf!(1, 2);
    printcf!(3, 1);
    printcf!(23, 8);
    printcf!(13, 11);
    printcf!(22, 7);
    printcf!(-152, 77);
¬†
    printcf!(14_142, 10_000);
    printcf!(141_421, 100_000);
    printcf!(1_414_214, 1_000_000);
    printcf!(14_142_136, 10_000_000);
¬†
    printcf!(31, 10);
    printcf!(314, 100);
    printcf!(3142, 1000);
    printcf!(31_428, 10_000);
    printcf!(314_285, 100_000);
    printcf!(3_142_857, 1_000_000);
    printcf!(31_428_571, 10_000_000);
    printcf!(314_285_714, 100_000_000);
}
¬†
```

Output:

```rust
[0, 2]
[3]
[2, 1, 7]
[1, 5, 2]
[3, 7]
[-1, -1, -37, -2]
[1, 2, 2, 2, 2, 2, 1, 1, 29]
[1, 2, 2, 2, 2, 2, 2, 3, 1, 1, 3, 1, 7, 2]
[1, 2, 2, 2, 2, 2, 2, 2, 3, 6, 1, 2, 1, 12]
[1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 4, 1, 1, 2]
[3, 10]
[3, 7, 7]
[3, 7, 23, 1, 2]
[3, 7, 357]
[3, 7, 2857]
[3, 7, 142857]
[3, 7, 476190, 3]
[3, 7, 7142857]

```

# Ray-casting algorithm<a id="sec-364"></a>

This page uses content from Wikipedia. The original article was at Point<sub>in</sub><sub>polygon</sub>. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Given a point and a polygon, check if the point is inside or outside the polygon using the ray-casting algorithm.

A pseudocode can be simply:

```
count ‚Üê 0
foreach side in polygon:
  if ray_intersects_segment(P,side) then
    count ‚Üê count + 1
if is_odd(count) then
  return inside
else
  return outside

```

Where the function ray<sub>intersects</sub><sub>segment</sub> return true if the horizontal ray starting from the point P intersects the side (segment), false otherwise.

An intuitive explanation of why it works is that every time we cross a border, we change "country" (inside-outside, or outside-inside), but the last "country" we land on is surely outside (since the inside of the polygon is finite, while the ray continues towards infinity). So, if we crossed an odd number of borders we were surely inside, otherwise we were outside; we can follow the ray backward to see it better: starting from outside, only an odd number of crossing can give an inside: outside-inside, outside-inside-outside-inside, and so on (the - represents the crossing of a border).

So the main part of the algorithm is how we determine if a ray intersects a segment. The following text explain one of the possible ways.

Looking at the image on the right, we can easily be convinced of the fact that rays starting from points in the hatched area (like P1 and P2) surely do not intersect the segment AB. We also can easily see that rays starting from points in the greenish area surely intersect the segment AB (like point P3).

So the problematic points are those inside the white area (the box delimited by the points A and B), like P4.

Let us take into account a segment AB (the point A having y coordinate always smaller than B's y coordinate, i.e. point A is always below point B) and a point P. Let us use the cumbersome notation PAX to denote the angle between segment AP and AX, where X is always a point on the horizontal line passing by A with x coordinate bigger than the maximum between the x coordinate of A and the x coordinate of B. As explained graphically by the figures on the right, if PAX is greater than the angle BAX, then the ray starting from P intersects the segment AB. (In the images, the ray starting from PA does not intersect the segment, while the ray starting from PB in the second picture, intersects the segment).

Points on the boundary or "on" a vertex are someway special and through this approach we do not obtain coherent results. They could be treated apart, but it is not necessary to do so.

An algorithm for the previous speech could be (if P is a point, Px is its x coordinate):

```
ray_intersects_segment:
   P¬†: the point from which the ray starts
   A¬†: the end-point of the segment with the smallest y coordinate
       (A must be "below" B)
   B¬†: the end-point of the segment with the greatest y coordinate
       (B must be "above" A)
if Py = Ay or Py = By then
  Py ‚Üê Py + Œµ
end if
if Py < Ay or Py > By then 
  return false
else if Px >= max(Ax, Bx) then 
  return false
else
  if Px < min(Ax, Bx) then
    return true
  else
    if Ax ‚â† Bx then
      m_red ‚Üê (By - Ay)/(Bx - Ax)
    else
      m_red ‚Üê ‚àû
    end if
    if Ax ‚â† Px then
      m_blue ‚Üê (Py - Ay)/(Px - Ax)
    else
      m_blue ‚Üê ‚àû
    end if
    if m_blue ‚â• m_red then
      return true
    else
      return false
    end if
  end if
end if

```

(To avoid the "ray on vertex" problem, the point is moved upward of a small quantity ¬† Œµ.)

Translation of: Python

```rust
use std::f64;
¬†
const _EPS: f64 = 0.00001;
const _MIN: f64 = f64::MIN_POSITIVE;
const _MAX: f64 = f64::MAX;
¬†
#[derive(Clone)]
struct Point {
    x: f64,
    y: f64,
}
¬†
#[derive(Clone)]
struct Edge {
    pt1: Point,
    pt2: Point,
}
¬†
impl Edge {
    fn new(pt1: (f64, f64), pt2: (f64, f64)) -> Edge {
        Edge {
            pt1: Point { x: pt1.0, y: pt1.1 },
            pt2: Point { x: pt2.0, y: pt2.1 },
        }
    }
}
¬†
struct Polygon {
    edges: Vec<Edge>, // Polygon has to be created with counter-clockwise coordinates
}
¬†
fn pt_in_polygon(pt: &Point, poly: &Polygon) -> bool {
    let count = poly.edges
        .iter()
        .filter(|edge| ray_intersect_seg(pt, edge))
        .count();
¬†
    count¬†% 2 == 1
}
¬†
fn ray_intersect_seg(p: &Point, edge: &Edge) -> bool {
    let mut pt = p.clone();
    let (mut a, mut b): (&Point, &Point) = (&edge.pt1, &edge.pt2);
    if a.y > b.y {
        std::mem::swap(&mut a, &mut b);
    }
    if pt.y == a.y || pt.y == b.y {
        pt.y += _EPS;
    }
¬†
    if (pt.y > b.y || pt.y < a.y) || pt.x > a.x.max(b.x) {
        false
    } else if pt.x < a.x.min(b.x) {
        true
    } else {
        let m_red = if (a.x - b.x).abs() > _MIN {
            (b.y - a.y) / (b.x - a.x)
        } else {
            _MAX
        };
        let m_blue = if (a.x - pt.x).abs() > _MIN {
            (pt.y - a.y) / (pt.x - a.x)
        } else {
            _MAX
        };
        m_blue >= m_red
    }
}
¬†
fn main() {
    let p = |x, y| Point { x, y };
    let testpoints = [p(5.0, 5.0), p(5.0, 8.0), p(-10.0, 5.0), p(0.0, 5.0), p(10.0, 5.0), p(8.0, 5.0), p(10.0, 10.0)];
    let poly_square = Polygon {
        edges: vec![
            Edge::new((0.0, 0.0), (10.0, 0.0)),
            Edge::new((10.0, 0.0), (10.0, 10.0)),
            Edge::new((10.0, 10.0), (0.0, 10.0)),
            Edge::new((0.0, 10.0), (0.0, 0.0)),
        ],
    };
    let poly_square_hole = Polygon {
        edges: vec![
            Edge::new((0.0, 0.0), (10.0, 0.0)),
            Edge::new((10.0, 0.0), (10.0, 10.0)),
            Edge::new((10.0, 10.0), (0.0, 10.0)),
            Edge::new((0.0, 10.0), (0.0, 0.0)),
            Edge::new((2.5, 2.5), (7.5, 2.5)),
            Edge::new((7.5, 2.5), (7.5, 7.5)),
            Edge::new((7.5, 7.5), (2.5, 7.5)),
            Edge::new((2.5, 7.5), (2.5, 2.5)),
        ],
    };
    let poly_strange = Polygon {
        edges: vec![
            Edge::new((0.0, 0.0), (2.5, 2.5)),
            Edge::new((2.5, 2.5), (0.0, 10.0)),
            Edge::new((0.0, 10.0), (2.5, 7.5)),
            Edge::new((2.5, 7.5), (7.5, 7.5)),
            Edge::new((7.5, 7.5), (10.0, 10.0)),
            Edge::new((10.0, 10.0), (10.0, 0.0)),
            Edge::new((10.0, 0.0), (2.5, 2.5)),
        ],
    };
    let poly_hexagon = Polygon {
        edges: vec![
            Edge::new((3.0, 0.0), (7.0, 0.0)),
            Edge::new((7.0, 0.0), (10.0, 5.0)),
            Edge::new((10.0, 5.0), (7.0, 10.0)),
            Edge::new((7.0, 10.0), (3.0, 10.0)),
            Edge::new((3.0, 10.0), (0.0, 5.0)),
            Edge::new((0.0, 5.0), (3.0, 0.0)),
        ],
    };
    print!("\nSquare¬†:");
    for pt in &testpoints {
        print!(" {:?}", pt_in_polygon(pt, &poly_square));
    }
    print!("\nSquare with hole:");
    for pt in &testpoints {
        print!(" {:?}", pt_in_polygon(pt, &poly_square_hole));
    }
    print!("\nStrange polygon¬†:");
    for pt in &testpoints {
        print!(" {:?}", pt_in_polygon(pt, &poly_strange));
    }
    print!("\nHexagon¬†:");
    for pt in &testpoints {
        print!(" {:?}", pt_in_polygon(pt, &poly_hexagon));
    }
    println!();
}
```

Output:

```rust
Square¬†: true true false false true true false
Square with hole: false true false false true true false
Strange polygon¬†: true false false false true true false
Hexagon¬†: true true false false true true false

```

# Sockets<a id="sec-365"></a>

For this exercise a program is open a socket to localhost on port 256 and send the message "hello socket world" before closing the socket.

Catching any exceptions or errors is not required.

Works with: Rust 1.0 stable

```rust
use std::io::prelude::*;
use std::net::TcpStream;
¬†
fn main() {
    // Open a tcp socket connecting to 127.0.0.1:256, no error handling (unwrap)
    let mut my_stream = TcpStream::connect("127.0.0.1:256").unwrap();
¬†
    // Write 'hello socket world' to the stream, ignoring the result of write
    let _ = my_stream.write(b"hello socket world");
¬†
} // <- my_stream's drop function gets called, which closes the socket
```

# JortSort<a id="sec-366"></a>

jortSort is a sorting toolset that makes the user do the work and guarantees efficiency because you don't have to sort ever again. It was originally presented by Jenn "Moneydollars" Schiffer at the prestigious JSConf.

jortSort is a function that takes a single array of comparable objects as its argument. It then sorts the array in ascending order and compares the sorted array to the originally provided array. If the arrays match (i.e. the original array was already sorted), the function returns true. If the arrays do not match (i.e. the original array was not sorted), the function returns false.

Translation of: JavaScript

```rust
use std::cmp::{Ord, Eq};
¬†
fn jort_sort<T: Ord + Eq + Clone>(array: Vec<T>) -> bool {
    // sort the array
    let mut sorted_array = array.to_vec();
    sorted_array.sort();
¬†
    // compare to see if it was originally sorted
    for i in 0..array.len() {
        if array[i]¬†!= sorted_array[i] {
            return false;
        }
    }
¬†
    return true;
}
```

# Atomic updates<a id="sec-367"></a>

Task

Define a data type consisting of a fixed number of 'buckets', each containing a nonnegative integer value, which supports operations to:

get the current value of any bucket remove a specified amount from one specified bucket and add it to another, preserving the total of all bucket values, and clamping the transferred amount to ensure the values remain non-negative

In order to exercise this data type, create one set of buckets, and start three concurrent tasks:

As often as possible, pick two buckets and make their values closer to equal. As often as possible, pick two buckets and arbitrarily redistribute their values. At whatever rate is convenient, display (by any means) the total value and, optionally, the individual values of each bucket.

The display task need not be explicit; use of e.g. a debugger or trace tool is acceptable provided it is simple to set up to provide the display.

This task is intended as an exercise in atomic operations. ¬† The sum of the bucket values must be preserved even if the two tasks attempt to perform transfers simultaneously, and a straightforward solution is to ensure that at any time, only one transfer is actually occurring ‚Äî that the transfer operation is atomic.

Library: rand

```rust
extern crate rand;
¬†
use std::sync::{Arc, Mutex};
use std::thread;
use std::cmp;
use std::time::Duration;
¬†
use rand::Rng;
use rand::distributions::{IndependentSample, Range};
¬†
trait Buckets {
    fn equalize<R:Rng>(&mut self, rng: &mut R);
    fn randomize<R:Rng>(&mut self, rng: &mut R);
    fn print_state(&self);
}
¬†
impl Buckets for [i32] {
    fn equalize<R:Rng>(&mut self, rng: &mut R) {
        let range = Range::new(0,self.len()-1);
        let src = range.ind_sample(rng);
        let dst = range.ind_sample(rng);
        if dst¬†!= src {
            let amount = cmp::min(((dst + src) / 2) as i32, self[src]);
            let multiplier = if amount >= 0 { -1 } else { 1 };
            self[src] += amount * multiplier;
            self[dst] -= amount * multiplier;
        }
    }
    fn randomize<R:Rng>(&mut self, rng: &mut R) {
        let ind_range = Range::new(0,self.len()-1);
        let src = ind_range.ind_sample(rng);
        let dst = ind_range.ind_sample(rng);
        if dst¬†!= src {
            let amount = cmp::min(Range::new(0,20).ind_sample(rng), self[src]);
            self[src] -= amount;
            self[dst] += amount;
¬†
        }
    }
    fn print_state(&self) {
        println!("{:?} = {}", self, self.iter().sum::<i32>());
    }
}
¬†
fn main() {
    let e_buckets = Arc::new(Mutex::new([10; 10]));
    let r_buckets = e_buckets.clone();
    let p_buckets = e_buckets.clone();
¬†
    thread::spawn(move || { 
        let mut rng = rand::thread_rng();
        loop {
            let mut buckets = e_buckets.lock().unwrap();
            buckets.equalize(&mut rng);
        }
    });
    thread::spawn(move || {
        let mut rng = rand::thread_rng();
        loop {
            let mut buckets = r_buckets.lock().unwrap();
            buckets.randomize(&mut rng);
        }
    });
¬†
    let sleep_time = Duration::new(1,0);
    loop {
        {
            let buckets = p_buckets.lock().unwrap();
            buckets.print_state();
        }
        thread::sleep(sleep_time);
    }
}
```

# Get system command output<a id="sec-368"></a>

Task

Execute a system command and get its output into the program. The output may be stored in any kind of collection (array, list, etc.).

Related task

Execute a system command

```rust
use std::process::Command;
use std::io::{Write, self};
¬†
fn main() {
    let output = Command::new("/bin/cat")
                            .arg("/etc/fstab")
                            .output()
                            .expect("failed to execute process");
¬†
    io::stdout().write(&output.stdout);
}
```

# Rosetta Code/Count examples<a id="sec-369"></a>

task

Essentially, count the number of occurrences of =={{header| on each task page.

Output:

```
100 doors: 20 examples.
99 Bottles of Beer: 29 examples.
Abstract type: 10 examples.

Total: X examples.
```

For a full output, updated periodically, see Rosetta Code/Count examples/Full list.

You'll need to use the Media Wiki API, which you can find out about locally, here, or in Media Wiki's API documentation at, API:Query

```rust
extern crate reqwest;
extern crate url;
extern crate rustc_serialize;
¬†
use std::io::Read;
use self::url::Url;
use rustc_serialize::json::{self, Json};
¬†
pub struct Task {
    page_id: u64,
    pub title: String,
}
¬†
#[derive(Debug)]
enum ParseError {
    /// Something went wrong with the HTTP request to the API.
    Http(reqwest::Error),
¬†
    /// There was a problem parsing the API response into JSON.
    Json(json::ParserError),
¬†
    /// Unexpected JSON format from response
    UnexpectedFormat,
}
impl From<json::ParserError> for ParseError {
    fn from(error: json::ParserError) -> Self {
        ParseError::Json(error)
    }
}
¬†
impl From<reqwest::Error> for ParseError {
    fn from(error: reqwest::Error) -> Self {
        ParseError::Http(error)
    }
}
¬†
¬†
fn construct_query_category(category: &str) -> Url {
    let mut base_url = Url::parse("http://rosettacode.org/mw/api.php").unwrap();
    let cat = format!("Category:{}", category);
    let query_pairs = vec![("action", "query"),
                           ("format", "json"),
                           ("list", "categorymembers"),
                           ("cmlimit", "500"),
                           ("cmtitle", &cat),
                           ("continue", "")];
    base_url.query_pairs_mut().extend_pairs(query_pairs.into_iter());
    base_url
}
¬†
fn construct_query_task_content(task_id: &str) -> Url {
    let mut base_url = Url::parse("http://rosettacode.org/mw/api.php").unwrap();
    let mut query_pairs =
        vec![("action", "query"), ("format", "json"), ("prop", "revisions"), ("rvprop", "content")];
    query_pairs.push(("pageids", task_id));
    base_url.query_pairs_mut().extend_pairs(query_pairs.into_iter());
    base_url
}
¬†
fn query_api(url: Url) -> Result<Json, ParseError> {
    let mut response = try!(reqwest::get(url.as_str()));
    // Build JSON
    let mut body = String::new();
    response.read_to_string(&mut body).unwrap();
¬†
    Ok(try!(Json::from_str(&body)))
}
¬†
fn parse_all_tasks(reply: &Json) -> Result<Vec<Task>, ParseError> {
    let json_to_task = |json: &Json| -> Result<Task, ParseError> {
        let page_id: u64 = try!(json.find("pageid")
            .and_then(|id| id.as_u64())
            .ok_or(ParseError::UnexpectedFormat));
        let title: &str = try!(json.find("title")
            .and_then(|title| title.as_string())
            .ok_or(ParseError::UnexpectedFormat));
¬†
        Ok(Task {
            page_id: page_id,
            title: title.to_owned(),
        })
    };
    let tasks_json = try!(reply.find_path(&["query", "categorymembers"])
        .and_then(|tasks| tasks.as_array())
        .ok_or(ParseError::UnexpectedFormat));
¬†
    // Convert into own type
    tasks_json.iter().map(json_to_task).collect()
}
fn count_number_examples(task: &Json, task_id: u64) -> Result<u32, ParseError> {
    let revisions =
        try!(task.find_path(&["query", "pages", task_id.to_string().as_str(), "revisions"])
            .and_then(|content| content.as_array())
            .ok_or(ParseError::UnexpectedFormat));
    let content = try!(revisions[0]
        .find("*")
        .and_then(|content| content.as_string())
        .ok_or(ParseError::UnexpectedFormat));
    Ok(content.split("=={{header").count() as u32)
}
¬†
pub fn query_all_tasks() -> Vec<Task> {
    let query = construct_query_category("Programming_Tasks");
    let json: Json = query_api(query).unwrap();
    parse_all_tasks(&json).unwrap()
}
¬†
pub fn query_a_task(task: &Task) -> u32 {
    let query = construct_query_task_content(&task.page_id.to_string());
    let json: Json = query_api(query).unwrap();
    count_number_examples(&json, task.page_id).unwrap()
}
```

The function is then run using the following:

```rust
¬†
extern crate count_examples;
fn main() {
    let all_tasks = count_examples::query_all_tasks();
    for task in &all_tasks {
        let count = count_examples::query_a_task(task);
        println!("Task: {} has {} examples", task.title, count);
    }
}
```

# Parametric polymorphism<a id="sec-370"></a>

Parametric Polymorphism

type variables

Task

Write a small example for a type declaration that is parametric over another type, together with a short bit of code (and its type signature) that uses it.

A good example is a container type, let's say a binary tree, together with some function that traverses the tree, say, a map-function that operates on every element of the tree.

This language feature only applies to statically-typed languages.

```rust
struct TreeNode<T> {
    value: T,
    left: Option<Box<TreeNode<T>>>,
    right: Option<Box<TreeNode<T>>>,
}
¬†
impl <T> TreeNode<T> {
    fn my_map<U,F>(&self, f: &F) -> TreeNode<U> where
            F: Fn(&T) -> U {
        TreeNode {
            value: f(&self.value),
            left: match self.left {
                None => None,
                Some(ref n) => Some(Box::new(n.my_map(f))),
            },
            right: match self.right {
                None => None,
                Some(ref n) => Some(Box::new(n.my_map(f))),
            },
        }
    }
}
¬†
fn main() {
    let root = TreeNode {
        value: 3,
        left: Some(Box::new(TreeNode {
            value: 55,
            left: None,
            right: None,
        })),
        right: Some(Box::new(TreeNode {
            value: 234,
            left: Some(Box::new(TreeNode {
                value: 0,
                left: None,
                right: None,
            })),
            right: None,
        })),
    };
    root.my_map(&|x| { println!("{}" , x)});
    println!("---------------");
    let new_root = root.my_map(&|x| *x as f64 * 333.333f64);
    new_root.my_map(&|x| { println!("{}" , x) });
}
```

# Munching squares<a id="sec-371"></a>

Render a graphical pattern where each pixel is colored by the value of 'x xor y' from an arbitrary color table.

```rust
extern crate image;
¬†
use image::{ImageBuffer, Pixel, Rgb};
¬†
fn main() {
    let mut img = ImageBuffer::new(256, 256);
¬†
    for x in 0..256 {
        for y in 0..256 {
            let pixel = Rgb::from_channels(0, x as u8 ^ y as u8, 0, 0);
            img.put_pixel(x, y, pixel);
        }
    }
¬†
    let _ = img.save("output.png");
}
```

# File extension is in extensions list<a id="sec-372"></a>

Filename extensions

Task[edit]

Given an arbitrary filename and a list of extensions, tell whether the filename has one of those extensions.

Notes:

The check should be case insensitive. The extension must occur at the very end of the filename, and be immediately preceded by a dot (.). You may assume that none of the given extensions are the empty string, and none of them contain a dot. Other than that they may be arbitrary strings.

Extra credit: Allow extensions to contain dots. This way, users of your function/program have full control over what they consider as the extension in cases like:

```
archive.tar.gz

```

Please state clearly whether or not your solution does this.

Test cases

The following test cases all assume this list of extensions: ¬† zip, rar, 7z, gz, archive, A##

Filename Result MyData.a## true MyData.tar.Gz true MyData.gzip false MyData.7z.backup false MyData&#x2026; false MyData false

If your solution does the extra credit requirement, add tar.bz2 to the list of extensions, and check the following additional test cases:

Filename Result MyData<sub>v1.0.tar.bz2</sub> true MyData<sub>v1.0.bz2</sub> false

Motivation

Checking if a file is in a certain category of file formats with known extensions (e.g. archive files, or image files) is a common problem in practice, and may be approached differently from extracting and outputting an arbitrary extension (see e.g. FileNameExtensionFilter in Java).

It also requires less assumptions about the format of an extension, because the calling code can decide what extensions are valid.

For these reasons, this task exists in addition to the Extract file extension task.

Related tasks

Extract file extension String matching

Does extra credit.

```rust
fn main() {
    let exts = ["zip", "rar", "7z", "gz", "archive", "A##", "tar.bz2"];
    let filenames = [
        "MyData.a##",
        "MyData.tar.Gz",
        "MyData.gzip",
        "MyData.7z.backup",
        "MyData...",
        "MyData",
        "MyData_v1.0.tar.bz2",
        "MyData_v1.0.bz2",
    ];
¬†
    println!("extenstions: {:?}\n", exts);
¬†
    for filename in filenames.iter() {
        let check = exts.iter().any(|ext| {
            filename
                .to_lowercase()
                .ends_with(&format!(".{}", ext.to_lowercase()))
        });
        println!("{:20} {}", filename, check);
    }
}
¬†
```

Output:

```rust
extensions: ["zip", "rar", "7z", "gz", "archive", "A##", "tar.bz2"]

MyData.a##           true
MyData.tar.Gz        true
MyData.gzip          false
MyData.7z.backup     false
MyData...            false
MyData               false
MyData_v1.0.tar.bz2  true
MyData_v1.0.bz2      false

```

# Unix/ls<a id="sec-373"></a>

Task

Write a program that will list everything in the current folder, ¬† similar to:

¬† the Unix utility ¬† ‚Äúls‚Äù ¬† [1] ¬† ¬† ¬† or ¬† the Windows terminal command ¬† ‚ÄúDIR‚Äù

The output must be sorted, but printing extended details and producing multi-column output is not required.

Example output

For the list of paths:

```
/foo/bar
/foo/bar/1
/foo/bar/2
/foo/bar/a
/foo/bar/b

```

When the program is executed in ¬† \`/foo\`, ¬† it should print:

```
bar

```

and when the program is executed in ¬† \`/foo/bar\`, ¬† it should print:

```
1
2
a
b

```

```rust
use std::{env, fmt, fs, process};
use std::io::{self, Write};
use std::path::Path;
¬†
fn main() {
    let cur = env::current_dir().unwrap_or_else(|e| exit_err(e, 1));
    let arg = env::args().nth(1);
    print_files(arg.as_ref().map_or(cur.as_path(), |p| Path::new(p)))
        .unwrap_or_else(|e| exit_err(e, 2));
}
¬†
#[inline]
fn print_files(path: &Path) -> io::Result<()> {
    for x in try!(fs::read_dir(path)) {
        println!("{}", try!(x).file_name().to_string_lossy());
    }
    Ok(())
}
¬†
#[inline]
fn exit_err<T>(msg: T, code: i32) ->¬†! where T: fmt::Display {
    writeln!(&mut io::stderr(), "{}", msg).expect("Could not write to stderr");
    process::exit(code)
}
```

Output:

```rust
$ mkdir -p foo/bar
$ ./unix_ls
foo
unix_ls
$ cd foo/bar
$ touch a b 1 2
$ cd ../..
$ ./unix_ls foo
bar
$ ./unix_ls foo/bar
1
2
a
b

```

# Elementary cellular automaton<a id="sec-374"></a>

An elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors. Those three values can be encoded with three bits.

The rules of evolution are then encoded with eight bits indicating the outcome of each of the eight possibilities 111, 110, 101, 100, 011, 010, 001 and 000 in this order. Thus for instance the rule 13 means that a state is updated to 1 only in the cases 011, 010 and 000, since 13 in binary is 0b00001101.

Task

Create a subroutine, program or function that allows to create and visualize the evolution of any of the 256 possible elementary cellular automaton of arbitrary space length and for any given initial state. You can demonstrate your solution with any automaton of your choice.

The space state should wrap: this means that the left-most cell should be considered as the right neighbor of the right-most cell, and reciprocally.

This task is basically a generalization of one-dimensional cellular automata.

See also

Cellular automata (natureofcode.com)

```rust
¬†
fn main() {
    struct ElementaryCA {
        rule: u8,
        state: u64,
    }
    impl ElementaryCA {
        fn new(rule: u8) -> (u64, ElementaryCA) {
            let out = ElementaryCA {
                rule,
                state: 1,
            };
            (out.state, out)
        }
        fn next(&mut self) -> u64 {
            let mut next_state = 0u64;
            let state = self.state;
            for i in 0..64 {
                next_state |= (((self.rule as u64)>>(7 & (state.rotate_left(1).rotate_right(i as u32)))) & 1)<<i;
            }
            self.state = next_state;
            self.state
        }
    }
    fn rep_u64(val: u64) -> String {
        let mut out = String::new();
        for i in (0..64).rev() {
            if 1<<i & val¬†!= 0 {
                out = out + "\u{2588}";
            } else {
                out = out + "-";
            }
        }
        out
    }
¬†
    let (i, mut thirty) = ElementaryCA::new(154);
    println!("{}",rep_u64(i));
    for _ in 0..32 {
        let s = thirty.next();
        println!("{}", rep_u64(s));
    }
}
¬†
```

Output:

```rust
---------------------------------------------------------------‚ñà
‚ñà-------------------------------------------------------------‚ñà-
-‚ñà-----------------------------------------------------------‚ñà--
‚ñà-‚ñà---------------------------------------------------------‚ñà-‚ñà-
---‚ñà-------------------------------------------------------‚ñà----
--‚ñà-‚ñà-----------------------------------------------------‚ñà-‚ñà---
-‚ñà---‚ñà---------------------------------------------------‚ñà---‚ñà--
‚ñà-‚ñà-‚ñà-‚ñà-------------------------------------------------‚ñà-‚ñà-‚ñà-‚ñà-
-------‚ñà-----------------------------------------------‚ñà--------
------‚ñà-‚ñà---------------------------------------------‚ñà-‚ñà-------
-----‚ñà---‚ñà-------------------------------------------‚ñà---‚ñà------
----‚ñà-‚ñà-‚ñà-‚ñà-----------------------------------------‚ñà-‚ñà-‚ñà-‚ñà-----
---‚ñà-------‚ñà---------------------------------------‚ñà-------‚ñà----
--‚ñà-‚ñà-----‚ñà-‚ñà-------------------------------------‚ñà-‚ñà-----‚ñà-‚ñà---
-‚ñà---‚ñà---‚ñà---‚ñà-----------------------------------‚ñà---‚ñà---‚ñà---‚ñà--
‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà---------------------------------‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-
---------------‚ñà-------------------------------‚ñà----------------
--------------‚ñà-‚ñà-----------------------------‚ñà-‚ñà---------------
-------------‚ñà---‚ñà---------------------------‚ñà---‚ñà--------------
------------‚ñà-‚ñà-‚ñà-‚ñà-------------------------‚ñà-‚ñà-‚ñà-‚ñà-------------
-----------‚ñà-------‚ñà-----------------------‚ñà-------‚ñà------------
----------‚ñà-‚ñà-----‚ñà-‚ñà---------------------‚ñà-‚ñà-----‚ñà-‚ñà-----------
---------‚ñà---‚ñà---‚ñà---‚ñà-------------------‚ñà---‚ñà---‚ñà---‚ñà----------
--------‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-----------------‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà---------
-------‚ñà---------------‚ñà---------------‚ñà---------------‚ñà--------
------‚ñà-‚ñà-------------‚ñà-‚ñà-------------‚ñà-‚ñà-------------‚ñà-‚ñà-------
-----‚ñà---‚ñà-----------‚ñà---‚ñà-----------‚ñà---‚ñà-----------‚ñà---‚ñà------
----‚ñà-‚ñà-‚ñà-‚ñà---------‚ñà-‚ñà-‚ñà-‚ñà---------‚ñà-‚ñà-‚ñà-‚ñà---------‚ñà-‚ñà-‚ñà-‚ñà-----
---‚ñà-------‚ñà-------‚ñà-------‚ñà-------‚ñà-------‚ñà-------‚ñà-------‚ñà----
--‚ñà-‚ñà-----‚ñà-‚ñà-----‚ñà-‚ñà-----‚ñà-‚ñà-----‚ñà-‚ñà-----‚ñà-‚ñà-----‚ñà-‚ñà-----‚ñà-‚ñà---
-‚ñà---‚ñà---‚ñà---‚ñà---‚ñà---‚ñà---‚ñà---‚ñà---‚ñà---‚ñà---‚ñà---‚ñà---‚ñà---‚ñà---‚ñà---‚ñà--
‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-‚ñà-
----------------------------------------------------------------

```

# Old lady swallowed a fly<a id="sec-375"></a>

Task

Present a program which emits the lyrics to the song ¬† I Knew an Old Lady Who Swallowed a Fly, ¬† taking advantage of the repetitive structure of the song's lyrics.

This song has multiple versions with slightly different lyrics, so all these programs might not emit identical output.

Related tasks

¬† 99 Bottles of Beer ¬† The Twelve Days of Christmas

Rust Playground

```rust
enum Action {Once, Every, Die}
use Action::*;
¬†
fn main() {
    let animals = [ ("horse" , Die  , "She's dead, of course!")
                  , ("donkey", Once , "It was rather wonky. To swallow a donkey.")
                  , ("cow"   , Once , "I don't know how. To swallow a cow.")
                  , ("goat"  , Once , "She just opened her throat. To swallow a goat.")
                  , ("pig"   , Once , "Her mouth was so big. To swallow a pig.")
                  , ("dog"   , Once , "What a hog. To swallow a dog.")
                  , ("cat"   , Once , "Fancy that. To swallow a cat.")
                  , ("bird"  , Once , "Quite absurd. To swallow a bird.")
                  , ("spider", Once , "That wriggled and jiggled and tickled inside her.")
                  , ("fly"   , Every, "I don't know why she swallowed the fly.")
                  ];
¬†
    for (i, a) in animals.iter().enumerate().rev() {
        println!("There was an old lady who swallowed a {}\n{}", a.0, a.2);
¬†
        if let Die = a.1 {break}
¬†
        for (swallowed, to_catch) in animals[i..].iter().zip(&animals[i+1..]) {
            println!("She swallowed the {} to catch the {}.", swallowed.0, to_catch.0);
¬†
            if let Every = to_catch.1 {
                println!("{}", to_catch.2);
            }
        }
¬†
        println!("Perhaps she'll die.\n");
    }
}
```

# Mouse position<a id="sec-376"></a>

Get the current location of the mouse cursor relative to the active window. Please specify if the window may be externally created.

Prints current location of the mouse cursor relative to any active window. This example relies on the Windows API.

```rust
// rustc 0.9 (7613b15 2014-01-08 18:04:43 -0800)
¬†
use std::libc::{BOOL, HANDLE, LONG};
use std::ptr::mut_null;
¬†
type HWND = HANDLE;
¬†
#[deriving(Eq)]
struct POINT {
    x: LONG,
    y: LONG
}
¬†
#[link_name = "user32"]
extern "system" {
    fn GetCursorPos(lpPoint:&mut POINT) -> BOOL;
    fn GetForegroundWindow() -> HWND;
    fn ScreenToClient(hWnd:HWND, lpPoint:&mut POINT);
}
¬†
fn main() {
    let mut pt = POINT{x:0, y:0};
    loop {
        std::io::timer::sleep(100); // sleep duration in milliseconds
¬†
        let pt_prev = pt;
        unsafe { GetCursorPos(&mut pt) };
        if pt¬†!= pt_prev {
            let h = unsafe { GetForegroundWindow() };
            if h == mut_null() { continue }
¬†
            let mut pt_client = pt;
            unsafe { ScreenToClient(h, &mut pt_client) };
            println!("x: {}, y: {}", pt_client.x, pt_client.y);
        }
    }
}
```

Output:

```rust
x: 550, y: 614
x: 650, y: 248
x: 612, y: 0
x: 620, y: 0
x: 405, y: 0
x: 0, y: 0
^C
```

# Average loop length<a id="sec-377"></a>

Let f be a uniformly-randomly chosen mapping from the numbers 1..N to the numbers 1..N (note: not necessarily a permutation of 1..N; the mapping could produce a number in more than one way or not at all). At some point, the sequence 1, f(1), f(f(1))&#x2026; will contain a repetition, a number that occurring for the second time in the sequence.

Task

Write a program or a script that estimates, for each N, the average length until the first such repetition.

Also calculate this expected length using an analytical formula, and optionally compare the simulated result with the theoretical one.

This problem comes from the end of Donald Knuth's Christmas tree lecture 2011.

Example of expected output:

```
 N    average    analytical    (error)
===  =========  ============  =========
  1     1.0000        1.0000  (  0.00%)
  2     1.4992        1.5000  (  0.05%)
  3     1.8784        1.8889  (  0.56%)
  4     2.2316        2.2188  (  0.58%)
  5     2.4982        2.5104  (  0.49%)
  6     2.7897        2.7747  (  0.54%)
  7     3.0153        3.0181  (  0.09%)
  8     3.2429        3.2450  (  0.07%)
  9     3.4536        3.4583  (  0.14%)
 10     3.6649        3.6602  (  0.13%)
 11     3.8091        3.8524  (  1.12%)
 12     3.9986        4.0361  (  0.93%)
 13     4.2074        4.2123  (  0.12%)
 14     4.3711        4.3820  (  0.25%)
 15     4.5275        4.5458  (  0.40%)
 16     4.6755        4.7043  (  0.61%)
 17     4.8877        4.8579  (  0.61%)
 18     4.9951        5.0071  (  0.24%)
 19     5.1312        5.1522  (  0.41%)
 20     5.2699        5.2936  (  0.45%)
```

Library: rand

```rust
extern crate rand;
¬†
use rand::{ThreadRng, thread_rng};
use rand::distributions::{IndependentSample, Range};
use std::collections::HashSet;
use std::env;
use std::process;
¬†
fn help() {
    println!("usage: average_loop_length <max_N> <trials>");
}
¬†
fn main() {
    let args: Vec<String> = env::args().collect();
    let mut max_n: u32 = 20;
    let mut trials: u32 = 1000;
¬†
    match args.len() {
        1 => {}
        3 => {
            max_n = args[1].parse::<u32>().unwrap();
            trials = args[2].parse::<u32>().unwrap();
        }
        _ => {
            help();
            process::exit(0);
        }
    }
¬†
    let mut rng = thread_rng();
¬†
    println!(" N    average    analytical    (error)");
    println!("===  =========  ============  =========");
    for n in 1..(max_n + 1) {
        let the_analytical = analytical(n);
        let the_empirical = empirical(n, trials, &mut rng);
        println!(" {:>2}     {:3.4}        {:3.4}  ( {:>+1.2}%)",
                 n,
                 the_empirical,
                 the_analytical,
                 100f64 * (the_empirical / the_analytical - 1f64));
    }
}
¬†
fn factorial(n: u32) -> f64 {
    (1..n + 1).fold(1f64, |p, n| p * n as f64)
}
¬†
fn analytical(n: u32) -> f64 {
    let sum: f64 = (1..(n + 1))
                       .map(|i| factorial(n) / (n as f64).powi(i as i32) / factorial(n - i))
                       .fold(0f64, |a, v| a + v);
    sum
}
¬†
fn empirical(n: u32, trials: u32, rng: &mut ThreadRng) -> f64 {
    let sum: f64 = (0..trials)
                       .map(|_t| {
                           let mut item = 1u32;
                           let mut seen = HashSet::new();
                           let range = Range::new(1u32, n + 1);
¬†
                           for step in 0..n {
                               if seen.contains(&item) {
                                   return step as f64;
                               }
                               seen.insert(item);
                               item = range.ind_sample(rng);
                           }
                           n as f64
                       })
                       .fold(0f64, |a, v| a + v);
    sum / trials as f64
}
¬†
¬†
¬†
```

Output:

Using default arguments:

```rust
N    average    analytical    (error)
===  =========  ============  =========
  1     1.0000        1.0000  ( +0.00%)
  2     1.4992        1.5000  ( -0.05%)
  3     1.8881        1.8889  ( -0.04%)
  4     2.2177        2.2188  ( -0.05%)
  5     2.5107        2.5104  ( +0.01%)
  6     2.7752        2.7747  ( +0.02%)
  7     3.0172        3.0181  ( -0.03%)
  8     3.2452        3.2450  ( +0.01%)
  9     3.4628        3.4583  ( +0.13%)
 10     3.6606        3.6602  ( +0.01%)
 11     3.8515        3.8524  ( -0.02%)
 12     4.0348        4.0361  ( -0.03%)
 13     4.2105        4.2123  ( -0.04%)
 14     4.3835        4.3820  ( +0.03%)
 15     4.5477        4.5458  ( +0.04%)
 16     4.7042        4.7043  ( -0.00%)
 17     4.8580        4.8579  ( +0.00%)
 18     5.0076        5.0071  ( +0.01%)
 19     5.1554        5.1522  ( +0.06%)
 20     5.2911        5.2936  ( -0.05%)

```

# CUSIP<a id="sec-378"></a>

This page uses content from Wikipedia. The original article was at CUSIP. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

A ¬† CUSIP ¬† is a nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. The CUSIP was adopted as an American National Standard under Accredited Standards X9.6.

Task

Ensure the last digit ¬† (i.e., the ¬† check digit) ¬† of the CUSIP code (the 1st column) is correct, against the following:

¬† 037833100 ¬† ¬† ¬† Apple Incorporated ¬† 17275R102 ¬† ¬† ¬† Cisco Systems ¬† 38259P508 ¬† ¬† ¬† Google Incorporated ¬† 594918104 ¬† ¬† ¬† Microsoft Corporation ¬† 68389X106 ¬† ¬† ¬† Oracle Corporation ¬† (incorrect) ¬† 68389X105 ¬† ¬† ¬† Oracle Corporation

Example pseudo-code below.

```
algorithm Cusip-Check-Digit(cusip) is
   Input: an 8-character CUSIP
¬†
   sum¬†:= 0
   for 1 ‚â§ i ‚â§ 8 do
      c¬†:= the ith character of cusip
      if c is a digit then
         v¬†:= numeric value of the digit c
      else if c is a letter then
         p¬†:= ordinal position of c in the alphabet (A=1, B=2...)
         v¬†:= p + 9
      else if c = "*" then
         v¬†:= 36
      else if c = "@" then
         v¬†:= 37
      else if' c = "#" then
         v¬†:= 38
      end if
      if i is even then
         v¬†:= v √ó 2
      end if
¬†
      sum¬†:= sum + int ( v div 10 ) + v mod 10
   repeat
¬†
   return (10 - (sum mod 10)) mod 10
end function
```

See related tasks

SEDOL ISIN

```rust
fn cusip_check(cusip: &str) -> bool {
    if cusip.len()¬†!= 9 {
        return false;
    }
¬†
    let mut v = 0;
    let capital_cusip = cusip.to_uppercase();
    let char_indices = capital_cusip.as_str().char_indices().take(7);
¬†
    let total = char_indices.fold(0, |total, (i, c)| {
        v = match c {
            '*' => 36,
            '@' => 37,
            '#' => 38,
            _ if c.is_digit(10) => c.to_digit(10).unwrap() as u8,
            _ if c.is_alphabetic() => (c as u8) - b'A' + 1 + 9,
            _ => v,
        };
¬†
        if i¬†% 2¬†!= 0 {
            v *= 2
        }
        total + (v / 10) + v¬†% 10
    });
¬†
    let check = (10 - (total¬†% 10))¬†% 10;
    (check.to_string().chars().nth(0).unwrap()) == cusip.chars().nth(cusip.len() - 1).unwrap()
}
¬†
fn main() {
    let codes = [
        "037833100",
        "17275R102",
        "38259P508",
        "594918104",
        "68389X106",
        "68389X105",
    ];
    for code in &codes {
        println!("{} -> {}", code, cusip_check(code))
    }
}
```

Output:

```rust
037833100 -> True
17275R102 -> True
38259P508 -> True
594918104 -> True
68389X106 -> False
68389X105 -> True

```

# Determine if only one instance is running<a id="sec-379"></a>

This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.

Using TCP socket

```rust
use std::net::TcpListener;
¬†
fn create_app_lock(port: u16) -> TcpListener {
    match TcpListener::bind(("0.0.0.0", port)) {
        Ok(socket) => {
            socket
        },
        Err(_) => {
            panic!("Couldn't lock port {}: another instance already running?", port);
        }
    }
}
¬†
fn remove_app_lock(socket: TcpListener) {
    drop(socket);
}
¬†
fn main() {
    let lock_socket = create_app_lock(12345);
    // ...
    // your code here
    // ...
    remove_app_lock(lock_socket);
}
```

# Carmichael 3 strong pseudoprimes<a id="sec-380"></a>

A lot of composite numbers can be separated from primes by Fermat's Little Theorem, but there are some that completely confound it.

The ¬† Miller Rabin Test ¬† uses a combination of Fermat's Little Theorem and Chinese Division Theorem to overcome this.

The purpose of this task is to investigate such numbers using a method based on ¬† Carmichael numbers, ¬† as suggested in ¬† Notes by G.J.O Jameson March 2010.

Task

Find Carmichael numbers of the form:

Prime1 √ó Prime2 √ó Prime3

where ¬† (Prime1 < Prime2 < Prime3) ¬† for all ¬† Prime1 ¬† up to ¬† 61. (See page 7 of ¬† Notes by G.J.O Jameson March 2010 ¬† for solutions.)

Pseudocode

For a given ¬† {\displaystyle Prime<sub>1</sub>}

```
for 1 < h3 < Prime1
    for 0 < d < h3+Prime1
         if (h3+Prime1)*(Prime1-1) mod d == 0 and -Prime1 squared mod h3 == d mod h3
         then
               Prime2 = 1 + ((Prime1-1) * (h3+Prime1)/d)
               next d if Prime2 is not prime
               Prime3 = 1 + (Prime1*Prime2/h3)
               next d if Prime3 is not prime
               next d if (Prime2*Prime3) mod (Prime1-1) not equal 1
               Prime1 * Prime2 * Prime3 is a Carmichael Number

```

```rust
¬†
fn is_prime(n: i64) -> bool {
    if n > 1 {
        (2..((n / 2) + 1)).all(|x| n¬†% x¬†!= 0)
    } else {
        false
    }
}
¬†
// The modulo operator actually calculates the remainder.
fn modulo(n: i64, m: i64) -> i64 {
    ((n¬†% m) + m)¬†% m
}
¬†
fn carmichael(p1: i64) -> Vec<(i64, i64, i64)> {
    let mut results = Vec::new();
    if¬†!is_prime(p1) {
        return results;
    }
¬†
    for h3 in 2..p1 {
        for d in 1..(h3 + p1) {
            if (h3 + p1) * (p1 - 1)¬†% d¬†!= 0 || modulo(-p1 * p1, h3)¬†!= d¬†% h3 {
                continue;
            }
¬†
            let p2 = 1 + ((p1 - 1) * (h3 + p1) / d);
            if¬†!is_prime(p2) {
                continue;
            }
¬†
            let p3 = 1 + (p1 * p2 / h3);
            if¬†!is_prime(p3) || ((p2 * p3)¬†% (p1 - 1)¬†!= 1) {
                continue;
            }
¬†
            results.push((p1, p2, p3));
        }
    }
¬†
    results
}
¬†
fn main() {
    (1..62)
        .filter(|&x| is_prime(x))
        .map(carmichael)
        .filter(|x|¬†!x.is_empty())
        .flat_map(|x| x)
        .inspect(|x| println!("{:?}", x))
        .count(); // Evaluate entire iterator
}
¬†
```

Output:

```rust
(3, 11, 17)
(5, 29, 73)
(5, 17, 29)
(5, 13, 17)
.
.
.
(61, 661, 2521)
(61, 271, 571)
(61, 241, 421)
(61, 3361, 4021)

```

# Vector<a id="sec-381"></a>

Task

Implement a Vector class (or a set of functions) that models a Physical Vector. The four basic operations and a pretty print function should be implemented.

The Vector may be initialized in any reasonable way.

Start and end points, and direction Angular coefficient and value (length)

The four operations to be implemented are:

Vector + Vector addition Vector - Vector subtraction Vector \* scalar multiplication Vector / scalar division

```rust
use std::fmt;
use std::ops::{Add, Div, Mul, Sub};
¬†
#[derive(Copy, Clone, Debug)]
pub struct Vector<T> {
    pub x: T,
    pub y: T,
}
¬†
impl<T> fmt::Display for Vector<T>
where
    T: fmt::Display,
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if let Some(prec) = f.precision() {
            write!(f, "[{:.*}, {:.*}]", prec, self.x, prec, self.y)
        } else {
            write!(f, "[{}, {}]", self.x, self.y)
        }
    }
}
¬†
impl<T> Vector<T> {
    pub fn new(x: T, y: T) -> Self {
        Vector { x, y }
    }
}
¬†
impl Vector<f64> {
    pub fn from_polar(r: f64, theta: f64) -> Self {
        Vector {
            x: r * theta.cos(),
            y: r * theta.sin(),
        }
    }
}
¬†
impl<T> Add for Vector<T>
where
    T: Add<Output = T>,
{
    type Output = Self;
¬†
    fn add(self, other: Self) -> Self::Output {
        Vector {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}
¬†
impl<T> Sub for Vector<T>
where
    T: Sub<Output = T>,
{
    type Output = Self;
¬†
    fn sub(self, other: Self) -> Self::Output {
        Vector {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}
¬†
impl<T> Mul<T> for Vector<T>
where
    T: Mul<Output = T> + Copy,
{
    type Output = Self;
¬†
    fn mul(self, scalar: T) -> Self::Output {
        Vector {
            x: self.x * scalar,
            y: self.y * scalar,
        }
    }
}
¬†
impl<T> Div<T> for Vector<T>
where
    T: Div<Output = T> + Copy,
{
    type Output = Self;
¬†
    fn div(self, scalar: T) -> Self::Output {
        Vector {
            x: self.x / scalar,
            y: self.y / scalar,
        }
    }
}
¬†
fn main() {
    use std::f64::consts::FRAC_PI_3;
¬†
    println!("{:?}", Vector::new(4, 5));
    println!("{:.4}", Vector::from_polar(3.0, FRAC_PI_3));
    println!("{}", Vector::new(2, 3) + Vector::new(4, 6));
    println!("{:.4}", Vector::new(5.6, 1.3) - Vector::new(4.2, 6.1));
    println!("{:.4}", Vector::new(3.0, 4.2) * 2.3);
    println!("{:.4}", Vector::new(3.0, 4.2) / 2.3);
    println!("{}", Vector::new(3, 4) / 2);
}
```

Output:

```rust
Vector { x: 4, y: 5 }
[1.5000, 2.5981]
[6, 9]
[1.4000, -4.8000]
[6.9000, 9.6600]
[1.3043, 1.8261]
[1, 2]

```

# Jaro distance<a id="sec-382"></a>

The Jaro distance is a measure of similarity between two strings.

The higher the Jaro distance for two strings is, the more similar the strings are.

The score is normalized such that ¬† 0 ¬† equates to no similarity and ¬† 1 ¬† is an exact match.

Definition

The Jaro distance ¬† {\displaystyle d<sub>j</sub>} ¬† of two given strings ¬† {\displaystyle s<sub>1</sub>} ¬† and ¬† {\displaystyle s<sub>2</sub>} ¬† is

{\displaystyle d<sub>j</sub>=\left\\{{\begin{array}{l l}0&{\text{if }}m=0\\\\{\frac {1}{3}}\left({\frac {m}{|s<sub>1</sub>|}}+{\frac {m}{|s<sub>2</sub>|}}+{\frac {m-t}{m}}\right)&{\text{otherwise}}\end{array}}\right.}

Where:

{\displaystyle m} ¬† is the number of matching characters; {\displaystyle t} ¬† is half the number of transpositions.

Two characters from ¬† {\displaystyle s<sub>1</sub>} ¬† and ¬† {\displaystyle s<sub>2</sub>} ¬† respectively, are considered matching only if they are the same and not farther than ¬† {\displaystyle \left&lfloor; {\frac {max(|s<sub>1</sub>|,|s<sub>2</sub>|)}{2}}\right&rfloor; -1} .

Each character of ¬† {\displaystyle s<sub>1</sub>} ¬† is compared with all its matching characters in ¬† {\displaystyle s<sub>2</sub>} .

The number of matching (but different sequence order) characters divided by 2 defines the number of transpositions.

Example

Given the strings ¬† {\displaystyle s<sub>1</sub>} ¬† DWAYNE ¬† and ¬† {\displaystyle s<sub>2</sub>} ¬† DUANE ¬† we find:

{\displaystyle m=4} {\displaystyle |s<sub>1</sub>|=6} {\displaystyle |s<sub>2</sub>|=5} {\displaystyle t=0}

We find a Jaro score of:

{\displaystyle d<sub>j</sub>={\frac {1}{3}}\left({\frac {4}{6}}+{\frac {4}{5}}+{\frac {4-0}{4}}\right)=0.822}

Task

Implement the Jaro-distance algorithm and show the distances for each of the following pairs:

("MARTHA", "MARHTA") ("DIXON", "DICKSONX") ("JELLYFISH", "SMELLYFISH")

See also

Jaro‚ÄìWinkler distance on Wikipedia.

Translation of: C++

```rust
use std::cmp;
¬†
pub fn jaro(s1: &str, s2: &str) -> f64 {
    let s1_len = s1.len();
    let s2_len = s2.len();
    if s1_len == 0 && s2_len == 0 { return 1.0; }
    let match_distance = cmp::max(s1_len, s2_len) / 2 - 1;
    let mut s1_matches = vec![false; s1_len];
    let mut s2_matches = vec![false; s2_len];
    let mut m: isize = 0;
    for i in 0..s1_len {
        let start = cmp::max(0, i as isize - match_distance as isize) as usize;
        let end = cmp::min(i + match_distance + 1, s2_len);
        for j in start..end {
            if¬†!s2_matches[j] && s1.as_bytes()[i] == s2.as_bytes()[j] {
                s1_matches[i] = true;
                s2_matches[j] = true;
                m += 1;
                break;
            }
        }
    }
    if m == 0 { return 0.0; }
    let mut t = 0.0;
    let mut k = 0;
    for i in 0..s1_len {
        if s1_matches[i] {
            while¬†!s2_matches[k] { k += 1; }
            if s1.as_bytes()[i]¬†!= s2.as_bytes()[k] { t += 0.5; }
            k += 1;
        }
    }
¬†
    let m = m as f64;
    (m / s1_len as f64 + m / s2_len as f64 + (m  - t) / m) / 3.0
}
¬†
fn main() {
    let pairs = [("MARTHA", "MARHTA"), ("DIXON", "DICKSONX"), ("JELLYFISH", "SMELLYFISH")];
    for p in pairs.iter() { println!("{}/{} = {}", p.0, p.1, jaro(p.0, p.1)); }
}
```

Output:

```rust
MARTHA/MARHTA = 0.9444444444444445
DIXON/DICKSONX = 0.7666666666666666
JELLYFISH/SMELLYFISH = 0.8962962962962964
```

# Bitmap/Write a PPM file<a id="sec-383"></a>

Using the data storage type defined on this page for raster images, write the image to a PPM file (binary P6 prefered). (Read the definition of PPM file on Wikipedia.)

```rust
use std::path::Path;
use std::io::Write;
use std::fs::File;
¬†
pub struct RGB {
    r: u8,
    g: u8,
    b: u8,
}
¬†
pub struct PPM {
    height: u32,
    width: u32,
    data: Vec<u8>,
}
¬†
impl PPM {
    pub fn new(height: u32, width: u32) -> PPM {
        let size = 3 * height * width;
        let buffer = vec![0; size as usize];
        PPM { height: height, width: width, data: buffer }
    }
¬†
    fn buffer_size(&self) -> u32 {
        3 * self.height * self.width
    }
¬†
    fn get_offset(&self, x: u32, y: u32) -> Option<usize> {
        let offset = (y * self.width * 3) + (x * 3);
        if offset < self.buffer_size() {
            Some(offset as usize)
        } else {
            None
        }
    }
¬†
    pub fn get_pixel(&self, x: u32, y: u32) -> Option<RGB> {
        match self.get_offset(x, y) {
            Some(offset) => {
                let r = self.data[offset];
                let g = self.data[offset + 1];
                let b = self.data[offset + 2];
                Some(RGB {r: r, g: g, b: b})
            },
            None => None
        }
    }
¬†
    pub fn set_pixel(&mut self, x: u32, y: u32, color: RGB) -> bool {
        match self.get_offset(x, y) {
            Some(offset) => {
                self.data[offset] = color.r;
                self.data[offset + 1] = color.g;
                self.data[offset + 2] = color.b;
                true
            },
            None => false
        }
    }
¬†
    pub fn write_file(&self, filename: &str) -> std::io::Result<()> {
        let path = Path::new(filename);
        let mut file = try!(File::create(&path));
        let header = format!("P6 {} {} 255\n", self.width, self.height);
        try!(file.write(header.as_bytes()));
        try!(file.write(&self.data));
        Ok(())
    }
}
```

# 2048<a id="sec-384"></a>

Task

Implement a 2D sliding block puzzle game where blocks with numbers are combined to add their values.

The rules are that on each turn the player must choose a direction (up, down, left or right) and all tiles move as far as possible in that direction, some more than others. Two adjacent tiles (in that direction only) with matching numbers combine into one bearing the sum of those numbers. A move is valid when at least one tile can be moved, if only by combination. A new tile with the value of 2 is spawned at the end of each turn at a randomly chosen empty square, if there is one. To win the player must create a tile with the number 2048. The player loses if no valid moves are possible.

The name comes from the popular open-source implementation of this game mechanic, 2048.

Requirements:

"Non-greedy" movement. The tiles that were created by combining other tiles should not be combined again during the same turn (move). That is to say that moving the tile row of

```
[2][2][2][2]

```

to the right should result in

```
......[4][4]

```

and not

```
.........[8]

```

"Move direction priority". If more than one variant of combining is possible, move direction shows one that will take effect. For example, moving the tile row of

```
...[2][2][2]

```

to the right should result in

```
......[2][4]

```

and not

```
......[4][2]

```

Adding a new tile on a blank space. Most of the time new "2" is to be added and occasionally (10% of the time) - "4" Check for valid moves. The player shouldn't be able to skip their turn by trying a move that doesn't change the board. Win condition. Lose condition.

Text mode[edit]

A simple implementation in rust. The user has to input an endline since i did not find a way to read a key press

Library: rand

```rust
¬†
use std::io::{self,BufRead};
extern crate rand;
¬†
enum Usermove {
    Up,
    Down,
    Left,
    Right,
}
¬†
fn print_game(field¬†:& [[u32;4];4] ){
    println!("{:?}",&field[0] );
    println!("{:?}",&field[1] );
    println!("{:?}",&field[2] );
    println!("{:?}",&field[3] );
}
¬†
fn get_usermove()-> Usermove {
    let umove: Usermove¬†;
    loop{
        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
¬†
        match input.chars().nth(0){
            Some('a') =>{umove = Usermove::Left¬†;break },
            Some('w') =>{umove = Usermove::Up  ¬†;break },
            Some('s') =>{umove = Usermove::Down¬†;break },
            Some('d') =>{umove = Usermove::Right;break },
            _   => {println!("input was {}: invalid character should be a,s,w or d ",input.chars().nth(0).unwrap());} ,
        }
    }
    umove
}
¬†
//this function inplements the user moves.
//for every element it looks if the element is zero
// if the element is zero it looks against the direction of the movement if any
//element is not zero then it will move it to the element its place then it will look for
//a matching element
//  if the element is not zero then it will look for a match if no match is found
// then it will look for the next element
¬†
fn do_game_step(step¬†: &Usermove, field:&mut [[u32;4];4]){
    match *step {
        Usermove::Left =>{
            for array in field{
                for  col in 0..4 {
                    for testcol in (col+1)..4 {
                        if array[testcol]¬†!= 0 {
                            if array[col] == 0 {
                                array[col] += array[testcol];
                                array[testcol] = 0;
                            }
                            else if array[col] == array[testcol] {
                                array[col] += array[testcol];
                                array[testcol] = 0;
                                break;
                            } else {
                                break
                            }
                        }
                    }
                }
            }
        } ,
        Usermove::Right=>{
            for array in field{
                for  col in (0..4).rev() {
                    for testcol in (0..col).rev() {
                        if array[testcol]¬†!= 0 {
                            if array[col] == 0 {
                                array[col] += array[testcol];
                                array[testcol] = 0;
                            }
                            else if array[col] == array[testcol] {
                                array[col] += array[testcol];
                                array[testcol] = 0;
                                break;
                            }else {
                                break;
                            }
                        }
                    }
                }
            }
        } ,
        Usermove::Down   =>{
            for col in 0..4 {
                for row in (0..4).rev() {
                    for testrow in (0..row).rev() {
                        if field[testrow][col]¬†!= 0 {
                            if field[row][col] == 0 {
                                field[row][col] += field[testrow][col];
                                field[testrow][col] = 0;
                            } else if field[row][col] == field[testrow][col] {
                                field[row][col] += field[testrow][col];
                                field[testrow][col] = 0;
                                break;
                            }else {
                                break;
                            }
¬†
                        }
                    }
                }
            }
        } ,
        Usermove::Up =>{
            for col in 0..4 {
                for row in 0..4{
                    for testrow in (row+1)..4 {
                        if field[testrow][col]¬†!= 0 {
                            if field[row][col] == 0 {
                                field[row][col] += field[testrow][col];
                                field[testrow][col] = 0;
                            } else if field[row][col] == field[testrow][col] {
                                field[row][col] += field[testrow][col];
                                field[testrow][col] = 0;
                                break;
                            }else {
                                break;
                            }
                        }
                    }
                }
            }
        },
    }
}
¬†
fn spawn( field: &mut  [[u32;4];4]){
    loop{
        let x = rand::random::<usize>();
        if field[x¬†% 4][(x/4)%4] == 0 {
            if x¬†% 10 == 0 {
                field[x¬†% 4][(x/4)%4]= 4;
            }else{
                field[x¬†% 4][(x/4)%4]= 2;
            }
            break;
        }
    }
}
¬†
¬†
fn main() {
    let mut field¬†: [[u32; 4];4] =  [[0;4];4];
    let mut test¬†: [[u32; 4];4]¬†;
    'gameloop:loop {
        //check if there is still an open space
        test=field.clone();
        spawn(&mut field);
        //if all possible moves do not yield a change then there is no valid move left
        //and it will be game over
        for i in [Usermove::Up,Usermove::Down,Usermove::Left,Usermove::Right].into_iter(){
            do_game_step(i, &mut test);
            if test¬†!= field{
                break;//found a valid move
            }
            match *i{
                Usermove::Right=> {
                    println!("No more valid move, you lose");
                    break 'gameloop;
                },
                _=>{},
            }
        }
        print_game(&field);
        println!("move the blocks");
¬†
        test=field.clone();
        while test==field {
            do_game_step(&get_usermove(), &mut field);
        }
¬†
        for row in field.iter(){
            if row.iter().any(|x| *x == 2048){
                print_game(&field );
                println!("You Won!!");
                break;
            }
        }
    }
}
¬†
```

# Doubly-linked list/Element definition<a id="sec-385"></a>

Task

Define the data structure for a doubly-linked list element.

The element should include a data member to hold its value and pointers to both the next element in the list and the previous element in the list.

The pointers should be mutable.

See also

Array Associative array: Creation, Iteration Collections Compound data type Doubly-linked list: Definition, Element definition, Element insertion, Traversal Linked list Queue: Definition, Usage Set Singly-linked list: Element definition, Element insertion, Traversal Stack

Simply using the standard library[edit]

```rust
use std::collections::LinkedList;
fn main() {
     // Doubly linked list containing 32-bit integers
     let list = LinkedList::<i32>::new();
}
```

The behind-the-scenes implementation[edit]

Doubly linked lists present a problem in Rust due to its ownership model. There cannot be two mutable references to the same object, so what are we to do? Below are the relevant lines (with added comments) from the std implementation (Documentation Source).

The standard library uses the (currently) unstable \`Shared<T>\` type which indicates that the ownership of its contained type has shared ownership. It is guaranteed not to be null, is variant over T (meaning that an &Shared<&'static T> may be used where a &Shared<&'a T> is expected, indicates to the compiler that it may own a T) and may be dereferenced to a mutable pointer (\*mut T). All of the above may be accomplished in standard stable Rust, except for the non-null guarantee which allows the compiler to make a few extra optimizations.

```rust
pub struct LinkedList<T> {
    head: Option<Shared<Node<T>>>,
    tail: Option<Shared<Node<T>>>,
    len: usize,
    marker: PhantomData<Box<Node<T>>>, // Indicates that we logically own a boxed (owned pointer) Node<T>>
}
¬†
struct Node<T> {
    next: Option<Shared<Node<T>>>,
    prev: Option<Shared<Node<T>>>,
    element: T,
}
```

# Egyptian division<a id="sec-386"></a>

Egyptian division is a method of dividing integers using addition and doubling that is similar to the algorithm of Ethiopian multiplication

Algorithm:

Given two numbers where the dividend is to be divided by the divisor:

Start the construction of a table of two columns: powers<sub>of</sub><sub>2</sub>, and doublings; by a first row of a 1 (i.e. 2<sup>0</sup>) in the first column and 1 times the divisor in the first row second column. Create the second row with columns of 2 (i.e 2<sup>1</sup>), and 2 \* divisor in order. Continue with successive i‚Äôth rows of 2<sup>i</sup> and 2<sup>i</sup> \* divisor. Stop adding rows, and keep only those rows, where 2<sup>i</sup> \* divisor is less than or equal to the dividend. We now assemble two separate sums that both start as zero, called here answer and accumulator Consider each row of the table, in the reverse order of its construction. If the current value of the accumulator added to the doublings cell would be less than or equal to the dividend then add it to the accumulator, as well as adding the powers<sub>of</sub><sub>2</sub> cell value to the answer. When the first row has been considered as above, then the integer division of dividend by divisor is given by answer. (And the remainder is given by the absolute value of accumulator - dividend).

Example: 580 / 34

Table creation:

powers<sub>of</sub><sub>2</sub> doublings 1 34 2 68 4 136 8 272 16 544

Initialization of sums:

powers<sub>of</sub><sub>2</sub> doublings answer accumulator 1 34 2 68 4 136 8 272 16 544 0 0

Considering table rows, bottom-up:

When a row is considered it is shown crossed out if it is not accumulated, or bold if the row causes summations.

powers<sub>of</sub><sub>2</sub> doublings answer accumulator 1 34 2 68 4 136 8 272 16 544 16 544

powers<sub>of</sub><sub>2</sub> doublings answer accumulator 1 34 2 68 4 136 8 272 16 544 16 544

powers<sub>of</sub><sub>2</sub> doublings answer accumulator 1 34 2 68 4 136 16 544 8 272 16 544

powers<sub>of</sub><sub>2</sub> doublings answer accumulator 1 34 2 68 16 544 4 136 8 272 16 544

powers<sub>of</sub><sub>2</sub> doublings answer accumulator 1 34 17 578 2 68 4 136 8 272 16 544

Answer

So 580 divided by 34 using the Egyptian method is 17 remainder (578 - 580) or 2.

Task

The task is to create a function that does Egyptian division. The function should closely follow the description above in using a list/array of powers of two, and another of doublings.

Functions should be clear interpretations of the algorithm. Use the function to divide 580 by 34 and show the answer here, on this page.

References

Egyptian Number System

```rust
fn egyptian_divide(dividend: u32, divisor: u32) -> (u32, u32) {
    let dividend = dividend as u64;
    let divisor = divisor as u64;
¬†
    let pows = (0..32).map(|p| 1 << p);
    let doublings = (0..32).map(|p| divisor << p);
¬†
    let (answer, sum) = doublings
        .zip(pows)
        .rev()
        .skip_while(|(i, _)| i > &dividend )
        .fold((0, 0), |(answer, sum), (double, power)| {
            if sum + double < dividend {
                (answer + power, sum + double)
            } else {
                (answer, sum)
            }
        });
¬†
    (answer as u32, (dividend - sum) as u32)
}
¬†
fn main() {
    let (div, rem) = egyptian_divide(580, 34);
    println!("580 divided by 34 is {} remainder {}", div, rem);
}
```

Output:

```rust
580 divided by 34 is 17 remainder 2
```

# Conjugate transpose<a id="sec-387"></a>

Suppose that a matrix {\displaystyle M} contains complex numbers. Then the conjugate transpose of {\displaystyle M} is a matrix {\displaystyle M<sup>H</sup>} containing the complex conjugates of the matrix transposition of {\displaystyle M} .

{\displaystyle (M<sup>H</sup>)<sub>ji</sub>={\overline {M<sub>ij</sub>}}}

This means that row {\displaystyle j} , column {\displaystyle i} of the conjugate transpose equals the complex conjugate of row {\displaystyle i} , column {\displaystyle j} of the original matrix.

In the next list, {\displaystyle M} must also be a square matrix.

A Hermitian matrix equals its own conjugate transpose: {\displaystyle M<sup>H</sup>=M} . A normal matrix is commutative in multiplication with its conjugate transpose: {\displaystyle M<sup>H</sup>M=MM<sup>H</sup>} . A unitary matrix has its inverse equal to its conjugate transpose: {\displaystyle M<sup>H</sup>=M<sup>-1</sup>} . This is true iff {\displaystyle M<sup>H</sup>M=I<sub>n</sub>} and iff {\displaystyle MM<sup>H</sup>=I<sub>n</sub>} , where {\displaystyle I<sub>n</sub>} is the identity matrix.

Task

Given some matrix of complex numbers, find its conjugate transpose.

Also determine if the matrix is a:

Hermitian matrix, normal matrix, or unitary matrix.

See also

MathWorld entry: conjugate transpose MathWorld entry: Hermitian matrix MathWorld entry: normal matrix MathWorld entry: unitary matrix

Uses external crate 'num', version 0.1.34

```rust
¬†
extern crate num; // crate for complex numbers
¬†
use num::complex::Complex;
use std::ops::Mul;
use std::fmt;
¬†
¬†
#[derive(Debug, PartialEq)]
struct Matrix<f32> {
    grid: [[Complex<f32>; 2]; 2], // used to represent matrix
}
¬†
¬†
impl Matrix<f32> { // implements a method call for calculating the conjugate transpose
    fn conjugate_transpose(&self) -> Matrix<f32> {
        Matrix {grid: [[self.grid[0][0].conj(), self.grid[1][0].conj()],
        [self.grid[0][1].conj(), self.grid[1][1].conj()]]}
    }
}
¬†
impl Mul for Matrix<f32> { // implements '*' (multiplication) for the matrix
    type Output = Matrix<f32>;
¬†
    fn mul(self, other: Matrix<f32>) -> Matrix<f32> {
        Matrix {grid: [[self.grid[0][0]*other.grid[0][0] + self.grid[0][1]*other.grid[1][0],
            self.grid[0][0]*other.grid[0][1] + self.grid[0][1]*other.grid[1][1]],
            [self.grid[1][0]*other.grid[0][0] + self.grid[1][1]*other.grid[1][0],
            self.grid[1][0]*other.grid[1][0] + self.grid[1][1]*other.grid[1][1]]]}
    }
}
¬†
impl Copy for Matrix<f32> {} // implemented to prevent 'moved value' errors in if statements below
impl Clone for Matrix<f32> {
    fn clone(&self) -> Matrix<f32> {
        *self
    }
}
¬†
impl fmt::Display for Matrix<f32> { // implemented to make output nicer
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})\n({}, {})", self.grid[0][0], self.grid[0][1], self.grid[1][0], self.grid[1][1])
    }
}
¬†
fn main() {
    let a = Matrix {grid: [[Complex::new(3.0, 0.0), Complex::new(2.0, 1.0)],
        [Complex::new(2.0, -1.0), Complex::new(1.0, 0.0)]]};
¬†
    let b = Matrix {grid: [[Complex::new(0.5, 0.5), Complex::new(0.5, -0.5)],
        [Complex::new(0.5, -0.5), Complex::new(0.5, 0.5)]]};
¬†
    test_type(a);
    test_type(b);
}
¬†
fn test_type(mat: Matrix<f32>) {
    let identity = Matrix {grid: [[Complex::new(1.0, 0.0), Complex::new(0.0, 0.0)],
        [Complex::new(0.0, 0.0), Complex::new(1.0, 0.0)]]};
    let mat_conj = mat.conjugate_transpose();
¬†
    println!("Matrix: \n{}\nConjugate transpose: \n{}", mat, mat_conj);
¬†
    if mat == mat_conj {
        println!("Hermitian?: TRUE");
    } else {
        println!("Hermitian?: FALSE");
    }
¬†
    if mat*mat_conj == mat_conj*mat {
        println!("Normal?: TRUE");
    } else {
        println!("Normal?: FALSE");
    }
¬†
    if mat*mat_conj == identity {
        println!("Unitary?: TRUE");
    } else {
        println!("Unitary?: FALSE");
    }
}
```

Output:

```rust
Matrix:
(3+0i, 2+1i)
(2-1i, 1+0i)
Conjugate transpose:
(3+0i, 2+1i)
(2-1i, 1+0i)
Hermitian?: TRUE
Normal?: TRUE
Unitary?: FALSE
Matrix:
(0.5+0.5i, 0.5-0.5i)
(0.5-0.5i, 0.5+0.5i)
Conjugate transpose:
(0.5-0.5i, 0.5+0.5i)
(0.5+0.5i, 0.5-0.5i)
Hermitian?: FALSE
Normal?: TRUE
Unitary?: TRUE

```

# Voronoi diagram<a id="sec-388"></a>

A Voronoi diagram is a diagram consisting of a number of sites. Each Voronoi site s also has a Voronoi cell consisting of all points closest to s.

The task is to demonstrate how to generate and display a Voroni diagram. See algo K-means++ clustering.

This implementation uses SDL to display the diagram. The actual implementation of the Voronoi diagram is very fast because it's not pixel based, it's vector based, using Fortune's Linesweep algorithm. It can be found in the crate voronoi.

The entire code, including the Crate.toml and a precompiled binary for Windows x86<sub>64</sub>, can be found at <https://github.com/ctrlcctrlv/interactive-voronoi/>

```rust
extern crate piston;
extern crate opengl_graphics;
extern crate graphics;
extern crate touch_visualizer;
¬†
#[cfg(feature = "include_sdl2")]
extern crate sdl2_window;
¬†
extern crate getopts;
extern crate voronoi;
extern crate rand;
¬†
use touch_visualizer::TouchVisualizer;
use opengl_graphics::{ GlGraphics, OpenGL };
use graphics::{ Context, Graphics };
use piston::window::{ Window, WindowSettings };
use piston::input::*;
use piston::event_loop::*;
#[cfg(feature = "include_sdl2")]
use sdl2_window::Sdl2Window as AppWindow;
use voronoi::{voronoi, Point, make_polygons};
use rand::Rng;
¬†
static DEFAULT_WINDOW_HEIGHT: u32 = 600;
static DEFAULT_WINDOW_WIDTH:  u32 = 600;
¬†
struct Settings {
    lines_only: bool,
    random_count: usize
}
¬†
fn main() {
    let args: Vec<String> = std::env::args().collect();
    let mut opts = getopts::Options::new();
    opts.optflag("l", "lines_only", "Don't color polygons, just outline them");
    opts.optopt("r", "random_count", "On keypress \"R\", put this many random points on-screen", "RANDOMCOUNT");
    let matches = opts.parse(&args[1..]).expect("Failed to parse args");
¬†
    let settings = Settings{
        lines_only: matches.opt_present("l"),
        random_count: match matches.opt_str("r") {
            None => { 50 },
            Some(s) => { s.parse().expect("Random count of bad format") }
        }
    };
¬†
    event_loop(&settings);
¬†
}
¬†
fn random_point() -> [f64; 2] {
    [rand::thread_rng().gen_range(0., DEFAULT_WINDOW_HEIGHT as f64), rand::thread_rng().gen_range(0., DEFAULT_WINDOW_WIDTH as f64)]
}
¬†
fn random_color() -> [f32; 4] {
    [rand::random::<f32>(), rand::random::<f32>(), rand::random::<f32>(), 1.0]
}
¬†
fn random_voronoi(dots: &mut Vec<[f64;2]>, colors: &mut Vec<[f32;4]>, num: usize) {
    dots.clear();
    colors.clear();
¬†
    for _ in 0..num {
        dots.push(random_point());
        colors.push(random_color());
    }
}
¬†
fn event_loop(settings: &Settings) {
    let opengl = OpenGL::V3_2;
    let mut window: AppWindow = WindowSettings::new("Interactive Voronoi", [DEFAULT_WINDOW_HEIGHT, DEFAULT_WINDOW_WIDTH])
        .exit_on_esc(true).opengl(opengl).build().unwrap();
¬†
    let ref mut gl = GlGraphics::new(opengl);
    let mut touch_visualizer = TouchVisualizer::new();
    let mut events = Events::new(EventSettings::new().lazy(true));
    let mut dots = Vec::new();
    let mut colors = Vec::new();
¬†
    let mut mx = 0.0;
    let mut my = 0.0;
¬†
    while let Some(e) = events.next(&mut window) {
        touch_visualizer.event(window.size(), &e);
        if let Some(button) = e.release_args() {
            match button {
                Button::Keyboard(key) => {
                    if key == piston::input::keyboard::Key::N { dots.clear(); colors.clear(); }
                    if key == piston::input::keyboard::Key::R { random_voronoi(&mut dots, &mut colors, settings.random_count); }
                }
                Button::Mouse(_) => {
                    dots.push([mx, my]);
                    colors.push(random_color());
                },
                _ => ()
            }
        };
        e.mouse_cursor(|x, y| {
            mx = x;
            my = y;
        });
        if let Some(args) = e.render_args() {
            gl.draw(args.viewport(), |c, g| {
                graphics::clear([1.0; 4], g);
                let mut vor_pts = Vec::new();
                for d in &dots {
                    vor_pts.push(Point::new(d[0], d[1]));
                }
                if vor_pts.len() > 0 {
                    let vor_diagram = voronoi(vor_pts, DEFAULT_WINDOW_WIDTH as f64);
                    let vor_polys = make_polygons(&vor_diagram);
                    for (i, poly) in vor_polys.iter().enumerate() {
                        if settings.lines_only {
                            draw_lines_in_polygon(poly, &c, g);
                        } else {
                            draw_polygon(poly, &c, g, colors[i]);
                        }
                    }
                }
                for d in &dots {
                    draw_ellipse(&d, &c, g);
                }
            });
        }
    } 
¬†
}
¬†
fn draw_lines_in_polygon<G: Graphics>(
    poly: &Vec<Point>,
    c: &Context,
    g: &mut G,
)
{
    let color = [0.0, 0.0, 1.0, 1.0];
¬†
    for i in 0..poly.len()-1 {
        graphics::line(
            color,
            2.0,
            [poly[i].x.into(), poly[i].y.into(), poly[i+1].x.into(), poly[i+1].y.into()],
            c.transform,
            g
        )
    }
}
¬†
fn draw_polygon<G: Graphics>(
    poly: &Vec<Point>,
    c: &Context,
    g: &mut G,
    color: [f32; 4]
) {
    let mut polygon_points: Vec<[f64; 2]> = Vec::new();
¬†
    for p in poly {
        polygon_points.push([p.x.into(), p.y.into()]);
    }
¬†
    graphics::polygon(
        color,
        polygon_points.as_slice(),
        c.transform,
        g
    )
}
¬†
fn draw_ellipse<G: Graphics>(
    cursor: &[f64; 2],
    c: &Context,
    g: &mut G,
) {
    let color = [0.0, 0.0, 0.0, 1.0];
    graphics::ellipse(
        color,
        graphics::ellipse::circle(cursor[0], cursor[1], 4.0),
        c.transform,
        g
    );
}
¬†
```

# Barnsley fern<a id="sec-389"></a>

A Barnsley fern is a fractal named after British mathematician Michael Barnsley and can be created using an iterated function system (IFS).

Task

Create this fractal fern, using the following transformations:

∆í1 ¬† (chosen 1% of the time)

```
xn + 1 = 0
yn + 1 = 0.16 yn

```

∆í2 ¬† (chosen 85% of the time)

```
xn + 1 = 0.85 xn + 0.04 yn
yn + 1 = ‚àí0.04 xn + 0.85 yn + 1.6

```

∆í3 ¬† (chosen 7% of the time)

```
xn + 1 = 0.2 xn ‚àí 0.26 yn
yn + 1 = 0.23 xn + 0.22 yn + 1.6

```

∆í4 ¬† (chosen 7% of the time)

```
xn + 1 = ‚àí0.15 xn + 0.28 yn
yn + 1 = 0.26 xn + 0.24 yn + 0.44.

```

Starting position: x = 0, y = 0

Translation of: Java

Library: rand

```rust
extern crate rand;
extern crate raster;
¬†
use rand::Rng;
¬†
fn main() {
    let max_iterations = 200_000u32;
    let height = 640i32;
    let width = 640i32;
¬†
    let mut rng = rand::thread_rng();
    let mut image = raster::Image::blank(width, height);
    raster::editor::fill(&mut image, raster::Color::white()).unwrap();
¬†
    let mut x = 0.;
    let mut y = 0.;
    for _ in 0..max_iterations {
        let r = rng.gen::<f32>();
        let cx: f64;
        let cy: f64;
¬†
        if r <= 0.01 {
            cx = 0f64;
            cy = 0.16 * y as f64;
        } else if r <= 0.08 {
            cx = 0.2 * x as f64 - 0.26 * y as f64;
            cy = 0.23 * x as f64 + 0.22 * y as f64 + 1.6;
        } else if r <= 0.15 {
            cx = -0.15 * x as f64 + 0.28 * y as f64;
            cy = 0.26 * x as f64 + 0.26 * y as f64 + 0.44;
        } else {
            cx = 0.85 * x as f64 + 0.04 * y as f64;
            cy = -0.04 * x as f64 + 0.85 * y as f64 + 1.6;
        }
        x = cx;
        y = cy;
¬†
        let _ = image.set_pixel(
            ((width as f64) / 2. + x * (width as f64) / 11.).round() as i32,
            ((height as f64) - y * (height as f64) / 11.).round() as i32,
            raster::Color::rgb(50, 205, 50));
    }
¬†
    raster::save(&image, "fractal.png").unwrap();
}
```

# Doubly-linked list/Element insertion<a id="sec-390"></a>

Doubly-Linked List (element)

This is much like inserting into a Singly-Linked List, but with added assignments so that the backwards-pointing links remain correct.

See also

Array Associative array: Creation, Iteration Collections Compound data type Doubly-linked list: Definition, Element definition, Element insertion, Traversal Linked list Queue: Definition, Usage Set Singly-linked list: Element definition, Element insertion, Traversal Stack

Simply using the standard library[edit]

```rust
use std::collections::LinkedList;
fn main() {
    let mut list = LinkedList::new();
    list.push_front(8);
}
```

The behind-the-scenes implementation[edit]

This expands upon the implementation defined in Doubly-linked list/Element definition#The<sub>behind</sub>-the-scenes<sub>implementation</sub> and consists of the relevant lines from the LinkedList implementation in the Rust standard library.

```rust
impl<T> Node<T> {
    fn new(v: T) -> Node<T> {
        Node {value: v, next: None, prev: Rawlink::none()}
    }
}
¬†
impl<T> Rawlink<T> {
    fn none() -> Self {
        Rawlink {p: ptr::null_mut()}
    }
¬†
    fn some(n: &mut T) -> Rawlink<T> {
        Rawlink{p: n}
    }
}
¬†
impl<'a, T> From<&'a mut Link<T>> for Rawlink<Node<T>> {
    fn from(node: &'a mut Link<T>) -> Self {
        match node.as_mut() {
            None => Rawlink::none(),
            Some(ptr) => Rawlink::some(ptr)
        }
    }
}
¬†
¬†
fn link_no_prev<T>(mut next: Box<Node<T>>) -> Link<T> {
    next.prev = Rawlink::none();
    Some(next)
}
¬†
impl<T> LinkedList<T> {
    #[inline]
    fn push_front_node(&mut self, mut new_head: Box<Node<T>>) {
        match self.list_head {
            None => {
                self.list_head = link_no_prev(new_head);
                self.list_tail = Rawlink::from(&mut self.list_head);
            }
            Some(ref mut head) => {
                new_head.prev = Rawlink::none();
                head.prev = Rawlink::some(&mut *new_head);
                mem::swap(head, &mut new_head);
                head.next = Some(new_head);
            }
        }
        self.length += 1;
    }
    pub fn push_front(&mut self, elt: T) {
        self.push_front_node(Box::new(Node::new(elt)));
    }
}
```

# Echo server<a id="sec-391"></a>

Create a network service that sits on TCP port 12321, which accepts connections on that port, and which echoes complete lines (using a carriage-return/line-feed sequence as line separator) back to clients. No error handling is required. For the purposes of testing, it is only necessary to support connections from localhost (127.0.0.1 or perhaps ::1). Logging of connection information to standard output is recommended.

The implementation must be able to handle simultaneous connections from multiple clients. A multi-threaded or multi-process solution may be used. Each connection must be able to echo more than a single line.

The implementation must not stop responding to other clients if one client sends a partial line or stops reading responses.

```rust
¬†
use std::net::{TcpListener, TcpStream};
use std::io::{BufReader, BufRead, Write};
use std::thread;
¬†
fn main() {
    let listener = TcpListener::bind("127.0.0.1:12321").unwrap();
    println!("server is running on 127.0.0.1:12321 ...");
¬†
    for stream in listener.incoming() {
        let stream = stream.unwrap();
        thread::spawn(move || handle_client(stream));
    }
}
¬†
fn handle_client(stream: TcpStream) {
    let mut stream = BufReader::new(stream);
    loop {
        let mut buf = String::new();
        if stream.read_line(&mut buf).is_err() {
            break;
        }
        stream
            .get_ref()
            .write(buf.as_bytes())
            .unwrap();
    }
}
¬†
```

# Word count<a id="sec-392"></a>

Task

Given a text file and an integer n, print the n most common words in the file (and the number of their occurrences) in decreasing frequency.

For the purposes of this task:

A word is a sequence of one or more contiguous letters You are free to define what a letter is. Underscores, accented letters, apostrophes, and other special characters can be handled at the example writer's discretion. For example, you may treat a compound word like "well-dressed" as either one word or two. The word "it's" could also be one or two words as you see fit. You may also choose not to support non US-ASCII characters. Feel free to explicitly state the thoughts behind the program decisions. Assume words will not span multiple lines. Do not worry about normalization of word spelling differences. Treat "color" and "colour" as two distinct words. Uppercase letters are considered equivalent to their lowercase counterparts Words of equal frequency can be listed in any order

Show example output using Les Mis√©rables from Project Gutenberg as the text file input and display the top 10 most used words.

History

This task was originally taken from programming pearls from Communications of the ACM June 1986 Volume 29 Number 6 where this problem is solved by Donald Knuth using literate programming and then critiqued by Doug McIlroy, demonstrating solving the problem in a 6 line Unix shell script (provided as an example below).

References

McIlroy's program

```rust
use std::cmp::Reverse;
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader};
¬†
extern crate regex;
use regex::Regex;
¬†
fn word_count(file: File, n: usize) {
    let word_regex = Regex::new("(?i)[a-z']+").unwrap();
¬†
    let mut words = HashMap::new();
    for line in BufReader::new(file).lines() {
        word_regex
            .find_iter(&line.expect("Read error"))
            .map(|m| m.as_str())
            .for_each(|word| {
                *words.entry(word.to_lowercase()).or_insert(0) += 1;
            });
    }
¬†
    let mut words: Vec<_> = words.iter().collect();
    words.sort_unstable_by_key(|&(word, count)| (Reverse(count), word));
¬†
    for (word, count) in words.iter().take(n) {
        println!("{:8} {:>8}", word, count);
    }
}
¬†
fn main() {
    word_count(File::open("135-0.txt").expect("File open error"), 10)
}
```

Output:

```rust
the         41083
of          19948
and         14941
a           14604
to          13951
in          11212
he           9604
was          8621
that         7824
it           6534

```

# Sutherland-Hodgman polygon clipping<a id="sec-393"></a>

The ¬† Sutherland-Hodgman clipping algorithm ¬† finds the polygon that is the intersection between an arbitrary polygon (the ‚Äúsubject polygon‚Äù) and a convex polygon (the ‚Äúclip polygon‚Äù).

It is used in computer graphics (especially 2D graphics) to reduce the complexity of a scene being displayed by eliminating parts of a polygon that do not need to be displayed.

Task

Take the closed polygon defined by the points:

{\displaystyle [(50,150),(200,50),(350,150),(350,300),(250,300),(200,250),(150,350),(100,250),(100,200)]}

and clip it by the rectangle defined by the points:

{\displaystyle [(100,100),(300,100),(300,300),(100,300)]}

Print the sequence of points that define the resulting clipped polygon.

Extra credit

Display all three polygons on a graphical surface, using a different color for each polygon and filling the resulting polygon.

(When displaying you may use either a north-west or a south-west origin, whichever is more convenient for your display mechanism.)

Translation of: Ruby

```rust
#[derive(Debug, Clone)]
struct Point {
    x: f64,
    y: f64,
}
¬†
#[derive(Debug, Clone)]
struct Polygon(Vec<Point>);
¬†
fn is_inside(p: &Point, cp1: &Point, cp2: &Point) -> bool {
    (cp2.x - cp1.x) * (p.y - cp1.y) > (cp2.y - cp1.y) * (p.x - cp1.x)
}
¬†
fn compute_intersection(cp1: &Point, cp2: &Point, s: &Point, e: &Point) -> Point {
    let dc = Point {
        x: cp1.x - cp2.x,
        y: cp1.y - cp2.y,
    };
    let dp = Point {
        x: s.x - e.x,
        y: s.y - e.y,
    };
    let n1 = cp1.x * cp2.y - cp1.y * cp2.x;
    let n2 = s.x * e.y - s.y * e.x;
    let n3 = 1.0 / (dc.x * dp.y - dc.y * dp.x);
    Point {
        x: (n1 * dp.x - n2 * dc.x) * n3,
        y: (n1 * dp.y - n2 * dc.y) * n3,
    }
}
¬†
fn sutherland_hodgman_clip(subject_polygon: &Polygon, clip_polygon: &Polygon) -> Polygon {
    let mut result_ring = subject_polygon.0.clone();
    let mut cp1 = clip_polygon.0.last().unwrap();
    for cp2 in &clip_polygon.0 {
        let input = result_ring;
        let mut s = input.last().unwrap();
        result_ring = vec![];
        for e in &input {
            if is_inside(e, cp1, cp2) {
                if¬†!is_inside(s, cp1, cp2) {
                    result_ring.push(compute_intersection(cp1, cp2, s, e));
                }
                result_ring.push(e.clone());
            } else if is_inside(s, cp1, cp2) {
                result_ring.push(compute_intersection(cp1, cp2, s, e));
            }
            s = e;
        }
        cp1 = cp2;
    }
    Polygon(result_ring)
}
¬†
fn main() {
    let _p = |x: f64, y: f64| Point { x, y };
    let subject_polygon = Polygon(vec![
        _p(50.0, 150.0), _p(200.0, 50.0), _p(350.0, 150.0), _p(350.0, 300.0), _p(250.0, 300.0),
        _p(200.0, 250.0), _p(150.0, 350.0), _p(100.0, 250.0), _p(100.0, 200.0),
    ]);
    let clip_polygon = Polygon(vec![
        _p(100.0, 100.0),_p(300.0, 100.0),_p(300.0, 300.0),_p(100.0, 300.0),
    ]);
    let result = sutherland_hodgman_clip(&subject_polygon, &clip_polygon);
    println!("{:?}", result);
}
```

Output:

```rust
Polygon([
    Point { x: 100, y: 116.66666666666667 }, Point { x: 125.00000000000001, y: 100 }, Point { x: 275, y: 100 },
    Point { x: 300, y: 116.66666666666667 }, Point { x: 300, y: 299.99999999999994 }, Point { x: 250, y: 300 },
    Point { x: 200, y: 250 }, Point { x: 175, y: 300 }, Point { x: 125, y: 300 }, Point { x: 100, y: 250 }])

```

# MD4<a id="sec-394"></a>

Find the MD4 message digest of a string of octets. Use the ASCII encoded string ‚ÄúRosetta Code‚Äù (without quotes). You may either call an MD4 library, or implement MD4 in your language.

MD4 is an obsolete hash function that computes a 128-bit message digest that sometimes appears in obsolete protocols.

RFC 1320 specifies the MD4 algorithm. RFC 6150 declares that MD4 is obsolete.

```rust
// MD4, based on RFC 1186 and RFC 1320.
//
// https://www.ietf.org/rfc/rfc1186.txt
// https://tools.ietf.org/html/rfc1320
//
¬†
use std::fmt::Write;
use std::mem;
¬†
// Let not(X) denote the bit-wise complement of X.
// Let X v Y denote the bit-wise OR of X and Y.
// Let X xor Y denote the bit-wise XOR of X and Y.
// Let XY denote the bit-wise AND of X and Y.
¬†
// f(X,Y,Z)  =  XY v not(X)Z
fn f(x: u32, y: u32, z: u32) -> u32 {
    (x & y) | (!x & z)
}
¬†
// g(X,Y,Z)  =  XY v XZ v YZ
fn g(x: u32, y: u32, z: u32) -> u32 {
    (x & y) | (x & z) | (y & z)
}
¬†
// h(X,Y,Z)  =  X xor Y xor Z
fn h(x: u32, y: u32, z: u32) -> u32 {
    x ^ y ^ z
}
¬†
// Round 1 macro
// Let [A B C D i s] denote the operation
//   A = (A + f(B,C,D) + X[i]) <<< s
macro_rules! md4round1 {
    ( $a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {
        {
            // Rust defaults to non-overflowing arithmetic, so we need to specify wrapping add.
            $a = ($a.wrapping_add( f($b, $c, $d) ).wrapping_add( $x[$i] ) ).rotate_left($s);
        }
    };
}
¬†
// Round 2 macro
// Let [A B C D i s] denote the operation
//   A = (A + g(B,C,D) + X[i] + 5A827999) <<< s .
macro_rules! md4round2 {
    ( $a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {
        {
            $a = ($a.wrapping_add( g($b, $c, $d)).wrapping_add($x[$i]).wrapping_add(0x5a827999_u32)).rotate_left($s);
        }
    };
}
¬†
// Round 3 macro
// Let [A B C D i s] denote the operation
//   A = (A + h(B,C,D) + X[i] + 6ED9EBA1) <<< s .
macro_rules! md4round3 {
    ( $a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {
        {
            $a = ($a.wrapping_add(h($b, $c, $d)).wrapping_add($x[$i]).wrapping_add(0x6ed9eba1_u32)).rotate_left($s);
        }
    };
}
¬†
fn convert_byte_vec_to_u32(mut bytes: Vec<u8>) -> Vec<u32> {
¬†
    bytes.shrink_to_fit();
    let num_bytes = bytes.len();
    let num_words = num_bytes / 4;
    unsafe {
        let words = Vec::from_raw_parts(bytes.as_mut_ptr() as *mut u32, num_words, num_words);
        mem::forget(bytes);
        words
    }
}
¬†
// Returns a 128-bit MD4 hash as an array of four 32-bit words.
// Based on RFC 1186 from https://www.ietf.org/rfc/rfc1186.txt
fn md4<T: Into<Vec<u8>>>(input: T) -> [u32; 4] {
¬†
    let mut bytes = input.into().to_vec();
    let initial_bit_len = (bytes.len() << 3) as u64;
¬†
    // Step 1. Append padding bits
    // Append one '1' bit, then append 0 ‚â§ k < 512 bits '0', such that the resulting message
    // length in bis is congruent to 448 (mod 512).
    // Since our message is in bytes, we use one byte with a set high-order bit (0x80) plus
    // a variable number of zero bytes.
¬†
    // Append zeros
    // Number of padding bytes needed is 448 bits (56 bytes) modulo 512 bits (64 bytes)
    bytes.push(0x80_u8);
    while (bytes.len()¬†% 64)¬†!= 56 {
        bytes.push(0_u8);
    }
¬†
    // Everything after this operates on 32-bit words, so reinterpret the buffer.
    let mut w = convert_byte_vec_to_u32(bytes);
¬†
    // Step 2. Append length
    // A 64-bit representation of b (the length of the message before the padding bits were added)
    // is appended to the result of the previous step, low-order bytes first.
    w.push(initial_bit_len as u32); // Push low-order bytes first
    w.push((initial_bit_len >> 32) as u32);
¬†
    // Step 3. Initialize MD buffer
    let mut a = 0x67452301_u32;
    let mut b = 0xefcdab89_u32;
    let mut c = 0x98badcfe_u32;
    let mut d = 0x10325476_u32;
¬†
    // Step 4. Process message in 16-word blocks
    let n = w.len();
    for i in 0..n / 16 {
¬†
        // Select the next 512-bit (16-word) block to process.
        let x = &w[i * 16..i * 16 + 16];
¬†
        let aa = a;
        let bb = b;
        let cc = c;
        let dd = d;
¬†
        // [Round 1]
        md4round1!(a, b, c, d, 0, 3, x);  // [A B C D 0 3]
        md4round1!(d, a, b, c, 1, 7, x);  // [D A B C 1 7]
        md4round1!(c, d, a, b, 2, 11, x); // [C D A B 2 11]
        md4round1!(b, c, d, a, 3, 19, x); // [B C D A 3 19]
        md4round1!(a, b, c, d, 4, 3, x);  // [A B C D 4 3]
        md4round1!(d, a, b, c, 5, 7, x);  // [D A B C 5 7]
        md4round1!(c, d, a, b, 6, 11, x); // [C D A B 6 11]
        md4round1!(b, c, d, a, 7, 19, x); // [B C D A 7 19]
        md4round1!(a, b, c, d, 8, 3, x);  // [A B C D 8 3]
        md4round1!(d, a, b, c, 9, 7, x);  // [D A B C 9 7]
        md4round1!(c, d, a, b, 10, 11, x);// [C D A B 10 11]
        md4round1!(b, c, d, a, 11, 19, x);// [B C D A 11 19]
        md4round1!(a, b, c, d, 12, 3, x); // [A B C D 12 3]
        md4round1!(d, a, b, c, 13, 7, x); // [D A B C 13 7]
        md4round1!(c, d, a, b, 14, 11, x);// [C D A B 14 11]
        md4round1!(b, c, d, a, 15, 19, x);// [B C D A 15 19]
¬†
        // [Round 2]
        md4round2!(a, b, c, d, 0, 3, x);  //[A B C D 0  3]
        md4round2!(d, a, b, c, 4, 5, x);  //[D A B C 4  5]
        md4round2!(c, d, a, b, 8, 9, x);  //[C D A B 8  9]
        md4round2!(b, c, d, a, 12, 13, x);//[B C D A 12 13]
        md4round2!(a, b, c, d, 1, 3, x);  //[A B C D 1  3]
        md4round2!(d, a, b, c, 5, 5, x);  //[D A B C 5  5]
        md4round2!(c, d, a, b, 9, 9, x);  //[C D A B 9  9]
        md4round2!(b, c, d, a, 13, 13, x);//[B C D A 13 13]
        md4round2!(a, b, c, d, 2, 3, x);  //[A B C D 2  3]
        md4round2!(d, a, b, c, 6, 5, x);  //[D A B C 6  5]
        md4round2!(c, d, a, b, 10, 9, x); //[C D A B 10 9]
        md4round2!(b, c, d, a, 14, 13, x);//[B C D A 14 13]
        md4round2!(a, b, c, d, 3, 3, x);  //[A B C D 3  3]
        md4round2!(d, a, b, c, 7, 5, x);  //[D A B C 7  5]
        md4round2!(c, d, a, b, 11, 9, x); //[C D A B 11 9]
        md4round2!(b, c, d, a, 15, 13, x);//[B C D A 15 13]
¬†
        // [Round 3]
        md4round3!(a, b, c, d, 0, 3, x);  //[A B C D 0  3]
        md4round3!(d, a, b, c, 8, 9, x);  //[D A B C 8  9]
        md4round3!(c, d, a, b, 4, 11, x); //[C D A B 4  11]
        md4round3!(b, c, d, a, 12, 15, x);//[B C D A 12 15]
        md4round3!(a, b, c, d, 2, 3, x);  //[A B C D 2  3]
        md4round3!(d, a, b, c, 10, 9, x); //[D A B C 10 9]
        md4round3!(c, d, a, b, 6, 11, x); //[C D A B 6  11]
        md4round3!(b, c, d, a, 14, 15, x);//[B C D A 14 15]
        md4round3!(a, b, c, d, 1, 3, x);  //[A B C D 1  3]
        md4round3!(d, a, b, c, 9, 9, x);  //[D A B C 9  9]
        md4round3!(c, d, a, b, 5, 11, x); //[C D A B 5  11]
        md4round3!(b, c, d, a, 13, 15, x);//[B C D A 13 15]
        md4round3!(a, b, c, d, 3, 3, x);  //[A B C D 3  3]
        md4round3!(d, a, b, c, 11, 9, x); //[D A B C 11 9]
        md4round3!(c, d, a, b, 7, 11, x); //[C D A B 7  11]
        md4round3!(b, c, d, a, 15, 15, x);//[B C D A 15 15]
¬†
        a = a.wrapping_add(aa);
        b = b.wrapping_add(bb);
        c = c.wrapping_add(cc);
        d = d.wrapping_add(dd);
    }
¬†
    // Step 5. Output
    // The message digest produced as output is A, B, C, D. That is, we begin with the low-order
    // byte of A, and end with the high-order byte of D.
    [u32::from_be(a), u32::from_be(b), u32::from_be(c), u32::from_be(d)]
}
¬†
fn digest_to_str(digest: &[u32]) -> String {
    let mut s = String::new();
    for &word in digest {
        write!(&mut s, "{:08x}", word).unwrap();
    }
    s
}
¬†
fn main() {
    let val = "Rosetta Code";
    println!("md4(\"{}\") = {}", val, digest_to_str(&md4(val)));
}
```

Output:

```rust
md4("Rosetta Code") = a52bcfc6a0d0d300cdc5ddbfbefe478b

```

# Archimedean spiral<a id="sec-395"></a>

The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.

An Archimedean spiral can be described by the equation:

{\displaystyle \\,r=a+b&theta; }

with real numbers a and b.

Task

Draw an Archimedean spiral.

```rust
#[macro_use(px)]
extern crate bmp;
¬†
use bmp::{Image, Pixel};
use std::f64;
¬†
fn main() {
    let width = 600u32;
    let half_width = (width / 2) as i32;
    let mut img = Image::new(width, width);
    let draw_color = px!(255, 128, 128);
¬†
    // Constants defining the spiral size.
    let a = 1.0_f64;
    let b = 9.0_f64;
¬†
    // max_angle = number of spirals * 2pi.
    let max_angle = 5.0_f64 * 2.0_f64 * f64::consts::PI;
¬†
    let mut theta = 0.0_f64;
    while theta < max_angle {
        theta = theta + 0.002_f64;
¬†
        let r = a + b * theta;
        let x = (r * theta.cos()) as i32 + half_width;
        let y = (r * theta.sin()) as i32 + half_width;
        img.set_pixel(x as u32, y as u32, draw_color);
    }
¬†
    // Save the image
    let _ = img.save("archimedean_spiral.bmp").unwrap_or_else(|e| panic!("Failed to save: {}", e));
}
```

# Julia set<a id="sec-396"></a>

Task

Generate and draw a Julia set.

Related tasks

¬† Mandelbrot Set

```rust
extern crate image;
¬†
use image::{ImageBuffer, Pixel, Rgb};
¬†
fn main() {
    // 4¬†: 3 ratio is nice
    let width = 8000;
    let height = 6000;
¬†
    let mut img = ImageBuffer::new(width as u32, height as u32);
¬†
    // constants to tweak for appearance
    let cx = -0.9;
    let cy = 0.27015;
    let iterations = 110;
¬†
    for x in 0..width {
        for y in 0..height {
            let inner_height = height as f32;
            let inner_width = width as f32;
            let inner_y = y as f32;
            let inner_x = x as f32;
¬†
            let mut zx = 3.0 * (inner_x - 0.5 * inner_width) / (inner_width);
            let mut zy = 2.0 * (inner_y - 0.5 * inner_height) / (inner_height);
¬†
            let mut i = iterations;
¬†
            while zx * zx + zy * zy < 4.0 && i > 1 {
                let tmp = zx * zx - zy * zy + cx;
                zy = 2.0 * zx * zy + cy;
                zx = tmp;
                i -= 1;
            }
¬†
            // guesswork to make the rgb color values look okay
            let r = (i << 3) as u8;
            let g = (i << 5) as u8;
            let b = (i << 4) as u8;
            let pixel = Rgb::from_channels(r, g, b, 0);
            img.put_pixel(x as u32, y as u32, pixel);
        }
    }
¬†
    let _ = img.save("output.png");
¬†
}
```

# Bitcoin/address validation<a id="sec-397"></a>

Task

Write a program that takes a bitcoin address as argument, and checks whether or not this address is valid.

A bitcoin address uses a base58 encoding, which uses an alphabet of the characters 0 .. 9, A ..Z, a .. z, but without the four characters:

¬† 0 ¬† zero ¬† O ¬† uppercase oh ¬† I ¬† uppercase eye ¬† l ¬† lowercase ell

With this encoding, a bitcoin address encodes 25 bytes:

the first byte is the version number, which will be zero for this task¬†; the next twenty bytes are a RIPEMD-160 digest, but you don't have to know that for this task: you can consider them a pure arbitrary data¬†; the last four bytes are a checksum check. They are the first four bytes of a double SHA-256 digest of the previous 21 bytes.

To check the bitcoin address, you must read the first twenty-one bytes, compute the checksum, and check that it corresponds to the last four bytes.

The program can either return a boolean value or throw an exception when not valid.

You can use a digest library for SHA-256.

Example of a bitcoin address

1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i

It doesn't belong to anyone and is part of the test suite of the bitcoin software. You can change a few characters in this string and check that it'll fail the test.

This requires the rust-crypto crate for sha256.

```rust
¬†
extern crate crypto;
¬†
use crypto::digest::Digest;
use crypto::sha2::Sha256;
¬†
const DIGITS58: [char; 58] = ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
¬†
fn main() {
    println!("{}", validate_address("1AGNa15ZQXAZUgFiqJ3i7Z2DPU2J6hW62i"));
    println!("{}", validate_address("1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i"));
    println!("{}", validate_address("17NdbrSGoUotzeGCcMMCqnFkEvLymoou9j"));
    println!("{}", validate_address("17NdbrSGoUotzeGCcMMC?nFkEvLymoou9j"));
}
¬†
fn validate_address(address: &str) -> bool {
    let decoded = match from_base58(address, 25) {
        Ok(x) => x,
        Err(_) => return false
    };
    if decoded[0]¬†!= 0 {
        return false;
    }
    let mut sha = Sha256::new();
    sha.input(&decoded[0..21]);
    let mut first_round = vec![0u8; sha.output_bytes()];
    sha.result(&mut first_round);
    sha.reset();
¬†
    sha.input(&first_round);
    let mut second_round = vec![0u8; sha.output_bytes()];
    sha.result(&mut second_round);
    if second_round[0..4]¬†!= decoded[21..25] {
        return false
    }
    true
}
¬†
fn from_base58(encoded: &str, size: usize) -> Result<Vec<u8>, String> {
    let mut res: Vec<u8> = vec![0; size];
    for base58_value in encoded.chars() {
        let mut value: u32 = match DIGITS58
            .iter()
            .position(|x| *x == base58_value){
            Some(x) => x as u32,
            None => return Err(String::from("Invalid character found in encoded string."))
        };
        for result_index in (0..size).rev() {
            value += 58 * res[result_index] as u32;
            res[result_index] = (value¬†% 256) as u8;
            value /= 256;
        }
    }
    Ok(res)
}
¬†
```

Output:

```rust
false
true
true
false

```

# Make directory path<a id="sec-398"></a>

Task

Create a directory and any missing parents.

This task is named after the posix mkdir -p command, and several libraries which implement the same behavior.

Please implement a function of a single path string (for example ./path/to/dir) which has the above side-effect. If the directory already exists, return successfully. Ideally implementations will work equally well cross-platform (on windows, linux, and OS X).

It's likely that your language implements such a function as part of its standard library. If so, please also show how such a function would be implemented.

```rust
use std::fs;
¬†
fn main() {
    fs::create_dir_all("./path/to/dir").expect("An Error Occured!")
}
```

# Pattern matching<a id="sec-399"></a>

Some languages offer direct support for algebraic data types and pattern matching on them. While this of course can always be simulated with manual tagging and conditionals, it allows for terse code which is easy to read, and can represent the algorithm directly.

Task

As an example, implement insertion in a red-black-tree.

A red-black-tree is a binary tree where each internal node has a color attribute red or black. Moreover, no red node can have a red child, and every path from the root to an empty node must contain the same number of black nodes. As a consequence, the tree is balanced, and must be re-balanced after an insertion.

Translation of: Haskell

This would be a horribly inefficient way to implement a Red-Black Tree in Rust as nodes are being allocated and deallocated constantly, but it does show off Rust's pattern matching.

```rust
#![feature(box_patterns, box_syntax)]
use self::Color::*;
use std::cmp::Ordering::*;
¬†
enum Color {R,B}
¬†
type Link<T> = Option<Box<N<T>>>;
struct N<T> {
    c: Color,
    l: Link<T>,
    val: T,
    r: Link<T>,
}
¬†
¬†
impl<T: Ord> N<T> {
    fn balance(col: Color, n1: Link<T>, z: T, n2: Link<T>) -> Link<T> {
        Some(box 
             match (col,n1,n2) {
                   (B, Some(box N {c: R, l: Some(box N {c: R, l: a, val: x, r: b}), val: y, r: c}), d)
                |  (B, Some(box N {c: R, l: a, val: x, r: Some (box N {c: R, l: b, val: y, r: c})}), d)
                => N {c: R, l: Some(box N {c: B, l: a, val: x, r: b}), val: y, r: Some(box N {c: B, l: c, val: z, r: d})},
                   (B, a, Some(box N {c: R, l: Some(box N {c: R, l: b, val: y, r: c}), val: v, r: d}))
                |  (B, a, Some(box N {c: R, l: b, val: y, r: Some(box N {c: R, l: c, val: v, r: d})}))
                => N {c: R, l: Some(box N {c: B, l: a, val: z, r: b}), val: y, r: Some(box N {c: B, l: c, val: v, r: d})},
                (col, a, b) => N {c: col, l: a, val: z, r: b},
        })
    }
    fn insert(x: T, n: Link<T>) -> Link<T> {
        match n {
            None => Some(box N { c: R, l: None, val: x, r: None }),
            Some(n) =>  {
                let n = *n;
                let N {c: col, l: a, val: y, r: b} = n;
                match x.cmp(&y) {
                    Greater => Self::balance(col, a,y,Self::insert(x,b)),
                    Less    => Self::balance(col, Self::insert(x,a),y,b),
                    Equal   => Some(box N {c: col, l: a, val: y, r: b})
                }
            }
        }
    }
}
```

# Arena storage pool<a id="sec-400"></a>

Dynamically allocated objects take their memory from a heap. The memory for an object is provided by an allocator which maintains the storage pool used for the heap. Often a call to allocator is denoted as

```
P¬†:= new T
```

where T is the type of an allocated object and P is a reference to the object.

The storage pool chosen by the allocator can be determined by either:

the object type T; the type of pointer P.

In the former case objects can be allocated only in one storage pool. In the latter case objects of the type can be allocated in any storage pool or on the stack.

Task description The task is to show how allocators and user-defined storage pools are supported by the language. In particular:

define an arena storage pool. An arena is a pool in which objects are allocated individually, but freed by groups. allocate some objects (e.g., integers) in the pool.

Explain what controls the storage pool choice in the language.

```rust
#![feature(rustc_private)]
¬†
extern crate arena;
¬†
use arena::TypedArena;
¬†
fn main() {
    // Memory is allocated using the default allocator (currently jemalloc).  The memory is
    // allocated in chunks, and when one chunk is full another is allocated.  This ensures that
    // references to an arena don't become invalid when the original chunk runs out of space.  The
    // chunk size is configurable as an argument to TypedArena::with_capacity if necessary.
    let arena = TypedArena::new();
¬†
    // The arena crate contains two types of arenas: TypedArena and Arena.  Arena is
    // reflection-basd and slower, but can allocate objects of any type.  TypedArena is faster, and
    // can allocate only objects of one type.  The type is determined by type inference--if you try
    // to allocate an integer, then Rust's compiler knows it is an integer arena.
    let v1 = arena.alloc(1i32);
¬†
    // TypedArena returns a mutable reference
    let v2 = arena.alloc(3);
    *v2 += 38;
    println!("{}", *v1 + *v2);
¬†
    // The arena's destructor is called as it goes out of scope, at which point it deallocates
    // everything stored within it at once.
}
```

# Chaos game<a id="sec-401"></a>

The Chaos Game is a method of generating the attractor of an iterated function system (IFS). One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.

Task

Play the Chaos Game using the corners of an equilateral triangle as the reference points. Add a starting point at random (preferably inside the triangle). Then add the next point halfway between the starting point and one of the reference points. This reference point is chosen at random.

After a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.

See also

The Game of Chaos

Dependencies: image, rand

```rust
extern crate image;
extern crate rand;
¬†
use std::fs::File;
use rand::Rng;
use std::f32;
¬†
fn main() {
    let max_iterations = 50_000u32;
    let img_side = 800u32;
    let tri_size = 400f32;
¬†
    // Create a new ImgBuf
    let mut imgbuf = image::ImageBuffer::new(img_side, img_side);
¬†
    // Create triangle vertices
    let mut vertices: [[f32; 2]; 3] = [[0f32, 0f32]; 3];
    for i in 0..vertices.len() {
        vertices[i][0] =
            (img_side as f32 / 2.) + (tri_size / 2.) * (f32::consts::PI * i as f32 * 2. / 3.).cos();
        vertices[i][1] =
            (img_side as f32 / 2.) + (tri_size / 2.) * (f32::consts::PI * i as f32 * 2. / 3.).sin();
    }
    for v in &vertices {
        imgbuf.put_pixel(v[0] as u32, v[1] as u32, image::Luma([255u8]));
    }
¬†
    // Iterate chaos game
    let mut rng = rand::weak_rng();
    let mut x = img_side as f32 / 2.;
    let mut y = img_side as f32 / 2.;
    for _ in 0..max_iterations {
        let choice = rng.gen_range(0, vertices.len());
        x = (x + vertices[choice][0]) / 2.;
        y = (y + vertices[choice][1]) / 2.;
¬†
        imgbuf.put_pixel(x as u32, y as u32, image::Luma([255u8]));
    }
¬†
    // Save image
    let fout = &mut File::create("fractal.png").unwrap();
    image::ImageLuma8(imgbuf).save(fout, image::PNG).unwrap();
}
```

# K-means++ clustering<a id="sec-402"></a>

K-means++ clustering

K-means

This data was partitioned into 7 clusters using the K-means algorithm.

The task is to implement the K-means++ algorithm. Produce a function which takes two arguments: the number of clusters K, and the dataset to classify. K is a positive integer and the dataset is a list of points in the Cartesian plane. The output is a list of clusters (related sets of points, according to the algorithm).

For extra credit (in order):

Provide a function to exercise your code, which generates a list of random points. Provide a visualization of your results, including centroids (see example image). Generalize the function to polar coordinates (in radians). Generalize the function to points in an arbitrary N space (i.e. instead of x,y pairs, points are an N-tuples representing coordinates in ‚ÑùN). If this is different or more difficult than the [naive] solution for ‚Ñù2, discuss what had to change to support N dimensions.

Extra credit is only awarded if the examples given demonstrate the feature in question. To earn credit for 1. and 2., visualize 6 clusters of 30,000 points in ‚Ñù2. It is not necessary to provide visualization for spaces higher than ‚Ñù2 but the examples should demonstrate features 3. and 4. if the solution has them.

Translation of: Python

```rust
extern crate csv;
extern crate getopts;
extern crate gnuplot;
extern crate nalgebra;
extern crate num;
extern crate rand;
extern crate rustc_serialize;
extern crate test;
¬†
use getopts::Options;
use gnuplot::{Axes2D, AxesCommon, Color, Figure, Fix, PointSize, PointSymbol};
use nalgebra::{DVector, Iterable};
use rand::{Rng, SeedableRng, StdRng};
use rand::distributions::{IndependentSample, Range};
use std::f64::consts::PI;
use std::env;
¬†
type Point = DVector<f64>;
¬†
struct Cluster<'a> {
    members: Vec<&'a Point>,
    center: Point,
}
¬†
struct Stats {
    centroids: Vec<Point>,
    mean_d_from_centroid: DVector<f64>,
}
¬†
/// DVector doesn't implement BaseFloat, so a custom distance function is required.
fn sqdist(p1: &Point, p2: &Point) -> f64 {
    (p1.clone() - p2.clone()).iter().map(|x| x * x).fold(0f64, |a, b| a + b)
}
¬†
/// Returns (distance^2, index) tuple of winning point.
fn nearest(p: &Point, candidates: &Vec<Point>) -> (f64, usize) {
    let (dsquared, the_index) = candidates.iter()
                                          .enumerate()
                                          .fold((sqdist(p, &candidates[0]), 0),
                                                |(d, index), next| {
                                                    let dprime = sqdist(p, &candidates[next.0]);
                                                    if dprime < d {
                                                        (dprime, next.0)
                                                    } else {
                                                        (d, index)
                                                    }
                                                });
    (dsquared, the_index)
}
¬†
/// Computes starting centroids and makes initial assignments.
fn kpp(points: &Vec<Point>, k: usize, rng: &mut StdRng) -> Stats {
    let mut centroids: Vec<Point> = Vec::new();
    // Random point for first centroid guess:
    centroids.push(points[rng.gen::<usize>()¬†% points.len()].clone());
    let mut dists: Vec<f64> = vec![0f64; points.len()];
¬†
    for _ in 1..k {
        let mut sum = 0f64;
        for (j, p) in points.iter().enumerate() {
            let (dsquared, _) = nearest(&p, &centroids);
            dists[j] = dsquared;
            sum += dsquared;
        }
¬†
        // This part chooses the next cluster center with a probability proportional to d^2
        sum *= rng.next_f64();
        for (j, d) in dists.iter().enumerate() {
            sum -= *d;
            if sum <= 0f64 {
                centroids.push(points[j].clone());
                break;
            }
        }
    }
¬†
    let clusters = assign_clusters(points, &centroids);
    compute_stats(&clusters)
}
¬†
fn assign_clusters<'a>(points: &'a Vec<Point>, centroids: &Vec<Point>) -> Vec<Cluster<'a>> {
    let mut clusters: Vec<Cluster> = Vec::new();
¬†
    for _ in 0..centroids.len() {
        clusters.push(Cluster {
            members: Vec::new(),
            center: DVector::new_zeros(points[0].len()),
        });
    }
¬†
    for p in points.iter() {
        let (_, nearest_index) = nearest(p, centroids);
        clusters[nearest_index].center = clusters[nearest_index].center.clone() + p.clone();
        clusters[nearest_index].members.push(p);
    }
¬†
    for i in 0..clusters.len() {
        clusters[i].center = clusters[i].center.clone() / clusters[i].members.len() as f64;
    }
¬†
    clusters
}
¬†
/// Computes centroids and mean-distance-from-centroid for each cluster.
fn compute_stats(clusters: &Vec<Cluster>) -> Stats {
    let mut centroids = Vec::new();
    let mut means_vec = Vec::new();
¬†
    for c in clusters.iter() {
        let pts = &c.members;
        let seed: DVector<f64> = DVector::new_zeros(pts[0].len());
        let centroid = pts.iter().fold(seed, |a, &b| a + b.clone()) / pts.len() as f64;
        means_vec.push(pts.iter().fold(0f64, |acc, pt| acc + sqdist(pt, &centroid).sqrt()) /
                       pts.len() as f64);
        centroids.push(centroid);
    }
¬†
    Stats {
        centroids: centroids,
        mean_d_from_centroid: DVector::from_slice(means_vec.len(), means_vec.as_slice()),
    }
}
¬†
fn lloyd<'a>(points: &'a Vec<Point>,
             k: usize,
             stoppage_delta: f64,
             max_iter: u32,
             rng: &mut StdRng)
             -> (Vec<Cluster<'a>>, Stats) {
¬†
    let mut clusters = Vec::new();
    // Choose starting centroids and make initial assignments
    let mut stats = kpp(points, k, rng);
¬†
    for i in 1..max_iter {
        let last_means: DVector<f64> = stats.mean_d_from_centroid.clone();
        clusters = assign_clusters(points, &stats.centroids);
        stats = compute_stats(&clusters);
        let err = sqdist(&stats.mean_d_from_centroid, &last_means).sqrt();
        if err < stoppage_delta {
            println!("Stoppage condition reached on iteration {}", i);
            return (clusters, stats);
        }
        // Console output
        print!("Iter {}: ", i);
        for (cen, mu) in stats.centroids.iter().zip(stats.mean_d_from_centroid.iter()) {
            print_dvec(cen);
            print!(" {:1.2} | ", mu);
        }
        print!("{:1.5}\n", err);
    }
¬†
    println!("Stoppage condition not reached by iteration {}", max_iter);
    (clusters, stats)
}
¬†
/// Uniform sampling on the unit disk.
fn generate_points(n: u32, rng: &mut StdRng) -> Vec<Point> {
    let r_range = Range::new(0f64, 1f64);
    let theta_range = Range::new(0f64, 2f64 * PI);
    let mut points: Vec<Point> = Vec::new();
¬†
    for _ in 0..n {
        let root_r = r_range.ind_sample(rng).sqrt();
        let theta = theta_range.ind_sample(rng);
        points.push(DVector::<f64>::from_slice(2, &[root_r * theta.cos(), root_r * theta.sin()]));
    }
¬†
    points
}
¬†
// Plot clusters (2d only). Closure idiom allows us to borrow and mutate the Axes2D.
fn viz(clusters: Vec<Cluster>, stats: Stats, k: usize, n: u32, e: f64) {
    let mut fg = Figure::new();
    {
        let prep = |fg: &mut Figure| {
            let axes: &mut Axes2D = fg.axes2d();
            let title: String = format!("k = {}, n = {}, e = {:4}", k, n, e);
            let centroids_x = stats.centroids.iter().map(|c| c[0]);
            let centroids_y = stats.centroids.iter().map(|c| c[1]);
            for cluster in clusters.iter() {
                axes.points(cluster.members.iter().map(|p| p[0]),
                            cluster.members
                                   .iter()
                                   .map(|p| p[1]),
                            &[PointSymbol('O'), PointSize(0.25)]);
            }
            axes.set_aspect_ratio(Fix(1.0))
                .points(centroids_x,
                        centroids_y,
                        &[PointSymbol('o'), PointSize(1.5), Color("black")])
                .set_title(&title[..], &[]);
        };
        prep(&mut fg);
    }
    fg.show();
}
¬†
fn print_dvec(v: &DVector<f64>) {
    print!("(");
    for elem in v.at.iter().take(v.len() - 1) {
        print!("{:+1.2}, ", elem)
    }
    print!("{:+1.2})", v.at.iter().last().unwrap());
}
¬†
fn print_usage(program: &str, opts: Options) {
    let brief = format!("Usage: {} [options]", program);
    print!("{}", opts.usage(&brief));
}
¬†
fn main() {
    let args: Vec<String> = env::args().collect();
    let mut k: usize = 7;
    let mut n: u32 = 30000;
    let mut e: f64 = 1e-3;
    let max_iterations = 100u32;
¬†
    let mut opts = Options::new();
    opts.optflag("?", "help", "Print this help menu");
    opts.optopt("k",
                "",
                "Number of clusters to assign (default: 7)",
                "<clusters>");
    opts.optopt("n",
                "",
                "Operate on this many points on the unit disk (default: 30000)",
                "<pts>");
    opts.optopt("e",
                "",
                "Min delta in norm of successive cluster centroids to continue (default: 1e-3)",
                "<eps>");
    opts.optopt("f", "", "Read points from file (overrides -n)", "<csv>");
¬†
    let program = args[0].clone();
    let matches = match opts.parse(&args[1..]) {
        Ok(m) => m,
        Err(f) => panic!(f.to_string()),
    };
    if matches.opt_present("?") {
        print_usage(&program, opts);
        return;
    }
    match matches.opt_str("k") {
        None => {}
        Some(x) => k = x.parse::<usize>().unwrap(),
    };
    match matches.opt_str("n") {
        None => {}
        Some(x) => n = x.parse::<u32>().unwrap(),
    };
    match matches.opt_str("e") {
        None => {}
        Some(x) => e = x.parse::<f64>().unwrap(),
    };
¬†
    let seed: &[_] = &[1, 2, 3, 4];
    let mut rng: StdRng = SeedableRng::from_seed(seed);
¬†
    let mut points: Vec<Point>;
¬†
    match matches.opt_str("f") {
        None => {
            // Proceed with random 2d data
            points = generate_points(n, &mut rng)
        }
        Some(file) => {
            points = Vec::new();
            let mut rdr = csv::Reader::from_file(file.clone()).unwrap();
            for row in rdr.records().map(|r| r.unwrap()) {
                // row is Vec<String>
                let floats: Vec<f64> = row.iter().map(|s| s.parse::<f64>().unwrap()).collect();
                points.push(DVector::<f64>::from_slice(floats.len(), floats.as_slice()));
            }
            assert!(points.iter().all(|v| v.len() == points[0].len()));
            n = points.len() as u32;
            println!("Read {} points from {}", points.len(), file.clone());
        }
    };
¬†
    assert!(points.len() >= k);
    let (clusters, stats) = lloyd(&points, k, e, max_iterations, &mut rng);
¬†
    println!(" k       centroid{}mean dist    pop",
             std::iter::repeat(" ").take((points[0].len() - 2) * 7 + 7).collect::<String>());
    println!("===  {}  ===========  =====",
             std::iter::repeat("=").take(points[0].len() * 7 + 2).collect::<String>());
    for i in 0..clusters.len() {
        print!(" {:>1}    ", i);
        print_dvec(&stats.centroids[i]);
        print!("      {:1.2}       {:>4}\n",
               stats.mean_d_from_centroid[i],
               clusters[i].members.len());
    }
¬†
    if points[0].len() == 2 {
        viz(clusters, stats, k, n, e)
    }
}
¬†
```

[Plots exist but file upload is broken at the moment.]

Output of run on 30k points on the unit disk:

```rust
Stoppage condition reached on iteration 10
 k       centroid       mean dist    pop
===  ================  ===========  =====
 0    (+0.34, -0.61)      0.27       4425
 1    (+0.70, -0.01)      0.26       4293
 2    (-0.37, -0.59)      0.27       4319
 3    (+0.35, +0.61)      0.26       4368
 4    (-0.00, +0.01)      0.25       4095
 5    (-0.34, +0.62)      0.26       4190
 6    (-0.71, +0.04)      0.26       4310

```

Extra credit 4: Use of the DVector type in the nalgebra crate gives some arithmetic vector operations for free, and generalizes to n dimensions with no work. Here is the output of running this program on the 4-D Fisher Iris data (I don't think this data clusters well):

```rust
k       centroid                     mean dist    pop
===  ==============================  ===========  =====
0    (+5.00, +3.43, +1.46, +0.25)      0.49         49
1    (+5.88, +2.74, +4.39, +1.43)      0.73         61
2    (+6.85, +3.08, +5.72, +2.05)      0.73         39

```

# Cut a rectangle<a id="sec-403"></a>

A given rectangle is made from m √ó n squares. If m and n are not both odd, then it is possible to cut a path through the rectangle along the square edges such that the rectangle splits into two connected pieces with the same shape (after rotating one of the pieces by 180¬∞). All such paths for 2 √ó 2 and 4 √ó 3 rectangles are shown below.

Write a program that calculates the number of different ways to cut an m √ó n rectangle. Optionally, show each of the cuts.

Possibly related task: Maze generation for depth-first search.

Translation of: Python

```rust
¬†
fn cwalk(mut vis: &mut Vec<Vec<bool>>, count: &mut isize, w: usize, h: usize, y: usize, x: usize, d: usize) {
    if x == 0 || y == 0 || x == w || y == h {
        *count += 1;
        return;
    }
¬†
    vis[y][x] = true;
    vis[h - y][w - x] = true;
¬†
    if x¬†!= 0 &&¬†! vis[y][x - 1] {
        cwalk(&mut vis, count, w, h, y, x - 1, d | 1);
    }
    if d & 1¬†!= 0 && x < w &&¬†! vis[y][x+1] {
        cwalk(&mut vis, count, w, h, y, x + 1, d | 1);
    }
    if y¬†!= 0 &&¬†! vis[y - 1][x] {
        cwalk(&mut vis, count, w, h, y - 1, x, d | 2);
    }
    if d & 2¬†!= 0 && y < h &&¬†! vis[y + 1][x] {
        cwalk(&mut vis, count, w, h, y + 1, x, d | 2);
    }
¬†
    vis[y][x] = false;
    vis[h - y][w - x] = false;
}
¬†
fn count_only(x: usize, y: usize) -> isize {
    let mut count = 0;
    let mut w = x;
    let mut h = y;
¬†
    if (h * w) & 1¬†!= 0 {
        return count;
    }
    if h & 1¬†!= 0 {
        std::mem::swap(&mut w, &mut h);
    }
¬†
    let mut vis = vec![vec![false; w + 1]; h + 1];
    vis[h / 2][w / 2] = true;
¬†
    if w & 1¬†!= 0 {
        vis[h / 2][w / 2 + 1] = true;
    }
    let mut res;
    if w > 1 {
        cwalk(&mut vis, &mut count, w, h, h / 2, w / 2 - 1, 1);
        res = 2 * count - 1;
        count = 0;
        if w¬†!= h {
            cwalk(&mut vis, &mut count, w, h, h / 2 + 1, w / 2, if w & 1¬†!= 0 { 3 } else { 2 });
        } 
        res += 2 * count - if w & 1 == 0 { 1 } else { 0 };
    }
    else {
        res = 1;
    }
¬†
    if w == h {
        res = 2 * res + 2;
    }
    res
}
¬†
fn main() {
    for y in 1..10 {
        for x in 1..y + 1 {
            if x & 1 == 0 || y & 1 == 0 {
                println!("{} x {}: {}", y, x, count_only(x, y));
            }
        }
    }
}
¬†
```

# Check output device is a terminal<a id="sec-404"></a>

Task

Demonstrate how to check whether the output device is a terminal or not.

Related task

¬† Check input device is a terminal

```rust
/* Uses C library interface */
¬†
extern crate libc;
¬†
fn main() {
    let istty = unsafe { libc::isatty(libc::STDOUT_FILENO as i32) }¬†!= 0;
    if istty {
        println!("stdout is tty");
    } else {
        println!("stdout is not tty");
    }
}
```

# Minesweeper game<a id="sec-405"></a>

There is an n by m grid that has a random number (between 10% to 20% of the total number of tiles, though older implementations may use 20%..60% instead) of randomly placed mines that need to be found.

Positions in the grid are modified by entering their coordinates where the first coordinate is horizontal in the grid and the second vertical. The top left of the grid is position 1,1; the bottom right is at n,m.

The total number of mines to be found is shown at the beginning of the game. Each mine occupies a single grid point, and its position is initially unknown to the player The grid is shown as a rectangle of characters between moves. You are initially shown all grids as obscured, by a single dot '.' You may mark what you think is the position of a mine which will show as a '?' You can mark what you think is free space by entering its coordinates.

If the point is free space then it is cleared, as are any adjacent points that are also free space- this is repeated recursively for subsequent adjacent free points unless that point is marked as a mine or is a mine. Points marked as a mine show as a '?'. Other free points show as an integer count of the number of adjacent true mines in its immediate neighborhood, or as a single space ' ' if the free point is not adjacent to any true mines.

Of course you lose if you try to clear space that has a hidden mine. You win when you have correctly identified all mines.

The Task is to create a program that allows you to play minesweeper on a 6 by 4 grid, and that assumes all user input is formatted correctly and so checking inputs for correct form may be omitted. You may also omit all GUI parts of the task and work using text input and output.

Note: Changes may be made to the method of clearing mines to more closely follow a particular implementation of the game so long as such differences and the implementation that they more accurately follow are described.

C.F: wp:Minesweeper (computer game)

```rust
extern crate rand;
¬†
use std::io;
use std::io::Write;
¬†
fn main() {
¬†
    use minesweeper::{MineSweeper, GameStatus};
¬†
    let mut width = 6;
    let mut height = 4;
    let mut mine_perctg = 10;
    let mut game = MineSweeper::new(width, height, mine_perctg);
¬†
    loop {
        let mut command = String::new();
¬†
        println!(
            "\n\
             M I N E S W E E P E R\n\
             \n\
             Commands: \n\
             line col            - reveal line,col \n\
             m line col          - mark   line,col \n\
             q                   - quit\n\
             n                   - new game\n\
             n width height perc - new game size and mine percentage\n"
        );
¬†
        game.print();
        print!("> ");
        io::stdout().flush().unwrap();
        while let Ok(_) = io::stdin().read_line(&mut command) {
            let mut command_ok = false;
            {
                let values: Vec<&str> = command.trim().split(' ').collect();
                if values.len() == 1 {
                    if values[0] == "q" {
                        println!("Goodbye");
                        return;
                    } else if values[0] == "n" {
                        println!("New game");
                        game = MineSweeper::new(width, height, mine_perctg);
                        command_ok = true;
                    }
                } else if values.len() == 2 {
                    if let (Ok(x), Ok(y)) = (
                        values[0].parse::<usize>(),
                        values[1].parse::<usize>(),
                    )
                    {
                        game.play(x - 1, y - 1);
¬†
                        match game.game_status {
                            GameStatus::Won => println!("You won!"),
                            GameStatus::Lost => println!("You lost!"),
                            _ => (),
                        }
                        command_ok = true;
                    }
                } else if values.len() == 3 {
                    if values[0] == "m" {
                        if let (Ok(x), Ok(y)) = (
                            values[1].parse::<usize>(),
                            values[2].parse::<usize>(),
                        )
                        {
                            game.mark(x - 1, y - 1);
                            command_ok = true;
                        }
                    }
                } else if values.len() == 4 {
                    if values[0] == "n" {
                        if let (Ok(new_width), Ok(new_height), Ok(new_mines_perctg)) =
                            (
                                values[1].parse::<usize>(),
                                values[2].parse::<usize>(),
                                values[3].parse::<usize>(),
                            )
                        {
                            width = new_width;
                            height = new_height;
                            mine_perctg = new_mines_perctg;
                            game = MineSweeper::new(width, height, mine_perctg);
                            command_ok = true;
                        }
                    }
                }
            }
¬†
            if command_ok {
                game.print();
            } else {
                println!("Invalid command");
            }
¬†
            print!("> ");
            io::stdout().flush().unwrap();
            command.clear();
        }
    }
}
¬†
pub mod minesweeper {
¬†
    pub struct MineSweeper {
        cell: [[Cell; 100]; 100],
        pub game_status: GameStatus,
        mines: usize,
        width: usize,
        height: usize,
        revealed_count: usize,
    }
¬†
    #[derive(Copy, Clone)]
    struct Cell {
        content: CellContent,
        mark: Mark,
        revealed: bool,
    }
¬†
    #[derive(Copy, Clone)]
    enum CellContent {
        Empty,
        Mine,
        MineNeighbour { count: u8 },
    }
¬†
    #[derive(Copy, Clone)]
    enum Mark {
        None,
        Mine,
    }
¬†
    pub enum GameStatus {
        InGame,
        Won,
        Lost,
    }
¬†
    extern crate rand;
¬†
    use std::cmp::max;
    use std::cmp::min;
    use self::rand::Rng;
    use self::CellContent::*;
    use self::GameStatus::*;
¬†
    impl MineSweeper {
        pub fn new(width: usize, height: usize, percentage_of_mines: usize) -> MineSweeper {
            let mut game = MineSweeper {
                cell: [[Cell {
                    content: Empty,
                    mark: Mark::None,
                    revealed: false,
                }; 100]; 100],
                game_status: InGame,
                mines: (width * height * percentage_of_mines) / 100,
                width: width,
                height: height,
                revealed_count: 0,
            };
            game.put_mines();
            game.calc_neighbours();
            game
        }
¬†
        pub fn play(&mut self, x: usize, y: usize) {
            match self.game_status {
                InGame => {
                    if¬†!self.cell[x][y].revealed {
                        match self.cell[x][y].content {
                            Mine => {
                                self.cell[x][y].revealed = true;
                                self.revealed_count += 1;
                                self.game_status = Lost;
                            }
                            Empty => {
                                self.flood_fill_reveal(x, y);
                                if self.revealed_count + self.mines == self.width * self.height {
                                    self.game_status = Won;
                                }
                            }
                            MineNeighbour { .. } => {
                                self.cell[x][y].revealed = true;
                                self.revealed_count += 1;
                                if self.revealed_count + self.mines == self.width * self.height {
                                    self.game_status = Won;
                                }
                            }
                        }
                    }
                }
                _ => println!("Game has ended"),
            }
        }
¬†
        pub fn mark(&mut self, x: usize, y: usize) {
            self.cell[x][y].mark = match self.cell[x][y].mark {
                Mark::None => Mark::Mine,
                Mark::Mine => Mark::None,
            }
        }
¬†
        pub fn print(&self) {
            print!("‚îå");
            for _ in 0..self.width {
                print!("‚îÄ");
            }
            println!("‚îê");
            for y in 0..self.height {
                print!("‚îÇ");
                for x in 0..self.width {
                    self.cell[x][y].print();
                }
                println!("‚îÇ");
            }
            print!("‚îî");
            for _ in 0..self.width {
                print!("‚îÄ");
            }
            println!("‚îò");
        }
¬†
        fn put_mines(&mut self) {
            let mut rng = rand::thread_rng();
            for _ in 0..self.mines {
                while let (x, y, true) = (
                    rng.gen::<usize>()¬†% self.width,
                    rng.gen::<usize>()¬†% self.height,
                    true,
                )
                {
                    match self.cell[x][y].content {
                        Mine => continue,
                        _ => {
                            self.cell[x][y].content = Mine;
                            break;
                        }
                    }
                }
            }
        }
¬†
        fn calc_neighbours(&mut self) {
            for x in 0..self.width {
                for y in 0..self.height {
                    if¬†!self.cell[x][y].is_bomb() {
                        let mut adjacent_bombs = 0;
¬†
                        for i in max(x as isize - 1, 0) as usize..min(x + 2, self.width) {
                            for j in max(y as isize - 1, 0) as usize..min(y + 2, self.height) {
                                adjacent_bombs += if self.cell[i][j].is_bomb() { 1 } else { 0 };
                            }
                        }
¬†
                        if adjacent_bombs == 0 {
                            self.cell[x][y].content = Empty;
                        } else {
                            self.cell[x][y].content = MineNeighbour { count: adjacent_bombs };
                        }
                    }
                }
            }
        }
¬†
        fn flood_fill_reveal(&mut self, x: usize, y: usize) {
            let mut stack = Vec::<(usize, usize)>::new();
            stack.push((x, y));
¬†
            while let Some((i, j)) = stack.pop() {
                if self.cell[i][j].revealed {
                    continue;
                }
                self.cell[i][j].revealed = true;
                self.revealed_count += 1;
                if let Empty = self.cell[i][j].content {
                    for m in max(i as isize - 1, 0) as usize..min(i + 2, self.width) {
                        for n in max(j as isize - 1, 0) as usize..min(j + 2, self.height) {
                            if¬†!self.cell[m][n].is_bomb() &&¬†!self.cell[m][n].revealed {
                                stack.push((m, n));
                            }
                        }
                    }
                }
            }
        }
    }
¬†
    impl Cell {
        pub fn print(&self) {
            print!(
                "{}",
                if self.revealed {
                    match self.content {
                        Empty => ' ',
                        Mine => '*',
                        MineNeighbour { count } => char::from(count + b'0'),
                    }
                } else {
                    match self.mark {
                        Mark::Mine => '?',
                        Mark::None => '.',
                    }
                }
            );
        }
¬†
        pub fn is_bomb(&self) -> bool {
            match self.content {
                Mine => true,
                _ => false,
            }
        }
    }
}
```

Sample output

```rust
M I N E S W E E P E R

Commands: 
line col            - reveal line,col 
m line col          - mark   line,col 
q                   - quit
n                   - new game
n width height perc - new game size and mine percentage

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ......‚îÇ
‚îÇ......‚îÇ
‚îÇ......‚îÇ
‚îÇ......‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
> 5 3
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ.1    ‚îÇ
‚îÇ.211  ‚îÇ
‚îÇ...1  ‚îÇ
‚îÇ...1  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
> 1 4
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ.1    ‚îÇ
‚îÇ1211  ‚îÇ
‚îÇ 1.1  ‚îÇ
‚îÇ 1.1  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
> 3 4
You won!
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ.1    ‚îÇ
‚îÇ1211  ‚îÇ
‚îÇ 1.1  ‚îÇ
‚îÇ 111  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
> q
Goodbye

```

# Euler's identity<a id="sec-406"></a>

This page uses content from Wikipedia. The original article was at Euler's<sub>identity</sub>. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

In mathematics, ¬† Euler's identity ¬† (also known as ¬† Euler's equation) ¬† is the equality:

```
              ei



   {\displaystyle \pi }


+ 1 = 0

```

where

```
  e is Euler's number, the base of natural logarithms,
  i is the imaginary unit, which satisfies i2 = ‚àí1, and




   {\displaystyle \pi }


is pi, the ratio of the circumference of a circle to its diameter.

```

Euler's identity is often cited as an example of deep mathematical beauty. Three of the basic arithmetic operations occur exactly once each: addition, multiplication, and exponentiation. The identity also links five fundamental mathematical constants:

```
  The number 0.
  The number 1.
  The number 



   {\displaystyle \pi }


(



   {\displaystyle \pi }


= 3.14159+),
  The number e (e = 2.71828+), which occurs widely in mathematical analysis.
  The number i, the imaginary unit of the complex numbers.

```

Task

Show in your language that Euler's identity is true. As much as possible and practical, mimic the Euler's identity equation.

Most languages are limited to IEEE 754 floating point calculations so will have some error in the calculation.

If that is the case, or there is some other limitation, show that ¬† ei {\displaystyle &pi; }

-   1 ¬† is approximately equal to zero and show the amount of error in the calculation.

If your language is capable of symbolic calculations, show that ¬† ei {\displaystyle &pi; }

-   1 ¬† is exactly equal to zero for bonus kudos points.

```rust
use std::f64::consts::PI;
¬†
extern crate num_complex;
use num_complex::Complex;
¬†
fn main() {
    println!("{:e}", Complex::new(0.0, PI).exp() + 1.0);
}
```

Output:

```rust
0e0+1.2246467991473532e-16i

```

# Find the intersection of a line with a plane<a id="sec-407"></a>

Task

Find the point of intersection for the infinite ray with direction (0,-1,-1) passing through position (0, 0, 10) with the infinite plane with a normal vector of (0, 0, 1) and which passes through [0, 0, 5].

Translation of: Kotlin

```rust
use std::ops::{Add, Div, Mul, Sub};
¬†
#[derive(Copy, Clone, Debug, PartialEq)]
struct V3<T> {
    x: T,
    y: T,
    z: T,
}
¬†
impl<T> V3<T> {
    fn new(x: T, y: T, z: T) -> Self {
        V3 { x, y, z }
    }
}
¬†
fn zip_with<F, T, U>(f: F, a: V3<T>, b: V3<T>) -> V3<U>
where
    F: Fn(T, T) -> U,
{
    V3 {
        x: f(a.x, b.x),
        y: f(a.y, b.y),
        z: f(a.z, b.z),
    }
}
¬†
impl<T> Add for V3<T>
where
    T: Add<Output = T>,
{
    type Output = Self;
¬†
    fn add(self, other: Self) -> Self {
        zip_with(<T>::add, self, other)
    }
}
¬†
impl<T> Sub for V3<T>
where
    T: Sub<Output = T>,
{
    type Output = Self;
¬†
    fn sub(self, other: Self) -> Self {
        zip_with(<T>::sub, self, other)
    }
}
¬†
impl<T> Mul for V3<T>
where
    T: Mul<Output = T>,
{
    type Output = Self;
¬†
    fn mul(self, other: Self) -> Self {
        zip_with(<T>::mul, self, other)
    }
}
¬†
impl<T> V3<T>
where
    T: Mul<Output = T> + Add<Output = T>,
{
    fn dot(self, other: Self) -> T {
        let V3 { x, y, z } = self * other;
        x + y + z
    }
}
¬†
impl<T> V3<T>
where
    T: Mul<Output = T> + Copy,
{
    fn scale(self, scalar: T) -> Self {
        self * V3 {
            x: scalar,
            y: scalar,
            z: scalar,
        }
    }
}
¬†
fn intersect<T>(
    ray_vector: V3<T>,
    ray_point: V3<T>,
    plane_normal: V3<T>,
    plane_point: V3<T>,
) -> V3<T>
where
    T: Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Div<Output = T> + Copy,
{
    let diff = ray_point - plane_point;
    let prod1 = diff.dot(plane_normal);
    let prod2 = ray_vector.dot(plane_normal);
    let prod3 = prod1 / prod2;
    ray_point - ray_vector.scale(prod3)
}
¬†
fn main() {
    let rv = V3::new(0.0, -1.0, -1.0);
    let rp = V3::new(0.0, 0.0, 10.0);
    let pn = V3::new(0.0, 0.0, 1.0);
    let pp = V3::new(0.0, 0.0, 5.0);
    println!("{:?}", intersect(rv, rp, pn, pp));
}
¬†
```

# Create an object at a given address<a id="sec-408"></a>

In systems programing it is sometimes required to place language objects at specific memory locations, like I/O registers, hardware interrupt vectors etc.

Task

Show how language objects can be allocated at a specific machine addresses.

Since most OSes prohibit access to the physical memory if it is not mapped by the application, as an example, rather than a physical address, take the address of some existing object (using suitable address operations if necessary). For example, create an integer object. Print the machine address of the object. Take the address of the object and create another integer object at this address. Print the value of this object to verify that it is same as one of the origin. Change the value of the origin and verify it again.

In a real program, most if not all of the contents of main would all be in one \`unsafe\` block, however in this one each unsafe operation gets its own block to emphasize exactly which actions Rust considers unsafe.

```rust
use std::{mem,ptr};
¬†
fn main() {
    let mut data: i32;
¬†
    // Rust does not allow us to use uninitialized memory but the STL provides an `unsafe`
    // function to override this protection.
    unsafe {data = mem::uninitialized()}
¬†
    // Construct a raw pointer (perfectly safe)
    let address = &mut data as *mut _;
¬†
    unsafe {ptr::write(address, 5)}
    println!("{0:p}: {0}", &data);
¬†
    unsafe {ptr::write(address, 6)}
    println!("{0:p}: {0}", &data);
¬†
}
```

# Nonoblock<a id="sec-409"></a>

Nonoblock is a chip off the old Nonogram puzzle.

Given

The number of cells in a row. The size of each, (space separated), connected block of cells to fit in the row, in left-to right order.

The task is to

show all possible positions and the number of positions

of the blocks for the following cases within the row. On this page. Using a "neat" diagram of the block positions.

Enumerate the following configurations

5 cells and [2, 1] blocks 5 cells and [] blocks (no blocks) 10 cells and [8] blocks 15 cells and [2, 3, 2, 3] blocks 5 cells and [2, 3] blocks (Should give some indication of this not being possible).

Example

Given a row of five cells and a block of two cells followed by a block of 1 cell - in that order, the example could be shown as:

```
|_|_|_|_|_| # 5 cells and [2, 1] blocks

```

And would expand to the following 3 possible rows of block positions:

```
|A|A|_|B|_|
|A|A|_|_|B|
|_|A|A|_|B|

```

Note how the sets of blocks are always separated by a space.

Note also that it is not necessary for each block to have a separate letter. Output approximating

This:

```
|#|#|_|#|_|
|#|#|_|_|#|
|_|#|#|_|#|

```

Or even this:

```
##.#.
##..#
.##.#

```

Would also work.

An algorithm

Find the minimum space to the right that is needed to legally hold all but the leftmost block of cells (with a space between blocks remember). The leftmost cell can legitimately be placed in all positions from the LHS up to a RH position that allows enough room for the rest of the blocks. for each position of the LH block recursively compute the position of the rest of the blocks in the remaining space to the right of the current placement of the LH block.

(This is the algorithm used in the Nonoblock#Python solution).

Reference

The blog post Nonogram puzzle solver (part 1) Inspired this task and donated its Nonoblock#Python solution.

Works with: Rust version 1.29.2

```rust
struct Nonoblock {
  width: usize,
  config: Vec<usize>,
  spaces: Vec<usize>,
}
¬†
impl Nonoblock {
  pub fn new(width: usize, config: Vec<usize>) -> Nonoblock {
    Nonoblock {
      width: width,
      config: config,
      spaces: Vec::new(),
    }
  }
¬†
  pub fn solve(&mut self) -> Vec<Vec<i32>> {
    let mut output: Vec<Vec<i32>> = Vec::new();
    self.spaces = (0..self.config.len()).fold(Vec::new(), |mut s, i| {
      s.push(match i {
        0 => 0,
        _ => 1,
      });
      s
    });
    if self.spaces.iter().sum::<usize>() + self.config.iter().sum::<usize>() <= self.width {
      'finished: loop {
        match self.spaces.iter().enumerate().fold((0, vec![0; self.width]), |mut a, (i, s)| {
            (0..self.config[i]).for_each(|j| a.1[a.0 + j + *s] = 1 + i as i32);
            return (a.0 + self.config[i] + *s, a.1);
          }) {
          (_, out) => output.push(out),
        }
        let mut i: usize = 1;
        'calc: loop {
          let len = self.spaces.len();
          if i > len {
            break 'finished;
          } else {
            self.spaces[len - i] += 1
          }
          if self.spaces.iter().sum::<usize>() + self.config.iter().sum::<usize>() > self.width {
            self.spaces[len - i] = 1;
            i += 1;
          } else {
            break 'calc;
          }
        }
      }
    }
    output
  }
}
¬†
fn main() {
  let mut blocks = [
    Nonoblock::new(5, vec![2, 1]),
    Nonoblock::new(5, vec![]),
    Nonoblock::new(10, vec![8]),
    Nonoblock::new(15, vec![2, 3, 2, 3]),
    Nonoblock::new(5, vec![2, 3]),
  ];
¬†
  for block in blocks.iter_mut() {
    println!("{} cells and {:?} blocks", block.width, block.config);
    println!("{}",(0..block.width).fold(String::from("="), |a, _| a + "=="));
    let solutions = block.solve();
    if solutions.len() > 0 {
      for solution in solutions.iter() {
        println!("{}", solution.iter().fold(String::from("|"), |s, f| s + &match f {
          i if *i > 0 => (('A' as u8 + ((*i - 1) as u8)¬†% 26) as char).to_string(),
          _ => String::from("_"),
        }+ "|"));
      }
    } else {
      println!("No solutions. ");
    }
    println!();
  }
}
```

Output:

```rust
5 cells and [2, 1] blocks
===========
|A|A|_|B|_|
|A|A|_|_|B|
|_|A|A|_|B|

5 cells and [] blocks
===========
|_|_|_|_|_|

10 cells and [8] blocks
=====================
|A|A|A|A|A|A|A|A|_|_|
|_|A|A|A|A|A|A|A|A|_|
|_|_|A|A|A|A|A|A|A|A|

15 cells and [2, 3, 2, 3] blocks
===============================
|A|A|_|B|B|B|_|C|C|_|D|D|D|_|_|
|A|A|_|B|B|B|_|C|C|_|_|D|D|D|_|
|A|A|_|B|B|B|_|C|C|_|_|_|D|D|D|
|A|A|_|B|B|B|_|_|C|C|_|D|D|D|_|
|A|A|_|B|B|B|_|_|C|C|_|_|D|D|D|
|A|A|_|B|B|B|_|_|_|C|C|_|D|D|D|
|A|A|_|_|B|B|B|_|C|C|_|D|D|D|_|
|A|A|_|_|B|B|B|_|C|C|_|_|D|D|D|
|A|A|_|_|B|B|B|_|_|C|C|_|D|D|D|
|A|A|_|_|_|B|B|B|_|C|C|_|D|D|D|
|_|A|A|_|B|B|B|_|C|C|_|D|D|D|_|
|_|A|A|_|B|B|B|_|C|C|_|_|D|D|D|
|_|A|A|_|B|B|B|_|_|C|C|_|D|D|D|
|_|A|A|_|_|B|B|B|_|C|C|_|D|D|D|
|_|_|A|A|_|B|B|B|_|C|C|_|D|D|D|

5 cells and [2, 3] blocks
===========
No solutions.

```

# Simulate input/Keyboard<a id="sec-410"></a>

Send simulated keystrokes to a GUI window, or terminal. You should specify whether the target may be externally created (i.e., if the keystrokes are going to an application other than the application that is creating them).

Works with: Rust version 1.25+

Library: AutoPilot

```rust
extern crate autopilot;
fn main() {
    autopilot::key::type_string("Hello, world!", None, None, &[]);
}
```

# Elementary cellular automaton/Random Number Generator<a id="sec-411"></a>

Rule 30 is considered to be chaotic enough to generate good pseudo-random numbers. As a matter of fact, rule 30 is used by the Mathematica software for its default random number generator.

Steven Wolfram's recommendation for random number generation from rule 30 consists in extracting successive bits in a fixed position in the array of cells, as the automaton changes state.

The purpose of this task is to demonstrate this. With the code written in the parent task, which you don't need to re-write here, show the ten first bytes that emerge from this recommendation. To be precise, you will start with a state of all cells but one equal to zero, and you'll follow the evolution of the particular cell whose state was initially one. Then you'll regroup those bits by packets of eight, reconstituting bytes with the first bit being the most significant.

You can pick which ever length you want for the initial array but it should be visible in the code so that your output can be reproduced with an other language.

For extra-credits, you will make this algorithm run as fast as possible in your language, for instance with an extensive use of bitwise logic.

Reference

Cellular automata: Is Rule 30 random? (PDF).

```rust
¬†
//Assuming the code from the Elementary cellular automaton task is in the namespace.
fn main() {
    struct WolfGen(ElementaryCA);
    impl WolfGen {
        fn new() -> WolfGen {
            let (_, ca) = ElementaryCA::new(30);
            WolfGen(ca)
        }
        fn next(&mut self) -> u8 {
            let mut out = 0;
            for i in 0..8 {
                out |= ((1 & self.0.next())<<i)as u8;
            }
            out
        }
    }
    let mut gen = WolfGen::new();
    for _ in 0..10 {
        print!("{} ", gen.next());
    }
}
¬†
```

Output:

```rust
157 209 228 58 87 195 212 106 147 244 

```

# Parallel Brute Force<a id="sec-412"></a>

Task

Find, through brute force, the five-letter passwords corresponding with the following SHA-256 hashes:

```
1. 1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad
2. 3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b
3. 74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f

```

Your program should naively iterate through all possible passwords consisting only of five lower-case ASCII English letters. It should use concurrent or parallel processing, if your language supports that feature. You may calculate SHA-256 hashes by calling a library or through a custom implementation. Print each matching password, along with its SHA-256 hash.

Related task: SHA-256

In this solution the number of threads is the number of logical processors on the machine. \`distribute<sub>work</sub>()\` distributes the work more or less equally between the threads.

```rust
// [dependencies]
// rust-crypto = "0.2.36"
// num_cpus = "1.7.0"
// hex = "0.2.0"
¬†
extern crate crypto;
extern crate num_cpus;
extern crate hex;
¬†
use std::thread;
use std::cmp::min;
use crypto::sha2::Sha256;
use crypto::digest::Digest;
use hex::{FromHex, ToHex};
¬†
fn main() {
    let hashes = vec![
        decode("1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad"),
        decode("3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b"),
        decode("74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f"),
    ];
¬†
    let mut threads = Vec::new();
    let mut ranges = distribute_work();
¬†
    while let Some(range) = ranges.pop() {
        let hashes = hashes.clone();
        threads.push(thread::spawn(
            move || search(range.0, range.1, hashes.clone()),
        ));
    }
¬†
    while let Some(t) = threads.pop() {
        t.join().ok();
    }
}
¬†
fn search(from: [u8; 5], to: [u8; 5], hashes: Vec<[u8; 256 / 8]>) {
¬†
    let mut password = from.clone();
¬†
    while password <= to {
        let mut sha256 = Sha256::new();
        sha256.input(&password);
        let mut result = [0u8; 256 / 8];
        sha256.result(&mut result);
¬†
        for hash in hashes.iter() {
            if *hash == result {
                println!(
                    "{}{}{}{}{} {}",
                    password[0] as char,
                    password[1] as char,
                    password[2] as char,
                    password[3] as char,
                    password[4] as char,
                    hash.to_hex()
                );
            }
        }
¬†
        password = next(&password);
    }
¬†
}
¬†
fn next(password: &[u8; 5]) -> [u8; 5] {
    let mut result = password.clone();
    for i in (0..result.len()).rev() {
        if result[i] == b'z' {
            if i == 0 {
                result[i] = b'z' + 1;
            } else {
                result[i] = b'a';
            }
        } else {
            result[i] += 1;
            break;
        }
    }
    result.clone()
}
¬†
fn distribute_work() -> Vec<([u8; 5], [u8; 5])> {
    let mut ranges = Vec::new();
    let num_cpus = min(num_cpus::get(), 26) as u8;
¬†
    let div = 25 / num_cpus;
    let mut remainder = 25¬†% num_cpus;
    let mut from = b'a';
    while from < b'z' {
¬†
        let to = from + div +
            if remainder > 0 {
                remainder -= 1;
                1
            } else {
                0
            };
¬†
        ranges.push((
            [from, from, from, from, from + 1].clone(),
            [to, to, to, to, to].clone(),
        ));
¬†
        from = to;
    }
    ranges[0].0[4] = b'a';
¬†
    ranges.clone()
}
¬†
fn decode(string: &str) -> [u8; 256 / 8] {
    let mut result = [0; 256 / 8];
    let vec = Vec::from_hex(string).unwrap();
    for i in 0..result.len() {
        result[i] = vec[i];
    }
    result.clone()
}
```

Output:

```rust
apple 3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b
zyzzx 1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad
mmmmm 74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f

```

# Levenshtein distance/Alignment<a id="sec-413"></a>

The Levenshtein distance algorithm returns the number of atomic operations (insertion, deletion or edition) that must be performed on a string in order to obtain an other one, but it does not say anything about the actual operations used or their order.

An alignment is a notation used to describe the operations used to turn a string into an other. At some point in the strings, the minus character ('-') is placed in order to signify that a character must be added at this very place. For instance, an alignment between the words 'place' and 'palace' is:

```
P-LACE
PALACE

```

Task

Write a function that shows the alignment of two strings for the corresponding levenshtein distance.

As an example, use the words "rosettacode" and "raisethysword".

You can either implement an algorithm, or use a dedicated library (thus showing us how it is named in your language).

Cargo.toml

```rust
[dependencies]
edit-distance = "^1.0.0"
```

src/main.rs

```rust
extern crate edit_distance;
¬†
edit_distance("rosettacode", "raisethysword");
```

# Apply a digital filter (direct form II transposed)<a id="sec-414"></a>

Digital filters are used to apply a mathematical operation to a sampled signal. One of the common formulations is the "direct form II transposed" which can represent both infinite impulse response (IIR) and finite impulse response (FIR) filters, as well as being more numerically stable than other forms. [1]

Task

Filter a signal using an order 3 low-pass Butterworth filter. The coefficients for the filter are a=[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17] and b = [0.16666667, 0.5, 0.5, 0.16666667]

The signal that needs filtering is the following vector: [-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677 ,0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589]

Translation of: Java

```rust
use std::cmp::Ordering;
¬†
struct IIRFilter<'f>(&'f [f32], &'f [f32]);
¬†
impl<'f> IIRFilter<'f> {
    pub fn with_coefficients(a: &'f [f32], b: &'f [f32]) -> IIRFilter<'f> {
        IIRFilter(a, b)
    }
¬†
    // Performs the calculation as an iterator chain.
    pub fn apply<I: Iterator<Item = &'f f32> + 'f>(
        &self,
        samples: I,
    ) -> impl Iterator<Item = f32> + 'f {
        // Name some things for readability
        let a_coeff = self.0;
        let b_coeff = self.1;
¬†
        let mut prev_results = Vec::<f32>::new();
        let mut prev_samples = Vec::<f32>::new();
¬†
        // The actual calculation, done one number at a time
        samples.enumerate() // (i, sample[i])
            .map(move |(i, sample)| { // for each sample, apply this function
                prev_samples.push(*sample);
                prev_results.push(0f32); // the initial version of the previous result
¬†
                let sum_b: f32 = b_coeff.iter() // for each coefficient in b
                    .enumerate() // (j, b_coeff[j])
                    .map(|(j, c)| { // calculate the weight of the coefficient
                        if i >= j {
                            (*c) * prev_samples[i-j]
                        } else {
                            0f32
                        }
                    })
                    .sum(); // add them all together
¬†
                let sum_a: f32 = a_coeff.iter() // for each coefficient in a
                    .enumerate() // (j, a_coeff[j])
                    .map(|(j, c)| { // calculate the weight of the coefficient
                        if i >= j {
                            (*c) * prev_results[i-j]
                        } else {
                            0f32
                        }
                    })
                    .sum(); // add them all together
¬†
                // perform the final calculation
                let result = (sum_b - sum_a) / a_coeff[0];
¬†
                // update the previous result for the next iteration
                prev_results[i] = result;
¬†
                // return the current result in this iteration
                result
            }
        )
    }
}
¬†
fn main() {
    let a: &[f32] = &[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17];
    let b: &[f32] = &[0.16666667, 0.5, 0.5, 0.16666667];
¬†
    let samples: Vec<f32> = vec![
        -0.917843918645,
        0.141984778794,
        1.20536903482,
        0.190286794412,
        -0.662370894973,
        -1.00700480494,
        -0.404707073677,
        0.800482325044,
        0.743500089861,
        1.01090520172,
        0.741527555207,
        0.277841675195,
        0.400833448236,
        -0.2085993586,
        -0.172842103641,
        -0.134316096293,
        0.0259303398477,
        0.490105989562,
        0.549391221511,
        0.9047198589,
    ];
¬†
    for (i, result) in IIRFilter::with_coefficients(a, b)
        .apply(samples.iter())
        .enumerate()
    {
        print!("{:.8}", result);
        if (i + 1)¬†% 5¬†!= 0 {
            print!(", ");
        } else {
            println!();
        }
    }
    println!();
}
```

output:

```rust
-0.15297399, -0.43525785, -0.13604343, 0.69750333, 0.65644467
-0.43548250, -1.08923948, -0.53767651, 0.51705003, 1.05224979
0.96185434, 0.69568992, 0.42435625, 0.19626230, -0.02783510
-0.21172196, -0.17474557, 0.06925842, 0.38544586, 0.65177077

```

# Check input device is a terminal<a id="sec-415"></a>

Task

Demonstrate how to check whether the input device is a terminal or not.

Related task

¬† Check output device is a terminal

```rust
/* Uses C library interface */
¬†
extern crate libc;
¬†
fn main() {
    let istty = unsafe { libc::isatty(libc::STDIN_FILENO as i32) }¬†!= 0;
    if istty {
        println!("stdout is tty");
    } else {
        println!("stdout is not tty");
    }
}
```

# Mind boggling card trick<a id="sec-416"></a>

Matt Parker of the "Stand Up Maths channel" has a ¬† YouTube video ¬† of a card trick that creates a semblance of order from chaos.

The task is to simulate the trick in a way that mimics the steps shown in the video.

1.  Cards.

Create a common deck of cards of 52 cards ¬† (which are half red, half black). Give the pack a good shuffle.

1.  Deal from the shuffled deck, you'll be creating three piles.

Assemble the cards face down. Turn up the ¬† top card ¬† and hold it in your hand. if the card is ¬† black, ¬† then add the ¬† next ¬† card (unseen) to the "black" pile. If the card is ¬† ¬† red,¬† ¬† then add the ¬† next ¬† card (unseen) to the ¬† "red"¬† pile. Add the ¬† top card ¬† that you're holding to the discard pile. ¬† (You might optionally show these discarded cards to get an idea of the randomness). Repeat the above for the rest of the shuffled deck.

1.  Choose a random number ¬† (call it X) ¬† that will be used to swap cards from the "red" and "black" piles.

Randomly choose ¬† X ¬† cards from the ¬† "red"¬† pile (unseen), let's call this the ¬† "red"¬† bunch. Randomly choose ¬† X ¬† cards from the "black" pile (unseen), let's call this the "black" bunch. Put the ¬† ¬† "red"¬† ¬† bunch into the ¬† "black" pile. Put the ¬† "black" ¬† bunch into the ¬† ¬† "red"¬† pile. (The above two steps complete the swap of ¬† X ¬† cards of the "red" and "black" piles. (Without knowing what those cards are &#x2014; they could be red or black, nobody knows).

1.  Order from randomness?

Verify (or not) the mathematician's assertion that:

```
The number of black cards in the "black" pile equals the number of red cards in the "red" pile. 

```

(Optionally, run this simulation a number of times, gathering more evidence of the truthfulness of the assertion.)

Show output on this page.

Library: rand

```rust
extern crate rand; // 0.5.5
use rand::Rng;
use std::iter::repeat;
¬†
#[derive(Debug, Eq, PartialEq, Clone)]
enum Colour {
    Black,
    Red,
}
use Colour::*;
¬†
fn main() {
    let mut rng = rand::thread_rng();
¬†
    //Create our deck.
    let mut deck: Vec<_> = repeat(Black).take(26)
        .chain(repeat(Red).take(26))
        .collect();
¬†
    rng.shuffle(&mut deck);
¬†
    let mut black_stack = vec![];
    let mut red_stack = vec![];
    let mut discarded = vec![];
¬†
    //Deal our cards.
    print!("Discarding:");
    while let (Some(card), Some(next)) = (deck.pop(), deck.pop()) {
        print!(" {}", if card == Black { "B" } else { "R" });
        match card {
            Red => red_stack.push(next),
            Black => black_stack.push(next),
        }
        discarded.push(card);
    }
    println!();
¬†
    // Choose how many to swap.
    let max = red_stack.len().min(black_stack.len());
    let num = rng.gen_range(1, max);
    println!("Exchanging {} cards", num);
¬†
    // Actually swap our cards.
    for _ in 0..num {
        let red = rng.choose_mut(&mut red_stack).unwrap();
        let black = rng.choose_mut(&mut black_stack).unwrap();
        std::mem::swap(red, black);
    }
¬†
    //Count how many are red and black.
    let num_black = black_stack.iter()
        .filter(|&c| c == &Black)
        .count();
    let num_red = red_stack.iter()
        .filter(|&c| c == &Red)
        .count();
¬†
    println!("Number of black cards in black stack: {}", num_black);
    println!("Number of red cards in red stack: {}", num_red);
}
```

Output:

```rust
Discarding: R R B B R R B R R B B B B B R R R B B B R R R B R R
Exchanging 5 cards
Number of black cards in black stack: 4
Number of red cards in red stack: 4
```

# Word break problem<a id="sec-417"></a>

Task Given an input string and a dictionary of words, segment the input string into a space-separated sequence of dictionary words if possible.

Dynamic programming[edit]

```rust
use std::collections::HashSet;
fn create_string(s: &str, v: Vec<Option<usize>>) -> String {
    let mut idx = s.len();
    let mut slice_vec = vec![];
    while let Some(prev) = v[idx] {
        slice_vec.push(&s[prev..idx]); 
        idx = prev;
    }
    slice_vec.reverse();
    slice_vec.join(" ")
¬†
¬†
}
¬†
fn word_break(s: &str, dict: HashSet<&str>) -> Option<String> {
    let size = s.len() + 1;
    let mut possible = vec![None; size];
¬†
    let check_word = |i,j| dict.get(&s[i..j]).map(|_| i);
¬†
    for i in 1..size {
        possible[i] = possible[i].or_else(|| check_word(0,i));
¬†
        if possible[i].is_some() {
            for j in i+1..size {
                possible[j] = possible[j].or_else(|| check_word(i,j));
            }
¬†
            if possible[s.len()].is_some() {
                return Some(create_string(s, possible));
            }
¬†
        };
    }
    None
}
¬†
fn main() {
    let mut set = HashSet::new();
    set.insert("a");
    set.insert("bc");
    set.insert("abc");
    set.insert("cd");
    set.insert("b");
    println!("{:?}", word_break("abcd", set).unwrap());
}
```

Output:

```rust
"a b cd"
```

# Simulate input/Mouse<a id="sec-418"></a>

Works with: Rust version 1.25+

Library: AutoPilot

```rust
extern crate autopilot;
extern crate rand;
use rand::Rng;
¬†
// Moves the mouse in a sine wave across the screen.
const TWO_PI: f64 = std::f64::consts::PI * 2.0;
fn sine_mouse_wave() -> Result<(), autopilot::mouse::MouseError> {
    let screen_size = autopilot::screen::size();
    let scoped_height = screen_size.height / 2.0 - 10.0; // Stay in screen bounds.
    for x in 0..screen_size.width as u64 {
        let y = (scoped_height * ((TWO_PI * x as f64) / screen_size.width).sin() + scoped_height)
            .round();
        let duration: u64 = rand::thread_rng().gen_range(1, 3);
        try!(autopilot::mouse::move_to(autopilot::geometry::Point::new(
            x as f64,
            y as f64
        )));
        std::thread::sleep(std::time::Duration::from_millis(duration));
    }
    Ok(())
}
¬†
fn main() {
    sine_mouse_wave().expect("Unable to move mouse");
}
```

# Draw a pixel<a id="sec-419"></a>

Task

Create a window and draw a pixel in it, subject to the following:

¬†the window is 320 x 240 ¬†the color of the pixel must be red (255,0,0) ¬†the position of the pixel is x = 100, y = 100

Library: piston<sub>window</sub>

Library: image

Output Image:

RustOut

```rust
extern crate piston_window;
extern crate image;
¬†
use piston_window::*;
¬†
fn main() {
    let (width, height) = (320, 240);
¬†
    let mut window: PistonWindow =
        WindowSettings::new("Red Pixel", [width, height])
        .exit_on_esc(true).build().unwrap();
¬†
    // Since we cant manipulate pixels directly, we need to manipulate the pixels on a canvas.
    // Only issue is that sub-pixels exist (which is probably why the red pixel looks like a smear on the output image)
    let mut canvas = image::ImageBuffer::new(width, height);
    canvas.put_pixel(100, 100, image::Rgba([0xff, 0, 0, 0xff]));
¬†
    // Transform into a texture so piston can use it.
    let texture: G2dTexture = Texture::from_image(
        &mut window.factory,
        &canvas,
        &TextureSettings::new()
    ).unwrap();
¬†
    // The window event loop.
    while let Some(event) = window.next() {
        window.draw_2d(&event, |context, graphics| {
            clear([1.0; 4], graphics);
            image(&texture,
            context.transform,
            graphics);
        });
    }
}
¬†
```

# Banker's algorithm<a id="sec-420"></a>

This page uses content from Wikipedia. The original article was at Banker's algorithm. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

The Banker's algorithm is a resource allocation and deadlock avoidance algorithm developed by Edsger Dijkstra that tests for safety by simulating the allocation of predetermined maximum possible amounts of all resources, and then makes a "s-state" check to test for possible deadlock conditions for all other pending activities, before deciding whether allocation should be allowed to continue.

Example input[edit]

Assuming that the system distinguishes between four types of resources, (A, B, C and D), the following is an example of how those resources could be distributed. Note that this example shows the system at an instant before a new request for resources arrives. Also, the types and number of resources are abstracted. Real systems, for example, would deal with much larger quantities of each resource.

```
Total resources in system:
A B C D
6 5 7 6

```

```
Available system resources are:
A B C D
3 1 1 2

```

```
Processes (currently allocated resources):
   A B C D
P1 1 2 2 1
P2 1 0 3 3
P3 1 2 1 0

```

```
Processes (maximum resources):
   A B C D
P1 3 3 2 2
P2 1 2 3 4
P3 1 3 5 0

```

```
Need= maximum resources - currently allocated resources
Processes (need resources):
   A B C D
P1 2 1 0 1
P2 0 2 0 1
P3 0 1 4 0

```

Adapted from the C language version. It crashes for invalid input.

```rust
¬†
fn read_numbers<T>() -> Vec<T>
where T: std::str::FromStr {
    use std::io::Write;
    std::io::stdout().flush().unwrap();
¬†
    let mut line = String::new();
    std::io::stdin().read_line(&mut line).unwrap();
    line.split(" ").map(|word| word.trim().parse::<T>().ok().unwrap()).collect()
}
¬†
fn main() {
    print!("Enter the number of resources: ");
    let r = read_numbers()[0];
¬†
    print!("Enter the number of processes: ");
    let p = read_numbers()[0];
    let mut running = vec![true; p];
    let mut count = p;
¬†
    print!("Enter the {}-item claim vector: ", r);
    let max_res = read_numbers::<u32>();
¬†
    println!("Enter the {}-line {}-column allocated-resource table:", p, r);
    let mut curr = vec![vec![0; 0]; p];
    for i in 0..p {
        curr[i] = read_numbers::<u32>();
    }
¬†
    println!("Enter the {}-line {}-column maximum-claim table:", p, r);
    let mut max_claim = vec![vec![0; 0]; p];
    for i in 0..p {
        max_claim[i] = read_numbers::<u32>();
    }
¬†
    print!("The claim vector is: ");
    for i in 0..r {
        print!("{} ", max_res[i]);
    }
    println!();
¬†
    println!("The allocated resources table is:");
    for i in 0..p {
        for j in 0..r {
            print!("\t{}", curr[i][j]);
        }
        println!();
    }
¬†
    println!("The maximum claims table is:");
    for i in 0..p {
        for j in 0..r {
            print!("\t{}", max_claim[i][j]);
        }
        println!();
    }
¬†
    let mut alloc = vec![0; r];
    for i in 0..p {
        for j in 0..r {
            alloc[j] += curr[i][j];
        }
    }
¬†
    print!("The allocated resources are: ");
    for i in 0..r {
        print!("{} ", alloc[i]);
    }
    println!();
    let mut avl = vec![0; r];
    for i in 0..r {
        avl[i] = max_res[i] - alloc[i];
    }
¬†
    print!("The available resources are: ");
    for i in 0..r {
        print!("{} ", avl[i]);
    }
    println!();
¬†
    while count¬†!= 0 {
        let mut safe = false;
        for i in 0..p {
            if running[i] {
                let mut exec = true;
                for j in 0..r {
                    if max_claim[i][j] - curr[i][j] > avl[j] {
                        exec = false;
                        break;
                    }
                }
¬†
                if exec {
                    println!("Process {} is executing.", i + 1);
                    running[i] = false;
                    count -= 1;
                    safe = true;
                    for j in 0..r {
                        avl[j] += curr[i][j];
                    }
                    break;
                }
            }
        }
¬†
        if safe {
            println!("The process is in safe state.");
        }
        else {
            println!("The processes are in unsafe state.");
            break;
        }
¬†
        print!("The available vector is: ");
        for i in 0..r {
            print!("{} ", avl[i]);
        }
        println!();
    }
}
¬†
```

Input and Output:

```rust
Enter the number of resources: 4
Enter the number of processes: 5
Enter the 4-item claim vector: 8 5 9 7
Enter the 5-line 4-column allocated-resource table:
2 0 1 1
0 1 2 1
4 0 0 3
0 2 1 0
1 0 3 0
Enter the 5-line 4-column maximum-claim table:
3 2 1 4
0 2 5 2
5 1 0 5
1 5 3 0
3 0 3 3
The claim vector is: 8 5 9 7 
The allocated resources table is:
  2	0	1	1
  0	1	2	1
  4	0	0	3
  0	2	1	0
  1	0	3	0
The maximum claims table is:
  3	2	1	4
  0	2	5	2
  5	1	0	5
  1	5	3	0
  3	0	3	3
The allocated resources are: 7 3 7 5 
The available resources are: 1 2 2 2 
Process 3 is executing.
The process is in safe state.
The available vector is: 5 2 2 5 
Process 1 is executing.
The process is in safe state.
The available vector is: 7 2 3 6 
Process 2 is executing.
The process is in safe state.
The available vector is: 7 3 5 7 
Process 4 is executing.
The process is in safe state.
The available vector is: 7 5 6 7 
Process 5 is executing.
The process is in safe state.
The available vector is: 8 5 9 7 

```

# Hello world/Line printer<a id="sec-421"></a>
